# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Zilliqa Research
# This file is distributed under the same license as the scilla中文文档 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: scilla中文文档 \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-21 15:18+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../interface.rst:5
msgid "Interpreter Interface"
msgstr "解释器接口"

#: ../interface.rst:7
msgid ""
"The Scilla interpreter provides a calling interface that enables users to"
" invoke transitions with specified inputs and obtain outputs. Execution "
"of a transition with supplied inputs will result in a set of outputs, and"
" a change in the smart contract mutable state."
msgstr "Scilla 解释器提供了一个调用接口，使用户能够使用指定的输入调用 transition 并获得输出。 使用提供的输入执行 transition 将产生一组输出，以及智能合约可变状态的变化。"

#: ../interface.rst:15
msgid "Calling Interface"
msgstr "调用接口"

#: ../interface.rst:17
msgid ""
"A transition defined in a contract can be called either by the issuance "
"of a transaction, or by message calls from another contract. The same "
"calling interface will be used to call the contract via external "
"transactions and inter-contract message calls."
msgstr "在合约所定义的 transaction 可以通过发行事务，或者从其他合约消息调用而被调用。相同的调用接口将被用来调用通过外部交易和合约间的消息调用合约。"

#: ../interface.rst:22
msgid ""
"The inputs to the interpreter (``scilla-runner``) consists of four input "
"JSON files as described below. Every invocation of the interpreter to "
"execute a transition must be provided with these four JSON inputs: ::"
msgstr "解释器 (``scilla-runner``) 的输入由四个输入 JSON 文件组成，如下所述。 每次调用解释器来执行 transition 都必须提供这四个 JSON 输入："

#: ../interface.rst:28
msgid ""
"The interpreter executable can be run either to create a contract "
"(denoted ``CreateContract``) or to invoke a transition in a contract "
"(``InvokeContract``). Depending on which of these two, some of the "
"arguments will be absent. The table below outlays the arguments that "
"should be present in each of these two cases.  A ``CreateContract`` is "
"distinguished from an ``InvokeContract``, based on the presence of "
"``input_message.json`` and ``input_state.json``. If these arguments are "
"absent, then the interpreter will evaluate it as a ``CreateContract``. "
"Else, it will treat it as an ``InvokeContract``. Note that for "
"``CreateContract``, the interpreter only performs basic checks such as "
"matching the contract’s immutable parameters with ``init.json`` and "
"whether the contract definition is free of syntax errors."
msgstr "解释器可执行文件可以运行以创建合约（表示为 ``CreateContract``）或调用合约中的 transition（``InvokeContract``）。 根据这两者中的任何一个，都将导致某些论点不存在。 下表列出了在这两种情况下应该出现的论点。 ``CreateContract`` 与 ``InvokeContract`` 的区别在于 ``input_message.json`` 和 ``input_state.json`` 的存在。 如果这些参数不存在，那么解释器会将其评估为 ``CreateContract``。 否则，它会将其视为 ``InvokeContract``。 请注意，对于 ``CreateContract``，解释器仅执行基本检查，例如将合约的不可变参数与 ``init.json`` 匹配以及合约定义有没有语法错误。"

#: ../interface.rst:42
msgid "Present"
msgstr "当前值"

#: ../interface.rst:44
msgid "Input"
msgstr "输入"

#: ../interface.rst:44 ../interface.rst:74 ../interface.rst:260
#: ../interface.rst:453 ../interface.rst:469 ../interface.rst:491
msgid "Description"
msgstr "描述"

#: ../interface.rst:44
msgid "``CreateContract``"
msgstr ""

#: ../interface.rst:44
msgid "``InvokeContract``"
msgstr ""

#: ../interface.rst:46
msgid "``init.json``"
msgstr ""

#: ../interface.rst:46
msgid "Immutable contract parameters"
msgstr "不可变合约参数"

#: ../interface.rst:46 ../interface.rst:48 ../interface.rst:50
#: ../interface.rst:52 ../interface.rst:54 ../interface.rst:56
msgid "Yes"
msgstr ""

#: ../interface.rst:48
msgid "``input_state.json``"
msgstr ""

#: ../interface.rst:48
msgid "Mutable contract state"
msgstr "可变合约状态"

#: ../interface.rst:48 ../interface.rst:52
msgid "No"
msgstr ""

#: ../interface.rst:50
msgid "``input_blockchain.json``"
msgstr ""

#: ../interface.rst:50
msgid "Blockchain state"
msgstr "区块链状态"

#: ../interface.rst:52
msgid "``input_message.json``"
msgstr ""

#: ../interface.rst:52
msgid "Transition and parameters"
msgstr "transition 和参数"

#: ../interface.rst:54
msgid "``output.json``"
msgstr ""

#: ../interface.rst:54
msgid "Output"
msgstr "输出"

#: ../interface.rst:56
msgid "``input.scilla``"
msgstr ""

#: ../interface.rst:56
msgid "Input contract"
msgstr "输入合约"

#: ../interface.rst:59
msgid ""
"In addition to the command line arguments provided above, the interpreter"
" also expects a mandatory ``-gaslimit X`` argument (where ``X`` is a "
"positive integer value). If the contract or library module imports other "
"libraries (including the standard library), a `-libdir` option must be "
"provided, with a list of directories (in the standard PATH format) as the"
" argument, indicating directories to be searched for for finding the "
"libraries."
msgstr "除了上面提供的命令行参数之外，解释器还需要一个强制的 ``-gaslimit X`` 参数（其中 ``X`` 是一个正整数值）。 如果合约或库模块导入其他库（包括标准库），则必须提供 ``-libdir`` 选项，以目录列表（标准 PATH 格式）作为参数，指出要搜索的目录从而查找库。"

#: ../interface.rst:67
msgid "Initializing the Immutable State"
msgstr "初始化不可变状态"

#: ../interface.rst:69
msgid ""
"``init.json`` defines the values of the immutable parameters of a "
"contract. It does not change between invocations.  The JSON is an array "
"of objects, each of which contains the following fields:"
msgstr "``init.json`` 限定了合约的不可变参数的值。 它不会在调用之间改变。JSON 是一个包含以下字段的对象数组："

#: ../interface.rst:74 ../interface.rst:260 ../interface.rst:453
#: ../interface.rst:469 ../interface.rst:491
msgid "Field"
msgstr "字段"

#: ../interface.rst:76
msgid "``vname``"
msgstr ""

#: ../interface.rst:76
msgid "Name of the immutable contract parameter"
msgstr "不可变合约参数的名称"

#: ../interface.rst:77
msgid "``type``"
msgstr ""

#: ../interface.rst:77
msgid "Type of the immutable contract parameter"
msgstr "不可变合约参数的类型"

#: ../interface.rst:78
msgid "``value``"
msgstr ""

#: ../interface.rst:78
msgid "Value of the immutable contract parameter"
msgstr "不可变合约参数的值"

#: ../interface.rst:81
msgid ""
"``init.json`` must specify ``_scilla_version`` with type ``Uint32``, "
"specifying a value that is the same as specified in the contract's "
"source. Additionally, the blockchain will provide two implicit contract "
"parameters ``_this_address``, a ``ByStr20`` value denoting the address of"
" the contract itself, and ``_creation_block``, a ``BNum`` value denoting "
"the block in which the contract is / was created. While working with the "
"offline interpreter, you may need to provide these values in the "
"``init.json`` yourself."
msgstr "``init.json`` 必须指定类型为 ``Uint32`` 的 ``_scilla_version``，指定一个与合约源中指定的值相同的值。 此外，区块链将提供两个隐式合约参数 ``_this_address``，一个表示合约本身地址的 ``ByStr20`` 值，和 一个 ``BNum`` 值 ``_creation_block``，表示以前和现在创建合约的区块。 在使用离线解释器时，你可能需要自己在 ``init.json`` 中提供这些值。"

#: ../interface.rst:90 ../interface.rst:278 ../interface.rst:502
msgid "Example 1"
msgstr "例1"

#: ../interface.rst:92
msgid ""
"For the ``HelloWorld.scilla`` contract fragment given below, we have only"
" one immutable parameter ``owner``."
msgstr "对于下面给出的 ``HelloWorld.scilla`` 合约片段，我们只有一个不可变参数 ``owner``。"

#: ../interface.rst:102 ../interface.rst:146
msgid "A sample ``init.json`` for this contract will look like the following:"
msgstr "此合约的示例 ``init.json`` 将如下所示："

#: ../interface.rst:131 ../interface.rst:298 ../interface.rst:553
msgid "Example 2"
msgstr "例2"

#: ../interface.rst:133
msgid ""
"For the ``Crowdfunding.scilla`` contract fragment given below, we have "
"three immutable parameters ``owner``, ``max_block`` and ``goal``."
msgstr "对于下面给出的 ``Crowdfunding.scilla`` 合约片段，我们有三个不可变参数 ``owner``、``max_block`` 和 ``goal``。"

#: ../interface.rst:185
msgid "Example 3: Using Address Types"
msgstr "例3：使用地址类型"

#: ../interface.rst:187
msgid ""
"Whenever a contract has an immutable parameter of an address type, the "
"type ``ByStr20`` must be used in the to initialise the parameter."
msgstr "每当一个合约有一个地址类型的不可变参数时，类型 ``ByStr20`` 必须用于初始化参数。"

#: ../interface.rst:190
msgid ""
"For the ``SimpleExchange`` we have a single the immutable parameter, "
"which has an address type:"
msgstr "对于 ``SimpleExchange``，我们有一个不可变参数，它具有地址类型："

#: ../interface.rst:200
msgid ""
"The JSON entry for the ``initial_admin`` parameter must use the type "
"``ByStr20`` rather than the type ``ByStr20 with end``, so an example "
"``init.json`` for this contract could like the following:"
msgstr "``initial_admin`` 参数的 JSON 条目必须使用类型 ``ByStr20`` 而不是类型 ``ByStr20 with end``，因此此合约的示例 ``init.json`` 可能如下所示："

#: ../interface.rst:234
msgid "Input Blockchain State"
msgstr "输入区块链状态"

#: ../interface.rst:236
msgid ""
"``input_blockchain.json`` feeds the current blockchain state to the "
"interpreter. It is similar to ``init.json``, except that it is a fixed "
"size array of objects, where each object has ``vname`` fields only from a"
" predetermined set (which correspond to actual blockchain state "
"variables)."
msgstr "``input_blockchain.json`` 将当前区块链状态提供给解释器。 它与 ``init.json`` 类似，不同之处在于它是一个固定大小的对象数组，其中每个对象只有来自预定集合（对应于实际区块链状态变量）的 ``vname`` 字段。"

#: ../interface.rst:241
msgid ""
"**Permitted JSON fields:** At the moment, the only blockchain value that "
"is exposed to contracts is the current ``BLOCKNUMBER``."
msgstr "**允许JSON字段：** 目前，暴露于合约的唯一区块链值是当前 ``BLOCKNUMBER``。"

#: ../interface.rst:254
msgid "Input Message"
msgstr "输入消息"

#: ../interface.rst:256
msgid ""
"``input_message.json`` contains the information required to invoke a "
"transition. The json is an array containing the following four objects:"
msgstr "``input_message.json`` 包含调用 transition 所需的信息。 这个 json 是一个包含以下四个对象的数组："

#: ../interface.rst:262 ../interface.rst:471
msgid "``_tag``"
msgstr ""

#: ../interface.rst:262 ../interface.rst:471
msgid "Transition to be invoked"
msgstr "要调用的 transition"

#: ../interface.rst:263 ../interface.rst:472
msgid "``_amount``"
msgstr ""

#: ../interface.rst:263 ../interface.rst:472
msgid "Number of QA to be transferred"
msgstr "要转移的QA数量"

#: ../interface.rst:264
msgid "``_sender``"
msgstr ""

#: ../interface.rst:264
msgid "Address of the invoker (in a chain call, this is the immediate caller)"
msgstr "调用者的地址（在链式调用中，这是直接调用者）"

#: ../interface.rst:265
msgid "``_origin``"
msgstr ""

#: ../interface.rst:265
msgid "Address from which the transaction originated"
msgstr "发起交易的地址"

#: ../interface.rst:266 ../interface.rst:474 ../interface.rst:494
msgid "``params``"
msgstr ""

#: ../interface.rst:266
msgid "An array of parameter objects"
msgstr "参数对象数组"

#: ../interface.rst:270
msgid ""
"All the four fields are mandatory. ``params`` can be empty if the "
"transition takes no parameters."
msgstr "所有四个字段都是强制性的。如果 transition 不带任何参数，则 ``params`` 可以为空。"

#: ../interface.rst:273 ../interface.rst:478
msgid ""
"The ``params`` array is encoded similar to how ``init.json`` is encoded, "
"with each parameter specifying the (``vname``, ``type``, ``value``) that "
"has to be passed to the transition that is being invoked."
msgstr "``params`` 数组的编码方式类似于 ``init.json`` 的编码方式，每个参数指定必须传递给正在调用的 transition 的 (``vname``、``type``、``value``)。"

#: ../interface.rst:279 ../interface.rst:299
msgid "For the following transition:"
msgstr "对于以下 transition："

#: ../interface.rst:285 ../interface.rst:305
msgid "an example ``input_message.json`` is given below:"
msgstr "下面给出了一个示例 ``input_message.json``："

#: ../interface.rst:334
msgid "Example 3: Using user-defined types"
msgstr "例3：使用用户自定义类型"

#: ../interface.rst:338
msgid ""
"Due to a bug in the Scilla implementation the information in this section"
" is only valid from Scilla version 0.10.0 and forwards. Contracts written"
" in Scilla versions prior to 0.10.0 and which exploit this bug will have "
"to be rewritten and redeployed, as they will no longer work from version "
"0.10.0 and onwards."
msgstr "由于 Scilla 实现中的错误，本节中的信息仅从 Scilla 版本 0.10.0 开始有效。 使用 0.10.0 之前的 Scilla 版本编写并碰到此错误的合约必须重新编写和重新部署，因为它们将不再适用于 0.10.0 及更高版本。"

#: ../interface.rst:344
msgid ""
"When passing a value of user-defined type through the interpreter "
"interface, the json structure is identical to the one described in the "
"previous example. However, in the interpreter interface all types must be"
" fully qualified, which is defined as follows:"
msgstr "当通过解释器接口传递用户自定义类型的值时，json 结构与前面示例中描述的相同。 但是，在解释器接口中，所有类型都必须是完全限定的，其定义如下："

#: ../interface.rst:346
msgid ""
"For a user-defined type ``T`` defined in a module deployed at address "
"``A``, the fully qualified name is ``A.T``."
msgstr "对于在地址 ``A`` 部署的模块中定义的用户自定义类型 ``T``，完全限定名称是 ``A.T``。"

#: ../interface.rst:348
msgid ""
"For a user-defined constructor ``C`` defined in a module deployed at "
"address ``A``, the fully qualified name is ``A.C``."
msgstr "对于在地址 ``A`` 部署的模块中定义的用户自定义构造函数 ``C``，完全限定名称是 ``A.C``。"

#: ../interface.rst:352
msgid ""
"For the purposes of offline development the address of a module is "
"defined as the module's filename, without file extension. That is, if a "
"contract defines a type ``T`` with a constructor ``C`` in a file "
"``F.scilla``, then the fully qualified name of the type is ``F.T``, and "
"the fully qualified name of the constructor is ``F.C``."
msgstr "为了离线开发，模块的地址被定义为模块的文件名，没有文件扩展名。 也就是说，如果合约在文件 ``F.scilla`` 中定义了带有构造函数 ``C`` 的类型 ``T``，则该类型的完全限定名称为 ``F.T``，构造函数的完全限定名称为 ``F.C``。"

#: ../interface.rst:359
msgid ""
"As an example consider a contract that implements a simple board game. "
"The contract might define a type ``Direction`` and a transition "
"``MoveAction`` as follows:"
msgstr "例如，考虑一个实现简单棋盘游戏的合约。 合约可能定义一个类型 ``Direction`` 和一个 transition ``MoveAction``，如下："

#: ../interface.rst:374
msgid ""
"Say that the contract has been deployed at address "
"``0x1234567890123456789012345678906784567890``. To invoke the transition "
"with parameters ``East`` and ``2``, use the type name "
"``0x1234567890123456789012345678906784567890.Direction`` and the "
"constructor name ``0x1234567890123456789012345678906784567890.East`` in "
"the message json:"
msgstr "假设合约已部署在地址 ``0x1234567890123456789012345678906784567890``。为了调用带有参数 ``East`` 和 ``2`` 的 transition，则需使用类型名称 ``0x1234567890123456789012345678906784567890.Direction`` 和在消息 JSON 中的构造名称``0x1234567890123456789012345678906784567890.East``："

#: ../interface.rst:403
msgid ""
"If a contract has immutable fields of user-defined types, then the fields"
" must also be initialised using fully qualified names in the associated "
"``init.json``."
msgstr "如果合约具有用户自定义类型的不可变字段，则还必须使用关联的 ``init.json`` 中的完全限定名称初始化这些字段。"

#: ../interface.rst:406
msgid "Example 4: Using Address Types"
msgstr "例4：使用地址类型"

#: ../interface.rst:408
msgid ""
"When passing an address value the type ``ByStr20`` must be used. It is "
"not possible to use address types (``ByStr20 with ... end``) in messages."
msgstr "传递地址值时，必须使用类型 ``ByStr20``。 不能在消息中使用地址类型（``ByStr20 with ... end``）。"

#: ../interface.rst:412
msgid "This means that for the following transition"
msgstr "这意味着对于接下来的 transition"

#: ../interface.rst:421
msgid ""
"the ``input_message.json`` must use the type ``ByStr20`` for the "
"``new_token`` parameter, e.g., as follows:"
msgstr "所述 ``input_message.json`` 必须使用类型 ``ByStr20`` 作为 ``new_token`` 参数，例如，如下所示："

#: ../interface.rst:447
msgid "Interpreter Output"
msgstr "解释器输出"

#: ../interface.rst:449
msgid ""
"The interpreter will return a JSON object (``output.json``)  with the "
"following fields:"
msgstr "解释器将返回一个带有以下字段的 JSON 对象 (``output.json``)："

#: ../interface.rst:455
msgid "``scilla_major_version``"
msgstr ""

#: ../interface.rst:455
msgid "The major version of the Scilla language of this contract."
msgstr "本合约的 Scilla 语言的主要版本。"

#: ../interface.rst:456
msgid "``gas_remaining``"
msgstr ""

#: ../interface.rst:456
msgid "The remaining gas after invoking or deploying a contract."
msgstr "调用或部署合约后剩余的 gas。"

#: ../interface.rst:457
msgid "``_accepted``"
msgstr ""

#: ../interface.rst:457
msgid ""
"Whether the incoming QA have been accepted (Either ``\"true\"`` or "
"``\"false\"``)"
msgstr ""

#: ../interface.rst:458
msgid "``message``"
msgstr ""

#: ../interface.rst:458
msgid "The message to be sent to another contract/non-contract account, if any."
msgstr "传入的 QA 是否已被接受（``\"true\"`` 或 ``\"false\"``)"

#: ../interface.rst:459
msgid "``states``"
msgstr ""

#: ../interface.rst:459
msgid "An array of objects that form the new contract state"
msgstr "形成新合约状态的对象数组"

#: ../interface.rst:460
msgid "``events``"
msgstr ""

#: ../interface.rst:460
msgid ""
"An array of events emitted by the transition and the procedures it "
"invoked."
msgstr "由 transition  及其调用的 procedure 发出的事件数组。"

#: ../interface.rst:463
msgid ""
"``message`` is a JSON object with a similar format to "
"``input_message.json``, except that it has a ``_recipient`` field instead"
" of the ``_sender`` field. The fields in ``message`` are given below:"
msgstr "``message`` 是一个与 ``input_message.json`` 格式类似的 JSON 对象，除了它有一个 ``_recipient`` 字段而不是 ``_sender`` 字段。 消息中的字段如下："

#: ../interface.rst:473
msgid "``_recipient``"
msgstr ""

#: ../interface.rst:473
msgid "Address of the recipient"
msgstr "接收者地址"

#: ../interface.rst:474
msgid "An array of parameter objects to be passed"
msgstr "要传递的参数对象数组"

#: ../interface.rst:482
msgid ""
"``states`` is an array of objects that represents the mutable state of "
"the contract. Each entry of the ``states`` array also specifies "
"(``vname``, ``type``, ``value``)."
msgstr "``states`` 是一个对象数组，表示合约的可变状态。 状态数组的每个条目还指定了（``vname``、``type``、``value``）。"

#: ../interface.rst:486
msgid ""
"``events`` is an array of objects that represents the events emitted by "
"the transition. The fields in each object in the ``events`` array are "
"given below:"
msgstr "``events`` 是一个对象数组，表示 transition 发出的事件。 事件数组中每个对象的字段如下："

#: ../interface.rst:493
msgid "``_eventname``"
msgstr ""

#: ../interface.rst:493
msgid "The name of the event"
msgstr "事件名称"

#: ../interface.rst:494
msgid "An array of additional event fields"
msgstr "额外的事件字段数组"

#: ../interface.rst:497
msgid ""
"The ``params`` array is encoded similar to how ``init.json`` is encoded, "
"with each parameter specifying the (``vname``, ``type``, ``value``) of "
"each event field."
msgstr "``params`` 数组的编码方式类似于 ``init.json`` 的编码方式，每个参数都需指定事件字段的 (``vname``、``type``、``value``)。"

#: ../interface.rst:504
msgid ""
"An example of the output generated by ``Crowdfunding.scilla`` is given "
"below. The example also shows the format for maps in contract states."
msgstr "下面给出了 ``Crowdfunding.scilla`` 生成的输出示例。 该示例还显示了合同状态中映射的格式。"

#: ../interface.rst:555
msgid "For values of an ADT type, the ``value`` field contains three subfields:"
msgstr "对于 ADT 类型的值，``value`` 字段包含三个子字段："

#: ../interface.rst:557
msgid "``constructor``: The name of the constructor used to construct the value."
msgstr "``constructor``：用于构造值的构造函数的名称。"

#: ../interface.rst:559
msgid ""
"``argtypes``: An array of type instantiations. For the ``List`` and "
"``Option`` types, this array will contain one type, indicating the type "
"of the list elements or the optional value, respectively. For the "
"``Pair`` type, the array will contain two types, indicating the types of "
"the two values in the pair. For all other ADTs, the array will be empty."
msgstr "``argtypes``：类型实例的数组。对于 ``List`` 和 ``Option`` 类型，这个数组将包含一种类型，分别指示列表中的元素或可选值的类型。对于 ``Pair`` 类型，数组将包含两种类型，表示该类型的 pair 中的两个值。对于所有其他抽象数据类型，数组都将是空数组。"

#: ../interface.rst:566
msgid "``arguments``: The arguments to the constructor."
msgstr "``arguments``：该构造函数的参数。"

#: ../interface.rst:568
msgid ""
"The following example shows how values of the ``List`` and ``Option`` "
"types are represented in the output json:"
msgstr "以下示例显示了如何在输出 json 中表示 ``List`` 和 ``Option`` 类型的值："

#: ../interface.rst:618
msgid "Input Mutable Contract State"
msgstr "输入可变合约状态"

#: ../interface.rst:620
msgid ""
"``input_state.json`` contains the current value of mutable state "
"variables. It has the same forms  as the ``states`` field in "
"``output.json``.  An example of ``input_state.json`` for "
"``Crowdfunding.scilla`` is given below."
msgstr "``input_state.json`` 包含可变状态变量的当前值。 它与 ``output.json`` 中的 ``states`` 字段具有相同的形式。 下面给出了 ``Crowdfunding.scilla`` 的 ``input_state.json`` 示例。"

