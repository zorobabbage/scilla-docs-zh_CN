# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Zilliqa Research
# This file is distributed under the same license as the scilla中文文档 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: scilla中文文档 \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-21 15:18+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../scilla-in-depth.rst:2
msgid "Scilla in Depth"
msgstr "Scilla深度解析"

#: ../scilla-in-depth.rst:5
msgid "Structure of a Scilla Contract"
msgstr "Scilla 合约结构"

#: ../scilla-in-depth.rst:8
msgid ""
"The general structure of a Scilla contract is given in the code fragment "
"below:"
msgstr "Scilla 合约的一般结构在下面的代码片段中给出："

#: ../scilla-in-depth.rst:10
msgid ""
"The contract starts with the declaration of ``scilla_version``, which "
"indicates which major Scilla version the contract uses."
msgstr "合约以 ``scilla_version`` 的声明开始，它指明合约使用的 Scilla 主版本号。"

#: ../scilla-in-depth.rst:13
msgid ""
"Then follows the declaration of a ``library`` that contains purely "
"mathematical functions, e.g., a function to compute the Boolean ``AND`` "
"of two bits, or a function computing the factorial of a given natural "
"number."
msgstr "然后是一个包含纯数学函数的 ``library`` 声明，例如，一个计算两位布尔 ``AND`` 的函数，或一个计算给定自然数阶乘的函数。"

#: ../scilla-in-depth.rst:18
msgid ""
"Then follows the actual contract definition declared using the keyword "
"``contract``."
msgstr "然后是遵循使用关键字 ``contract`` 声明的实际合约定义。"

#: ../scilla-in-depth.rst:21
msgid "Within a contract, there are then four distinct parts:"
msgstr "在合约中，有四个不同的部分："

#: ../scilla-in-depth.rst:23
msgid "The first part declares the immutable parameters of the contract."
msgstr "第一部分声明了合约的不可变参数。"

#: ../scilla-in-depth.rst:24
msgid ""
"The second part describes the contract's constraint, which must be valid "
"when the contract is deployed."
msgstr "第二部分描述了合约的约束，约束指明在部署合约时必须是有效的。"

#: ../scilla-in-depth.rst:26
msgid "The third part declares the mutable fields."
msgstr "第三部分声明了可变字段。"

#: ../scilla-in-depth.rst:27
msgid "The fourth part contains all ``transition`` and ``procedure`` definitions."
msgstr "第四部分包含所有 ``transition`` 和 ``procedure`` 定义。"

#: ../scilla-in-depth.rst:102
msgid "Immutable Contract Parameters"
msgstr "不可变合约参数"

#: ../scilla-in-depth.rst:104
msgid ""
"`Immutable parameters` are the contract's initial parameters whose values"
" are defined when the contract is deployed, and cannot be modified "
"afterwards."
msgstr "不可变参数是合约的初始参数，其值在合约部署时定义，之后无法修改。"

#: ../scilla-in-depth.rst:108
msgid "Immutable parameters are declared using the following syntax:"
msgstr "不可变参数使用以下语法声明："

#: ../scilla-in-depth.rst:116
msgid ""
"Each declaration consists of a parameter name (an identifier) and "
"followed by its type, separated by ``:``. Multiple parameter declarations"
" are separated by ``,``. The initialization values for parameters are to "
"be specified when the contract is deployed."
msgstr "每个声明都包含一个参数名称（一个标识符），后跟它的类型，用 ``:`` 分隔。 多个参数声明由 ``,`` 分隔。 参数的初始化值将在部署合约时指定。"

#: ../scilla-in-depth.rst:123
msgid ""
"In addition to the explicitly declared immutable parameters, a Scilla "
"contract has the following implicitly declared immutable contract "
"parameters"
msgstr "除了显式声明的不可变参数外，Scilla 合约还具有以下隐式声明的不可变合约参数"

#: ../scilla-in-depth.rst:126
msgid ""
"1. ``_this_address`` of type ``ByStr20``, which is initialised to the "
"address of the contract when the contract is deployed."
msgstr "1. ``ByStr20`` 类型的 ``_this_address`` ，在合约部署时初始化为合约地址。"

#: ../scilla-in-depth.rst:129
msgid ""
"2. ``_creation_block`` of type ``BNum``, which is initialized to the "
"block number at which the contract is / was deployed."
msgstr "2. ``BNum`` 类型的 ``_creation_block`` ，不管在过去还是现在，它都被初始化为合约部署时的区块号。"

#: ../scilla-in-depth.rst:132
msgid ""
"These parameters can be freely read within the implementation without "
"having to dereference it using ``<-`` and cannot be modified with ``:=``."
msgstr "这些参数可以在实现中自由读取，而不必使用  ``<-``  来取消它的引用调用，并且不能使用 ``:=`` 修改。"

#: ../scilla-in-depth.rst:136
msgid "Contract Constraints"
msgstr "合约约束"

#: ../scilla-in-depth.rst:138
msgid ""
"A `contract constraint` is a requirement placed on the contract's "
"immutable parameters. A contract constraint provides a way of "
"establishing a contract invariant as soon as the contract is deployed, "
"thus preventing the contract being deployed with nonsensical parameters."
msgstr "合约约束是对合约不可变参数的要求。 合约约束提供了一种在合约部署后立即建立合约不变性的方法，从而防止合约使用无意义的参数进行部署。"

#: ../scilla-in-depth.rst:144
msgid "A contract constraint is declared using the following syntax:"
msgstr "使用以下语法声明合约约束："

#: ../scilla-in-depth.rst:152
msgid "The constraint must be an expression of type ``Bool``."
msgstr "约束必须是 ``Bool`` 类型的表达式。"

#: ../scilla-in-depth.rst:154
msgid ""
"The constraint is checked when the contract is deployed. Contract "
"deployment only succeeds if the constraint evaluates to ``True``. If it "
"evaluates to ``False``, then the deployment fails."
msgstr "在部署合约时检查约束。 仅当约束判定为 ``True`` 时，合同部署才会成功。 如果判定结果为 ``False`` ，则部署失败。"

#: ../scilla-in-depth.rst:158
msgid ""
"Here is a simple example of using contract constraints to make sure a "
"contract with a limited period of functioning is not deployed `after` "
"that period:"
msgstr "下面是一个简单的例子，它使用合约约束来确保在该期限之后不会部署具有有限功能期限的合约："

#: ../scilla-in-depth.rst:169
msgid ""
"The snippet above uses the implicit contract parameter "
"``_creation_block`` described in :ref:`immutable-contract-parameters`."
msgstr "上面的代码片段使用了 :ref:`immutable-contract-parameters` 中描述的隐式合约参数 ``_creation_block`` 。"

#: ../scilla-in-depth.rst:174
msgid ""
"Declaring a contract constraint is optional. If no constraint is "
"declared, then the constraint is assumed to simply be ``True``."
msgstr "声明合同约束是可选的。 如果未声明约束，则假定该约束被简单地默认为 ``True`` 。"

#: ../scilla-in-depth.rst:180
msgid "Mutable Fields"
msgstr "可变字段"

#: ../scilla-in-depth.rst:182
msgid ""
"`Mutable fields` represent the mutable state (mutable variables) of the "
"contract. They are declared after the immutable parameters, with each "
"declaration prefixed with the keyword ``field``."
msgstr "可变字段代表合约的可变状态（可变变量）。 它们在不可变参数之后声明，每个声明都以关键字 ``field`` 为前缀。"

#: ../scilla-in-depth.rst:192
msgid ""
"Each expression here is an initialiser for the field in question. The "
"definitions complete the initial state of the contract, at the time of "
"creation.  As the contract executes a transition, the values of these "
"fields get modified."
msgstr "这里的每个表达式都是相关字段的初始值设定项。 这些定义在创建时完成了合约的初始状态。 当合约执行 transition 时，这些字段的值会被修改。"

#: ../scilla-in-depth.rst:199
msgid ""
"In addition to the explicitly declared mutable fields, a Scilla contract "
"has an implicitly declared mutable field ``_balance`` of type "
"``Uint128``, which is initialised to 0 when the contract is deployed. The"
" ``_balance`` field keeps the amount of funds held by the contract, "
"measured in QA (1 ZIL = 1,000,000,000,000 QA).  This field can be freely "
"read within the implementation, but can only modified by explicitly "
"transferring funds to other accounts (using ``send``), or by accepting "
"money from incoming messages (using ``accept``)."
msgstr "除了显式声明的可变字段之外，Scilla 合约还有一个隐式声明的 ``Uint128`` 类型的可变字段 ``_balance`` ，在部署合约时将其初始化为 0。 ``_balance`` 字段保存合约持有的资金量，以 QA 衡量（1 ZIL = 1,000,000,000,000 QA）。 该字段可以在实现中自由读取，但只能通过明确地将资金转移到其他帐户（使用 ``send`` ）或通过接收来自传入消息的资金（使用 ``accept`` ）来修改。"

#: ../scilla-in-depth.rst:211
msgid "Both mutable fields and immutable parameters must be of a *storable* type:"
msgstr "可变字段和不可变参数都必须是可存储类型："

#: ../scilla-in-depth.rst:214
msgid ""
"Messages, events and the special ``Unit`` type are not storable. All "
"other primitive types like integers and strings are storable."
msgstr "消息、事件和特殊 ``Unit`` 类型不可存储。 所有其他原始类型（如整数和字符串）都是可存储的。"

#: ../scilla-in-depth.rst:218
msgid "Function types are not storable."
msgstr "函数类型不可存储。"

#: ../scilla-in-depth.rst:220
msgid "Complex types involving uninstantiated type variables are not storable."
msgstr "涉及未实例化类型变量的复杂类型不可存储。"

#: ../scilla-in-depth.rst:223
msgid ""
"Maps and ADT are storable if the types of their subvalues are storable. "
"For maps this means that the key type and the value type must both be "
"storable, and for ADTs this means that the type of every constructor "
"argument must be storable."
msgstr "如果映射和 ADT 的子值类型是可存储的，则它们是可存储的。 对于映射，这意味着键类型和值类型都必须是可存储的，对于 ADT，这意味着每个构造函数参数的类型都必须是可存储的。"

#: ../scilla-in-depth.rst:230
msgid "Units"
msgstr "单位"

#: ../scilla-in-depth.rst:232
msgid ""
"The Zilliqa protocol supports three basic tokens units - ZIL, LI (10^-6 "
"ZIL) and QA (10^-12 ZIL)."
msgstr "Zilliqa 协议支持三种基本的代币单元——ZIL、LI (10^-6 ZIL) 和 QA (10^-12 ZIL)。"

#: ../scilla-in-depth.rst:234
msgid ""
"The base unit used in Scilla smart contracts is QA. Hence, when using "
"money variables, it is important to attach the trailing zeroes that are "
"needed to represent it in QAs."
msgstr "Scilla 智能合约中使用的基本单位是 QA。 因此，在使用货币变量时，重要的是需要明确表明最后有多少个0附加在 QA 中。"

#: ../scilla-in-depth.rst:249
msgid "Transitions"
msgstr "Transitions"

#: ../scilla-in-depth.rst:251
msgid ""
"`Transitions` are a way to define how the state of the contract may "
"change. The transitions of a contract define the public interface for the"
" contract, since transitions may be invoked by sending a message to the "
"contract."
msgstr "transition 是一种定义合约状态如何改变的方式。 合约的 transition 定义了合约的公共接口，因为可以通过向合约发送消息来调用 transition。"

#: ../scilla-in-depth.rst:256
msgid ""
"Transitions are defined with the keyword ``transition`` followed by the "
"parameters to be passed. The definition ends with the ``end`` keyword."
msgstr "transition 是用关键字 ``transition`` 定义的，后跟要传递的参数。 定义以 ``end`` 关键字结束。"

#: ../scilla-in-depth.rst:266 ../scilla-in-depth.rst:334
msgid ""
"where ``vname : vtype`` specifies the name and type of each parameter and"
" multiple parameters are separated by ``,``."
msgstr "其中 ``vname : vtype`` 指定每个参数的名称和类型，多个参数之间用 ``,`` 分隔。"

#: ../scilla-in-depth.rst:272
msgid ""
"In addition to the parameters that are explicitly declared in the "
"definition, each transition has the following implicit parameters:"
msgstr "除了定义中显式声明的参数外，每个 transition  都有以下隐式参数："

#: ../scilla-in-depth.rst:275
msgid ""
"``_amount : Uint128`` : Incoming amount, in QA (see section above on the "
"units), sent by the sender. To transfer the money from the sender to the "
"contract, the transition must explicitly accept the money using the "
"``accept`` instruction. The money transfer does not happen if the "
"transition does not execute an ``accept``."
msgstr "``_amount : Uint128`` : 发送方发送的传入金额，在 QA 中（请参阅上面有关单位的部分）。 要将钱从发送方转移到合约，transition 必须使用 ``accept`` 指令明确接受资金。 如果 transition 不执行 ``accept`` ，则不会发生汇款。"

#: ../scilla-in-depth.rst:282
msgid ""
"``_sender : ByStr20 with end`` : The account address that triggered this "
"transition. If the transition was called by a contract account instead of"
" a user account, then ``_sender`` is the address of the contract that "
"called this transition. In a chain call, this is the contract that sent "
"the message invoking the current transition."
msgstr "``_sender : ByStr20 with end`` : 触发此 transition 的帐户地址。 如果 transition 是由合约账户而不是用户账户调用的，则 ``_sender`` 是调用此 transition 的合约的地址。 在链式调用中，这是发送调用当前 transition 的消息的合约。"

#: ../scilla-in-depth.rst:288
msgid ""
"``_origin : ByStr20 with end`` : The account address that initiated the "
"current transaction (which can possibly be a chain call). This is always "
"a user address, since contracts can never initiate transactions."
msgstr "``_origin : ByStr20 with end`` : 发起当前交易的账户地址（可能是链式调用）。 这始终是用户地址，因为合约永远无法发起交易。"

#: ../scilla-in-depth.rst:292
msgid ""
"The type ``ByStr20 with end`` is an `address type`. Address types are "
"explained in detail in the :ref:`Addresses <Addresses>` section."
msgstr "``ByStr20 with end`` 的类型是地址类型。 地址类型在 :ref:`地址 <Addresses>` 部分有详细说明。"

#: ../scilla-in-depth.rst:297
msgid "Transition parameters must be of a *serialisable* type:"
msgstr "transition 的参数必须是可序列化的类型："

#: ../scilla-in-depth.rst:299
msgid "Messages, events and the special ``Unit`` type are not serialisable."
msgstr "消息、事件和特殊 ``Unit`` 类型不可序列化。"

#: ../scilla-in-depth.rst:302
msgid ""
"Byte strings are serialisable. Addresses are serialisable only as "
"``ByStr20`` values. All other primitive types like integers and strings "
"are serialisable."
msgstr "字节字符串是可序列化的。 地址只能作为 ``ByStr20`` 值进行序列化。 所有其他原始类型（如整数和字符串）都是可序列化的。"

#: ../scilla-in-depth.rst:306
msgid "Function types and map types are not serialisable."
msgstr "函数类型和映射类型不可序列化。"

#: ../scilla-in-depth.rst:308
msgid ""
"Complex types involving uninstantiated type variables are not "
"serialisable."
msgstr "涉及未实例化类型变量的复杂类型不可序列化。"

#: ../scilla-in-depth.rst:311
msgid ""
"ADT are serialisable if the types of their subvalues are serialisable. "
"This means that the type of every constructor argument must be "
"serialisable."
msgstr "如果 ADT 的子值的类型是可序列化的，则 ADT 是可序列化的。 这意味着每个构造函数参数的类型都必须是可序列化的。"

#: ../scilla-in-depth.rst:316
msgid "Procedures"
msgstr "Procedures"

#: ../scilla-in-depth.rst:318
msgid ""
"`Procedures` are another way to define now the state of the contract may "
"change, but in contrast to transitions, procedures are not part of the "
"public interface of the contract, and may not be invoked by sending a "
"message to the contract. The only way to invoke a procedure is to call it"
" from a transition or from another procedure."
msgstr "procedure 是另一种定义合约状态的方法，现在合约的状态可能会改变，但与 transition 相反，procedure 不是合约公共接口的一部分，并且不能通过向合约发送消息来调用。 调用 procedure 的唯一方法是从 transition 或从另一个 procedure 调用它。"

#: ../scilla-in-depth.rst:324
msgid ""
"Procedures are defined with the keyword ``procedure`` followed by the "
"parameters to be passed. The definition ends with the ``end`` keyword."
msgstr "procedure 是用关键字 ``procedure`` 定义的，后跟要传递的参数。 定义以 ``end`` 关键字结束。"

#: ../scilla-in-depth.rst:337
msgid ""
"Once a procedure is defined it is available to be invoked from "
"transitions and procedures in the rest of the contract file. It is not "
"possible to invoke a procedure from transition or procedure defined "
"earlier in the contract, nor is it possible for a procedure to call "
"itself recursively."
msgstr "一旦定义了 procedure，就可以从合约文件其余部分的 transition 和 procedure 中调用它。 但是不能从合约中之前定义的 transition 或 procedure 中调用它，procedure 也不能递归调用自身。"

#: ../scilla-in-depth.rst:343
msgid ""
"Procedures are invoked using the name of the procedure followed by the "
"actual arguments to the procedure:"
msgstr "使用 procedure 名称后跟 procedure 的实际参数来调用 procedure："

#: ../scilla-in-depth.rst:352
msgid ""
"All arguments must be supplied when the procedure is invoked. A procedure"
" does not return a result."
msgstr "调用 procedure  时必须提供所有参数。 procedure 不返回结果。"

#: ../scilla-in-depth.rst:358
msgid ""
"The implicit transition parameters ``_sender``, ``_origin`` and "
"``_amount`` are implicitly passed to all the procedures that a transition"
" calls. There is therefore no need to declare those parameters explicitly"
" when defining a procedure."
msgstr "隐式 transition  参数 ``_sender`` 、``_origin`` 和 ``_amount`` 被隐式传递给 transition  调用的所有 procedure。 因此，在定义 procedure 时无需显式声明这些参数。"

#: ../scilla-in-depth.rst:365
msgid ""
"Procedure parameters cannot be (or contain) maps. If a procedure needs to"
" access a map, it is therefore necessary to either make the procedure "
"directly access the contract field containing the map, or use a library "
"function to perform the necessary computations on the map."
msgstr "procedure 参数不能是（或包含）映射。 如果一个 procedure  需要访问一个映射，就必须让该 procedure  直接访问包含该映射的合约字段，或者使用库函数在映射上执行必要的计算。"

#: ../scilla-in-depth.rst:373
msgid "Expressions"
msgstr "表达式"

#: ../scilla-in-depth.rst:375
msgid ""
"`Expressions` handle pure operations. Scilla contains the following types"
" of expressions:"
msgstr "表达式处理纯操作。 Scilla 包含以下类型的表达式："

#: ../scilla-in-depth.rst:377
msgid ""
"``let x = f`` : Give  ``f`` the name ``x`` in the contract. The binding "
"of ``x`` to ``f`` is **global** and extends to the end of the contract. "
"The following code fragment defines a constant ``one`` whose values is "
"``1`` of type ``Int32`` throughout the contract."
msgstr "``let x = f`` ：在合约中把 ``f`` 命名为 ``x``。 ``x`` 到 ``f`` 的绑定是全局的，并延伸到合约结束。 以下代码片段定义了一个常量 ``one`` ，其值在整个合约中都是 ``Int32`` 类型的 ``1`` 。"

#: ../scilla-in-depth.rst:386
msgid ""
"``let x = f in expr`` :  Bind ``f`` to the name ``x`` within expression "
"``expr``.  The binding here is **local** to ``expr`` only. The following "
"example binds the value of ``one`` to ``1`` of type ``Int32`` and ``two``"
" to ``2`` of type ``Int32`` in the expression ``builtin add one two``, "
"which adds ``1`` to ``2`` and hence evaluates to ``3`` of type ``Int32``."
msgstr "``let x = f in expr`` ：将 ``f`` 绑定到表达式 ``expr`` 中的名称 ``x`` 。 这里的绑定对 ``expr`` 来说仅仅是 **local** 。 以下示例将 ``Int32` 类型的 ``1`` 的值绑定到 ``one`` 以及将 ``Int32` 类型的 ``2`` 的值绑定到 ``two`` 并使用内置表达式 ``builtin add one two`` 计算，该表达式将 ``1`` 与 ``2`` 相加，因此计算结果为 ``Int32` 类型的 ``3``。"

#: ../scilla-in-depth.rst:399
msgid ""
"``{ <entry>_1 ; <entry>_2 ... }``: Message or event expression, where "
"each entry has the following form: ``b : x``. Here ``b`` is an identifier"
" and ``x`` a variable, whose value is bound to the identifier in the "
"message."
msgstr "``{ <entry>_1 ; <entry>_2 ... }`` ：消息或事件表达式，其中每个条目具有以下形式： ``b : x`` 。 这里 ``b`` 是一个标识符， ``x`` 是一个变量，其值绑定到消息中的标识符。"

#: ../scilla-in-depth.rst:404
msgid ""
"``fun (x : T) => expr`` : A function that takes an input ``x`` of type "
"``T`` and returns the value to which expression ``expr`` evaluates."
msgstr "``fun (x : T) => expr`` ：一个函数，它接受类型为 ``T`` 的输入 ``x`` 并返回表达式 ``expr`` 求值结果。"

#: ../scilla-in-depth.rst:407
msgid "``f x`` : Apply the function ``f`` to the parameter ``x``."
msgstr "``f x`` ：将函数 ``f`` 应用于参数 ``x`` 。"

#: ../scilla-in-depth.rst:409
msgid ""
"``tfun 'T => expr`` : A type function that takes ``'T`` as a parametric "
"type and returns the value to which expression ``expr`` evaluates. These "
"are typically used to build library functions. See the implementation of "
"fst_ for an example."
msgstr "``tfun 'T => expr`` ：一个类型函数，它将 ``'T`` 作为参数类型并返回表达式 ``expr` 求值结果。 这些通常用于构建库函数。 有关示例，请参阅 fst_ 的实现。"

#: ../scilla-in-depth.rst:415
msgid ""
"Shadowing of type variables is not currently allowed. E.g. ``tfun 'T => "
"tfun 'T => expr`` is not a valid expression."
msgstr "当前不允许隐藏类型变量。 例如。 ``tfun 'T => tfun 'T => expr`` 不是有效的表达式。"

#: ../scilla-in-depth.rst:418
msgid ""
"``@x T``: Apply the type function ``x`` to the type ``T``. This "
"specialises the type function ``x`` by instantiating the first type "
"variable of ``x`` to ``T``. Type applications are typically used when a "
"library function is about to be applied. See the example application of "
"fst_ for an example."
msgstr "``@x T`` ：将类型函数 ``x`` 应用于类型 ``T`` 。这通过将 ``x`` 的第一个类型变量实例化为 ``T`` 来专门化类型函数 ``x`` 。类型应用程序通常在即将应用库函数时使用。 有关示例，请参阅 fst_ 的示例应用程序。"

#: ../scilla-in-depth.rst:424
msgid "``builtin f x``: Apply the built-in function ``f`` on ``x``."
msgstr "``builtin f x`` ：在 ``x`` 上应用内置函数 ``f`` 。"

#: ../scilla-in-depth.rst:426
msgid ""
"``match`` expression: Matches a bound variable with patterns and "
"evaluates the expression in that clause. The ``match`` expression is "
"similar to the ``match`` expression in OCaml. The pattern to be matched "
"can be an ADT constructor (see ADTs_) with subpatterns, a variable, or a "
"wildcard ``_``. An ADT constructor pattern matches values constructed "
"with the same constructor if the subpatterns match the corresponding "
"subvalues. A variable matches anything, and binds the variable to the "
"value it matches in the expression of that clause. A wildcard matches "
"anything, but the value is then ignored."
msgstr "``match`` 表达式：将绑定变量与模式匹配并判断该子句中的表达式。  ``match`` 表达式类似于 OCaml 中的 ``match`` 表达式。 要匹配的模式可以是带有子模式、变量或通配符 ``_`` 的 ADT 构造函数（请参阅 ADTs_ ）。 如果子模式匹配相应的子值，则 ADT 构造函数模式匹配使用相同构造函数构造的值。 变量匹配任何内容，并将变量绑定到它在该子句的表达式中匹配的值。 通配符匹配任何内容，但随后会忽略该值。"

#: ../scilla-in-depth.rst:449
msgid ""
"A pattern-match must be exhaustive, i.e., every legal (type-safe) value "
"of ``x`` must be matched by a pattern. Additionally, every pattern must "
"be reachable, i.e., for each pattern there must be a legal (type-safe) "
"value of ``x`` that matches that pattern, and which does not match any "
"pattern preceding it."
msgstr "模式匹配必须是详尽的，即 ``x`` 的每个合法（类型安全）值都必须与模式匹配。 此外，每个模式都必须是可达的，即对于每个模式，必须有一个合法（类型安全）的 ``x`` 值与该模式匹配，并且不匹配它之前的任何模式。"

#: ../scilla-in-depth.rst:456
msgid "Statements"
msgstr "语句"

#: ../scilla-in-depth.rst:458
msgid ""
"Statements in Scilla are operations with effect, and hence not purely "
"mathematical. Scilla contains the following types of statements:"
msgstr "Scilla 中的语句是有效的运算，因此不是纯粹的数学运算。 Scilla 包含以下类型的语句："

#: ../scilla-in-depth.rst:461
msgid ""
"``x <- f`` : Fetch the value of the contract field ``f``, and store it "
"into the local variable ``x``."
msgstr "``x <- f`` ：获取合约字段 ``f`` 的值，并将其存储到局部变量 ``x`` 中。"

#: ../scilla-in-depth.rst:464
msgid ""
"``f := x`` : Update the mutable contract field ``f`` with the value of "
"``x``. ``x`` may be a local variable, or another contract field."
msgstr "``f := x`` ：用 ``x`` 的值更新可变合约字段 ``f`` 。 ``x`` 可能是一个局部变量，或另一个合约字段。"

#: ../scilla-in-depth.rst:467
msgid ""
"``x <- & BLOCKNUMBER`` : Fetch the value of the blockchain state variable"
" ``BLOCKNUMBER``, and store it into the local variable ``x``."
msgstr "``x <- & BLOCKNUMBER`` ：获取区块链状态变量 ``BLOCKNUMBER`` 的值，并将其存储到局部变量 ``x`` 中。"

#: ../scilla-in-depth.rst:471
msgid ""
"``x <- & c.f`` : Remote fetch. Fetch the value of the contract field "
"``f`` at address ``c``, and store it into the local variable ``x``. Note "
"that the type of ``c`` must be an address type containing the field "
"``f``. See the secion on :ref:`Addresses <Addresses>` for details on "
"address types."
msgstr "``x <- & c.f`` ：远程获取。 获取地址 ``c`` 处的合约字段 ``f`` 的值，并将其存储到局部变量 ``x`` 中。 请注意， ``c`` 的类型必须是包含字段 ``f`` 的地址类型。 有关地址类型的详细信息，请参阅 :ref:`地址 <Addresses>` 部分。"

#: ../scilla-in-depth.rst:477
msgid ""
"``v = e`` : Evaluate the expression ``e``, and assign the value to the "
"local variable ``v``."
msgstr "``v = e`` ：计算表达式 ``e`` ，并将值赋给局部变量 ``v`` 。"

#: ../scilla-in-depth.rst:480
msgid ""
"``p x y z`` : Invoke the procedure ``p`` with the arguments ``x``, ``y`` "
"and ``z``. The number of arguments supplied must correspond to the number"
" of arguments the procedure takes."
msgstr "``p x y z`` ：使用参数 ``x``、``y``  和 ``z`` 调用 procedure ``p``。 提供的参数数量必须与 procedure 采用的参数数量相对应。"

#: ../scilla-in-depth.rst:484
msgid ""
"``forall ls p`` : Invoke procedure ``p`` for each element in the list "
"``ls``. ``p`` should be defined to take exactly one argument whose type "
"is equal to an element of the list ``ls``."
msgstr "``forall ls p`` ：为列表 ``ls`` 中的每个元素调用 procedure ``p``。 ``p`` 应该被定义为只接受一个类型等于列表 ``ls`` 元素的参数。"

#: ../scilla-in-depth.rst:488
msgid "``match`` : Pattern-matching at statement level:"
msgstr "``match`` ：语句级别的模式匹配："

#: ../scilla-in-depth.rst:507
msgid ""
"``accept`` : Accept the QA of the message that invoked the transition. "
"The amount is automatically added to the ``_balance`` field of the "
"contract. If a message contains QA, but the invoked transition does not "
"accept the money, the money is transferred back to the sender of the "
"message. Not accepting the incoming amount (when it is non-zero) is not "
"an error."
msgstr "``accept`` ：接受调用 transition 的消息的 QA。 该金额会自动添加到合约的 ``_balance`` 字段中。 如果消息包含 QA，但调用的 transition 不接受这笔钱，则将钱转回给消息的发送者。 不接受传入金额（当它非零时）不是错误。"

#: ../scilla-in-depth.rst:514
msgid ""
"``send`` and ``event`` : Communication with the blockchain. See the next "
"section for details."
msgstr "``send`` 和 ``event``：与区块链的通信。 有关详细信息，请参阅下一节。"

#: ../scilla-in-depth.rst:517
msgid ""
"In-place map operations : Operations on contract fields of type ``Map``. "
"See the Maps_ section for details."
msgstr "原位映射操作：对 ``Map`` 类型的合约字段的操作。 有关详细信息，请参阅 Maps_ 部分。"

#: ../scilla-in-depth.rst:520
msgid "A sequence of statements must be separated by semicolons ``;``:"
msgstr "语句序列必须用分号分隔 ``;``："

#: ../scilla-in-depth.rst:531
msgid ""
"Notice that the final statement does not have a trailing ``;``, since "
"``;`` is used to separate statements rather than terminate them."
msgstr "请注意，最后的语句没有尾随 ``;``，因为 ``;`` 用于分隔语句而不是终止它们。"

#: ../scilla-in-depth.rst:536
msgid "Communication"
msgstr "通信"

#: ../scilla-in-depth.rst:538
msgid ""
"A contract can communicate with other contract and user accounts through "
"the ``send`` instruction:"
msgstr "一个合约可以通过 ``send`` 指令与其他合约和用户账户进行通信："

#: ../scilla-in-depth.rst:541
msgid "``send msgs`` : Send a list of messages ``msgs``."
msgstr "``send msgs``：发送 ``msgs`` 消息列表。"

#: ../scilla-in-depth.rst:543
msgid ""
"The following code snippet defines a ``msg`` with four entries ``_tag``, "
"``_recipient``, ``_amount`` and ``param``."
msgstr "以下代码片段定义了一条 ``msg``，其中包含四个条目 ``_tag``、``_recipient``、``_amount`` 和 ``param``。"

#: ../scilla-in-depth.rst:551
msgid ""
"A message passed to ``send`` must contain the mandatory fields ``_tag``, "
"``_recipient`` and ``_amount``."
msgstr "传递给 ``send`` 的消息必须包含必填字段 ``_tag``、``_recipient`` 和 ``_amount``。"

#: ../scilla-in-depth.rst:554
msgid ""
"The ``_recipient`` field (of type ``ByStr20``) is the blockchain address "
"that the message is to be sent to, and the ``_amount`` field (of type "
"``Uint128``) is the number of QA to be transferred to that account."
msgstr "``_recipient`` 字段（``ByStr20`` 类型）是消息要发送到的区块链地址，``_amount`` 字段（``Uint128`` 类型）是要转移到该帐户的 QA 数量。"

#: ../scilla-in-depth.rst:559
msgid ""
"The ``_tag`` field (of type ``String``) is only used when the value of "
"the ``_recipient`` field is the address of a contract. In this case, the "
"value of the ``_tag`` field is the name of the transition that is to be "
"invoked on the recipient contract. If the recipient is a user account, "
"the ``_tag`` field is ignored."
msgstr "``_tag`` 字段（``String`` 类型）仅在 ``_recipient`` 字段的值为合约地址时使用。 在这种情况下，``_tag`` 字段的值是要在接收方合约上调用的 transition 的名称。 如果收件人是用户帐户，则忽略 ``_tag`` 字段。"

#: ../scilla-in-depth.rst:567
msgid ""
"To make it possible to transfer funds from a contract to both contracts "
"and user accounts, use a standard transition name as per `ZRC-5 "
"<https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-5.md>`_, i.e. "
"``AddFunds``. Please make sure to check if a contract to which you intend"
" to send funds is implemented in adherence with ZRC-5 convention."
msgstr "为了能够将资金从合约转移到合约和用户账户，请使用 `ZRC-5<https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-5.md>`_  中的标准 transition 名称，即 ``AddFunds``。 请务必检查您打算向其发送资金的合约是否符合 ZRC-5 公约。"

#: ../scilla-in-depth.rst:573
msgid ""
"In addition to the compulsory fields the message may contain other fields"
" (of any type), such as ``param`` above. However, if the message "
"recipient is a contract, the additional fields must have the same names "
"and types as the parameters of the transition being invoked on the "
"recipient contract."
msgstr "除了必填字段之外，消息还可以包含其他字段（任何类型），例如上面的 ``param``。 但是，如果消息接收者是合约，则附加字段的名称和类型必须与在接收者合约上调用的 transition 参数相同。"

#: ../scilla-in-depth.rst:579
msgid "Here's an example that sends multiple messages."
msgstr "这是一个发送多条消息的示例。"

#: ../scilla-in-depth.rst:594
msgid ""
"A transition may execute a ``send`` at any point during execution "
"(including during the execution of the procedures it invokes), but the "
"messages will not sent onwards until after the transition has finished. "
"More details can be found in the :ref:`Chain Calls <Chaincalls>` section."
msgstr "transition 可以在执行期间的任何时候执行 ``send``（包括在它调用的 procedure 的执行期间），但是直到 transition 完成后才会继续发送消息。 更多细节可以在 :ref:`链式调用 <Chaincalls>` 部分找到。"

#: ../scilla-in-depth.rst:600
msgid ""
"A contract can also communicate to the outside world by emitting events. "
"An event is a signal that gets stored on the blockchain for everyone to "
"see. If a user uses a client application invoke a transition on a "
"contract, the client application can listen for events that the contract "
"may emit, and alert the user."
msgstr "合约还可以通过发出事件与外界进行通信。 事件是存储在区块链上供所有人查看的信号。 如果用户使用客户端应用程序调用合约上的 transition，则客户端应用程序可以侦听合约可能发出的事件，并提醒用户。"

#: ../scilla-in-depth.rst:606
msgid ""
"``event e``: Emit a message ``e`` as an event. The following code emits "
"an event with name ``e_name``."
msgstr "``event e``：将消息 ``e`` 作为事件发出。 以下代码发出一个名为 ``e_name`` 的事件。"

#: ../scilla-in-depth.rst:614
msgid ""
"An emitted event must contain the compulsory field ``_eventname`` (of "
"type ``String``), and may contain other entries as well. The value of the"
" ``_eventname`` entry must be a string literal. All events with the same "
"name must have the same entry names and types."
msgstr "发出的事件必须包含强制字段 ``_eventname`` （``String`` 类型），并且还可以包含其他条目。 ``_eventname`` 条目的值必须是字符串文字。 所有具有相同名称的事件必须具有相同的条目名称和类型。"

#: ../scilla-in-depth.rst:621
msgid ""
"As with the sending of messages, a transition may emit events at any "
"point during execution (including during the execution of the procedures "
"it invokes), but the event will not be visible on the blockchain before "
"the transition has finished. More details can be found in the :ref:`Chain"
" Calls <Chaincalls>` section."
msgstr "与发送消息一样，transition 可以在执行期间的任何时候（包括在它调用的过程的执行期间）发出事件，但在 transition 完成之前，该事件在区块链上是不可见的。 更多细节可以在 :ref:`链式调用 <Chaincalls>` 部分找到。"

#: ../scilla-in-depth.rst:629
msgid "Run-time Errors"
msgstr "运行时错误"

#: ../scilla-in-depth.rst:631
msgid ""
"A transition may encounter a run-time error during execution, such as "
"out-of-gas errors, integer overflows, or deliberately thrown exceptions. "
"A run-time error causes the transition to terminate abruptly, and the "
"entire transaction to be aborted. However, gas is still charged up until "
"the point of the error."
msgstr "transition 在执行过程中可能会遇到运行时错误，例如 out-of-gas 错误、整数溢出或故意抛出的异常。 运行时错误会导致 transition 突然终止，并中止整个事务。 但是gas费用仍旧会被扣除，直到出现错误为止。"

#: ../scilla-in-depth.rst:637
msgid ""
"The syntax for throwing an exception is similar to that of events and "
"messages."
msgstr "抛出异常的语法类似于事件和消息的语法。"

#: ../scilla-in-depth.rst:644
msgid ""
"Unlike that for ``event`` or ``send``, The argument to ``throw`` is "
"optional and can be omitted. An empty throw will result in an error that "
"just conveys the location of where the ``throw`` happened without more "
"information."
msgstr "与 ``event`` 或 ``send`` 不同， ``throw`` 的参数是可选的，可以省略。 不带参数的抛出异常将导致错误，该错误只会展示发生 ``throw`` 的位置而没有更多信息。"

#: ../scilla-in-depth.rst:650
msgid ""
"If a run-time error occurs during the execution of a transition, then the"
" entire transaction is aborted, and any state changes in both the current"
" and other contracts are rolled back. (The state of other contracts may "
"have changed due to a chain call)."
msgstr "如果在执行 transition 期间发生运行时错误，则整个交易将被中止，并且当前合约和其他合约中的任何状态更改都将回滚。 （其他合约的状态可能因链式调用而发生变化）。"

#: ../scilla-in-depth.rst:655
msgid "In particular:"
msgstr "特别是："

#: ../scilla-in-depth.rst:657
msgid ""
"All transferred funds are returned to their respective senders, even if "
"an ``accept`` was executed before the error."
msgstr "即使在错误发生之前执行了 ``accept``，所有转移的资金都会返回给各自的发送者。"

#: ../scilla-in-depth.rst:660
msgid ""
"The message queue is cleared, so that as yet unprocessed messages will no"
" longer be sent onwards even if a ``send`` was executed before the error."
msgstr "消息队列被清除，因此即使在错误之前执行了 ``send``，也不会再继续发送尚未处理的消息。"

#: ../scilla-in-depth.rst:664
msgid ""
"The event list is cleared, so that no events are emitted even if an "
"``event`` was executed before the error."
msgstr "事件列表被清除，因此即使在错误之前执行了 ``event``，也不会发出任何事件。"

#: ../scilla-in-depth.rst:667
msgid ""
"Gas is still charged for the transaction up until the point the run-time "
"error occurs."
msgstr "在发生运行时错误之前，仍会为交易收取 Gas 费用。"

#: ../scilla-in-depth.rst:672
msgid ""
"Scilla does not have exception handlers. Throwing an exception always "
"aborts the entire transaction."
msgstr "Scilla 没有异常处理程序。 抛出异常总是会中止整个事务。"

#: ../scilla-in-depth.rst:677
msgid "Gas consumption in Scilla"
msgstr "Scilla 的 Gas 消耗量"

#: ../scilla-in-depth.rst:679
msgid ""
"Deploying contracts and executing transitions in them cost gas. The "
"detailed cost mechanism is explained `here <https://github.com/Zilliqa"
"/scilla-docs/tree/master/docs/texsources/gas-costs/gas-doc.pdf>`_."
msgstr "部署合约并在其中执行 transition 会消耗 gas。 `这里  <https://github.com/Zilliqa/scilla-docs/tree/master/docs/texsources/gas-costs/gas-doc.pdf>`_ 解释了详细的成本机制。"

#: ../scilla-in-depth.rst:683
msgid ""
"The `Nucleus Wallet <https://dev-wallet.zilliqa.com/calculate>`_ page can"
" be used to estimate gas costs for some transactions ."
msgstr "`Nucleus 钱包 <https://dev-wallet.zilliqa.com/calculate>`_ 页面可用于估算某些交易的 gas 成本。"

#: ../scilla-in-depth.rst:688
msgid "Primitive Data Types & Operations"
msgstr "原始数据类型和操作"

#: ../scilla-in-depth.rst:691
msgid "Integer Types"
msgstr "整数类型"

#: ../scilla-in-depth.rst:693
msgid ""
"Scilla defines signed and unsigned integer types of 32, 64, 128, and 256 "
"bits.  These integer types can be specified with the keywords ``IntX`` "
"and ``UintX`` where ``X`` can be 32, 64, 128, or 256. For example, the "
"type of an unsigned integer of 32 bits is ``Uint32``."
msgstr "Scilla 定义了 32、64、128 和 256 位的有符号和无符号整数类型。 这些整数类型可以用关键字 ``IntX`` 和 ``UintX`` 指定，其中 ``X`` 可以是 32、64、128 或 256。例如，32 位无符号整数的类型是 ``Uint32``。"

#: ../scilla-in-depth.rst:698
msgid "The following code snippet declares a variable of type ``Uint32``:"
msgstr "以下代码片段声明了一个 ``Uint32`` 类型的变量："

#: ../scilla-in-depth.rst:705
msgid ""
"Scilla supports the following built-in operations on integers. Each "
"operation takes two integers ``IntX`` / ``UintX`` (of the same type) as "
"arguments. Exceptions are ``pow`` whose second argument is always "
"``Uint32`` and ``isqrt`` which takes in a single ``UintX`` argument."
msgstr "Scilla 支持以下内置的整数运算。 每个操作都采用两个整数 ``IntX`` / ``UintX`` （相同类型）作为参数。 有两个除外，即 ``pow`` 的第二个参数始终是 ``Uint32`` 以及 ``isqrt`` 接受单个 ``UintX`` 参数。"

#: ../scilla-in-depth.rst:710
msgid "``builtin eq i1 i2`` : Is ``i1`` equal to ``i2``? Returns a ``Bool``."
msgstr "``builtin eq i1 i2`` ：判断 ``i1`` 是否等于 ``i2``。 返回 ``Bool``。"

#: ../scilla-in-depth.rst:711
msgid ""
"``builtin add i1 i2``: Add integer values ``i1`` and ``i2``. Returns an "
"integer of the same type."
msgstr "``builtin add i1 i2``：整数值 ``i1` 和 ``i2`` 相加。 返回相同类型的整数。"

#: ../scilla-in-depth.rst:713
msgid ""
"``builtin sub i1 i2``: Subtract ``i2`` from ``i1``. Returns an integer of"
" the same type."
msgstr "``builtin sub i1 i2``：从 ``i1`` 中减去 ``i2``。 返回相同类型的整数。"

#: ../scilla-in-depth.rst:715
msgid ""
"``builtin mul i1 i2``: Integer product of ``i1`` and ``i2``. Returns an "
"integer of the same type."
msgstr "``builtin mul i1 i2``：``i1`` 和 ``i2`` 的整数乘积。 返回相同类型的整数。"

#: ../scilla-in-depth.rst:717
msgid ""
"``builtin div i1 i2``: Integer division of ``i1`` by ``i2``. Returns an "
"integer of the same type."
msgstr "``builtin div i1 i2``：``i1`` 除以 ``i2`` 的整数。 返回相同类型的整数。"

#: ../scilla-in-depth.rst:719
msgid ""
"``builtin rem i1 i2``: The remainder of integer division of ``i1`` by "
"``i2``. Returns an integer of the same type."
msgstr "``builtin rem i1 i2``：``i1`` 除以 ``i2`` 的整数余数。 返回相同类型的整数。"

#: ../scilla-in-depth.rst:721
msgid "``builtin lt i1 i2``: Is ``i1`` less than ``i2``? Returns a ``Bool``."
msgstr "``builtin lt i1 i2``：``i1`` 是否小于 ``i2``， 返回 ``Bool``。"

#: ../scilla-in-depth.rst:722
msgid ""
"``builtin pow i1 i2``: ``i1`` raised to the power of ``i2``. Returns an "
"integer of the same type as ``i1``."
msgstr "``builtin pow i1 i2``：``i1`` 提升到 ``i2`` 的幂运算。 返回与 ``i1`` 类型相同的整数。"

#: ../scilla-in-depth.rst:723
msgid ""
"``builtin isqrt i``: Computes the integer square root of ``i``, i.e. the "
"largest integer ``j`` such that ``j * j <= i``. Returns an integer of the"
" same type as ``i``."
msgstr "``builtin isqrt i``：计算 ``i`` 的整数平方根，即最大整数 ``j`` 使得 ``j * j <= i``。 返回与 ``i`` 类型相同的整数。"

#: ../scilla-in-depth.rst:725
msgid ""
"``builtin to_nat i1``: Convert a value of type ``Uint32`` to the "
"equivalent value of type ``Nat``."
msgstr "``builtin to_nat i1``：将 ``Uint32`` 类型的值转换为 ``Nat`` 类型的等效值。"

#: ../scilla-in-depth.rst:726
msgid ""
"``builtin to_(u)int32/64/128/256``: Convert a ``UintX`` / ``IntX`` or a "
"``String`` (that represents a decimal number) value to the result of "
"``Option UintX`` or ``Option IntX`` type. Returns ``Some res`` if the "
"conversion succeeded and ``None`` otherwise. The conversion may fail when"
msgstr "``builtin to_(u)int32/64/128/256``：将 ``UintX`` / ``IntX`` 或 ``String`` （表示十进制数）值转换为 ``Option UintX`` 或 ``Option IntX`` 类型的结果。 如果转换成功，则返回 ``Some res``，否则返回 ``None``。 转换可能会在下面这些情况下失败"

#: ../scilla-in-depth.rst:731
msgid "there is not enough bits to represent the result;"
msgstr "没有足够的位来表示结果；"

#: ../scilla-in-depth.rst:732
msgid ""
"when converting a negative integer (or a string representing a negative "
"integer) into a value of an unsigned type;"
msgstr "将负整数（或表示负整数的字符串）转换为无符号类型的值时；"

#: ../scilla-in-depth.rst:734
msgid "the input string cannot be parsed as an integer."
msgstr "输入字符串不能解析为整数。"

#: ../scilla-in-depth.rst:736
msgid ""
"Here is the list of concrete conversion builtins for better "
"discoverability: ``to_int32``, ``to_int64``, ``to_int128``, "
"``to_int256``, ``to_uint32``, ``to_uint64``, ``to_uint128``, "
"``to_uint256``."
msgstr "以下是具体转换内置函数列表：``to_int32``、``to_int64``、``to_int128``、``to_int256``、``to_uint32``、``to_uint64``、``to_uint128``、``to_uint256``。"

#: ../scilla-in-depth.rst:740
msgid ""
"Addition, subtraction, multiplication, pow, division and remainder "
"operations may raise integer overflow, underflow and division_by_zero "
"errors. This aborts the execution of the current transition and unrolls "
"all the state changes made so far."
msgstr "加法、减法、乘法、幂、除法和余数运算可能会引发整数溢出、下溢和除零错误。 这会中止当前 transition 的执行并还原迄今为止所做的所有状态更改。"

#: ../scilla-in-depth.rst:747
msgid ""
"Variables related to blockchain money, such as the ``_amount`` entry of a"
" message or the ``_balance`` field of a contract, are of type "
"``Uint128``."
msgstr "与区块链货币相关的变量，例如消息的 ``_amount`` 条目或合约的 ``_balance`` 字段，属于 ``Uint128`` 类型。"

#: ../scilla-in-depth.rst:754
msgid "Strings"
msgstr "字符串"

#: ../scilla-in-depth.rst:756
msgid ""
"``String`` literals in Scilla are expressed using a sequence of "
"characters enclosed in double quotes. Variables can be declared by "
"specifying using keyword ``String``."
msgstr "Scilla 中的 ``String`` 文字使用双引号括起来的字符序列表示。 可以通过使用关键字 ``String`` 指定来声明变量。"

#: ../scilla-in-depth.rst:760
msgid "The following code snippet declares a variable of type ``String``:"
msgstr "以下代码片段声明了一个 ``String`` 类型的变量："

#: ../scilla-in-depth.rst:766
msgid "Scilla supports the following built-in operations on strings:"
msgstr "Scilla 支持以下对字符串的内置操作："

#: ../scilla-in-depth.rst:768
msgid ""
"``builtin eq s1 s2`` : Is ``s1`` equal to ``s2``? Returns a ``Bool``. "
"``s1`` and ``s2`` must be of type ``String``."
msgstr "``builtin eq s1 s2`` ： ``s1`` 是否等于 ``s2``。 返回 ``Bool``。 ``s1`` 和 ``s2`` 必须都是字符串类型。"

#: ../scilla-in-depth.rst:770
msgid ""
"``builtin concat s1 s2`` : Concatenate string ``s1`` with string ``s2``. "
"Returns a ``String``."
msgstr "``builtin concat s1 s2`` ：将字符串 ``s1`` 与字符串 ``s2`` 连接起来。 返回一个 ``String``。"

#: ../scilla-in-depth.rst:772
msgid ""
"``builtin substr s idx len`` : Extract the substring of ``s`` of length "
"``len`` starting from position ``idx``. ``idx`` and ``len`` must be of "
"type ``Uint32``. Character indices in strings start from ``0``.  Returns "
"a ``String`` or fails with a runtime error if the combination of the "
"input parameters results in an invalid substring."
msgstr "``builtin substr s idx len`` ：从位置 ``idx`` 开始提取长度为 ``len`` 的 ``s`` 子串。 ``idx`` 和 len 必须是 ``Uint32`` 类型。 字符串中的字符索引从 ``0`` 开始。如果输入参数的组合导致无效的子字符串，则返回 ``String`` 或失败并显示运行时错误。"

#: ../scilla-in-depth.rst:777
msgid ""
"``builtin to_string x``: Convert ``x`` to a string literal. Valid types "
"of ``x`` are ``IntX``, ``UintX``, ``ByStrX`` and ``ByStr``. Returns a "
"``String``. Byte strings are converted to textual hexadecimal "
"representation."
msgstr "``builtin to_string x``：将 ``x`` 转换为字符串文字。 ``x`` 的有效类型是 ``IntX``、``UintX``、``ByStrX`` 和 ``ByStr``。 返回一个 ``String``。 字节字符串被转换为文本十六进制表示。"

#: ../scilla-in-depth.rst:780
msgid ""
"``builtin strlen s`` : Calculate the length of ``s`` (of type "
"``String``). Returns a ``Uint32``."
msgstr "``builtin strlen s`` ：计算 ``s`` （``String`` 类型）的长度。 返回一个 ``Uint32``。"

#: ../scilla-in-depth.rst:782
msgid "``builtin strrev s`` : Returns the reverse of the string ``s``."
msgstr "``builtin strrev s`` ：返回字符串 ``s`` 的反转。"

#: ../scilla-in-depth.rst:783
msgid ""
"``builtin to_ascii h`` : Reinterprets a byte string (``ByStr`` or "
"``ByStrX``) as a printable ASCII string and returns an equivalent "
"``String`` value. If the byte string contains any non-printable "
"characters, a runtime error is raised."
msgstr "``builtin to_ascii h`` ：将字节字符串（``ByStr`` 或 ``ByStrX``）重新解释为可打印的 ASCII 字符串并返回等效的 ``String`` 值。 如果字节字符串包含任何不可打印的字符，则会引发运行时错误。"

#: ../scilla-in-depth.rst:788
msgid "Byte strings"
msgstr "字节字符串"

#: ../scilla-in-depth.rst:790
msgid ""
"Byte strings in Scilla are represented using the types ``ByStr`` and "
"``ByStrX``, where ``X`` is a number. ``ByStr`` refers to a byte string of"
" arbitrary length, whereas for any ``X``, ``ByStrX`` refers to a byte "
"string of fixed length ``X``. For instance, ``ByStr20`` is the type of "
"byte strings of length 20, ``ByStr32`` is the type of byte strings of "
"length 32, and so on."
msgstr "Scilla 中的字节字符串使用 ``ByStr`` 和 ``ByStrX`` 类型表示，其中 ``X`` 是一个数字。 ``ByStr`` 是指任意长度的字节串，从而对应于任意 ``X``，``ByStrX`` 是指固定长度 ``X`` 的字节串。例如，``ByStr20`` 是长度为20的字节串类型，``ByStr32`` 是长度为32的字节串类型 ， 等等。"

#: ../scilla-in-depth.rst:797
msgid ""
"Byte strings literals in Scilla are written using hexadecimal characters "
"prefixed with ``0x``. Note that it takes 2 hexadecimal characters to "
"specify 1 byte, so a ``ByStrX`` literal requires ``2 * X`` hexadecimal "
"characters. The following code snippet declares a variable of type "
"``ByStr32``:"
msgstr "Scilla 中的字节字符串文字是使用以 ``0x`` 为前缀的十六进制字符编写的。 请注意，指定 1 个字节需要 2 个十六进制字符，因此 ``ByStrX`` 文字需要 ``2 * X`` 个十六进制字符。 以下代码片段声明了一个 ``ByStr32`` 类型的变量："

#: ../scilla-in-depth.rst:807
msgid ""
"Scilla supports the following built-in operations for computing on and "
"converting between byte string types:"
msgstr "Scilla 支持以下用于计算和转换字节字符串类型的内置操作："

#: ../scilla-in-depth.rst:810
msgid ""
"``builtin to_bystr h`` : Convert a value ``h`` of type ``ByStrX`` (for "
"some known ``X``) to one of arbitrary length of type ``ByStr``."
msgstr "``builtin to_bystr h`` ：将 ``ByStrX`` 类型的值 ``h`` （对于某些已知的 ``X``）转换为 ``ByStr`` 类型的任意长度之一。"

#: ../scilla-in-depth.rst:813
msgid ""
"``builtin to_bystrX h`` : (note that ``X`` is a numerical paratemeter "
"here and not a part of the builtin name, see the examples below)"
msgstr "``builtin to_bystrX h`` :（请注意，这里的 ``X`` 是数字参数，而不是内置名称的一部分，请参见下面的示例）"

#: ../scilla-in-depth.rst:816
msgid ""
"if the argument ``h`` is of type ``ByStr``: Convert an arbitrary size "
"byte string value ``h`` (of type ``ByStr``) to a fixed sized byte string "
"of type ``ByStrX``, with length ``X``. The result is of type ``Option "
"ByStrX`` in this case: the builtin returns ``Some res`` if the length of "
"the argument is equal to ``X`` and ``None`` otherwise. E.g. ``builtin "
"to_bystr42 bs`` returns ``Some bs'`` if the length of ``bs`` is 42."
msgstr "如果参数 ``h`` 的类型为 ``ByStr``：将任意大小的字节字符串值 ``h`` （类型为 ``ByStr``）转换为固定大小的 ``ByStrX`` 类型的字节字符串，长度为 ``X``。在这种情况下，结果为 ``Option ByStrX`` 类型：如果参数的长度等于 ``X``，内置函数返回 ``Some res`` ，否则为 ``None`` 。 例如，如果 ``bs`` 的长度为 42，则 ``builtin to_bystr42 bs`` 返回 ``Some bs'``。"

#: ../scilla-in-depth.rst:822
msgid ""
"if the argument ``h`` is of type ``Uint(32/64/128/256)``: Convert "
"unsigned integers to their big endian byte representation, returning a "
"``ByStr(4/8/16/32)`` value (notice it's not an optional type in this "
"case). For instance, ``builtin to_bystr4 x`` (this only typechecks if "
"``x`` has type ``Uint32``) or ``builtin to_bystr16 x`` (this only "
"typechecks if ``x`` is of type ``Uint128``)."
msgstr "如果参数 ``h`` 是 ``Uint(32/64/128/256)`` 类型：将无符号整数转换为它们的大端字节表示，返回一个 ``ByStr(4/8/16/32)`` 值（注意在这个情况下它不是一个可选类型）。 例如，``builtin to_bystr4 x`` （仅在 ``x`` 的类型为 ``Uint32`` 时进行类型检查）或 ``builtin to_bystr16 x`` （仅在 ``x`` 的类型为 ``Uint128`` 时进行类型检查）。"

#: ../scilla-in-depth.rst:829
msgid ""
"``builtin to_uint(32/64/128/256) h`` : Convert a fixed sized byte string "
"value ``h`` to an equivalent value of type ``Uint(32/64/128/256)``. ``h``"
" must be of type ``ByStrX`` for some known ``X`` less than or equal to "
"(4/8/16/32). A big-endian representation is assumed."
msgstr "``builtin to_uint(32/64/128/256) h`` ：将固定大小的字节字符串值 ``h`` 转换为 ``Uint(32/64/128/256)`` 类型的等效值。 对于一些小于或等于 (4/8/16/32) 的已知 ``X``，``h`` 必须是 ``ByStrX`` 类型。 假设采用大端表示。"

#: ../scilla-in-depth.rst:833
msgid "``builtin concat h1 h2``: Concatenate byte strings ``h1`` and ``h2``."
msgstr "``builtin concat h1 h2``：连接字节字符串 ``h1`` 和 ``h2``。"

#: ../scilla-in-depth.rst:835
msgid ""
"If ``h1`` has type ``ByStrX`` and ``h2`` has type ``ByStrY``, then the "
"result will have type ``ByStr(X+Y)``."
msgstr "如果 ``h1`` 的类型为 ``ByStrX`` 而 ``h2`` 的类型为 ``ByStrY``，则结果的类型为 ``ByStr(X+Y)``。"

#: ../scilla-in-depth.rst:837
msgid ""
"If the arguments are of type ``ByStr``, the result is also of type "
"``ByStr``."
msgstr "如果参数是 ``ByStr`` 类型，则结果也是 ``ByStr`` 类型。"

#: ../scilla-in-depth.rst:839
msgid ""
"``builtin strlen h``: The length of byte string (``ByStr``) ``h``. "
"Returns ``Uint32``."
msgstr "``builtin strlen h``：字节串 (``ByStr``) ``h`` 的长度。 返回 ``Uint32``。"

#: ../scilla-in-depth.rst:841
msgid "``eq a1 a2``: Is ``a1`` equal to ``a2``? Returns a ``Bool``."
msgstr "``eq a1 a2``: a1 是否等于 a2 ， 返回一个 ``Bool``。"

#: ../scilla-in-depth.rst:846
msgid "Addresses"
msgstr "地址"

#: ../scilla-in-depth.rst:848
msgid ""
"Addresses on the Zilliqa network are strings of 20 bytes, and raw "
"addresses are therefore represented by values of type ``ByStr20``."
msgstr "Zilliqa 网络上的地址是 20 字节的字符串，因此原始地址由 ``ByStr20`` 类型的值表示。"

#: ../scilla-in-depth.rst:851
msgid ""
"Additionally, Scilla supports structured address types, i.e., types that "
"are equivalent to ``ByStr20``, but which, when interpreted as an address "
"on the network, provide additional information about the contents of that"
" address. Address types are written using the form ``ByStr20 with "
"<address contents> end``, where ``<address contents>`` refers to what the"
" address contains."
msgstr "此外，Scilla 支持结构化地址类型，即等价于 ``ByStr20`` 的类型，但当被解释为网络上的地址时，会提供有关该地址内容的附加信息。 地址类型使用形式为 ``ByStr20 with <address contents> end``，其中 ``<address contents>`` 指地址包含的内容。"

#: ../scilla-in-depth.rst:858
msgid "The hierarchy of address types is as follows:"
msgstr "地址类型的层次结构如下："

#: ../scilla-in-depth.rst:860
msgid ""
"``ByStr20``: A raw byte string of length 20. The type does not provide "
"any guarantee as to what is located at the address. (Generally, "
"``ByStr20`` is not regarded as an address type, because it can refer to "
"any byte string of length 20, whether it is meant to represent an address"
" or not.)"
msgstr "``ByStr20``：长度为 20 的原始字节字符串。该类型不提供任何关于地址处的内容的保证。 （通常，``ByStr20`` 不被视为地址类型，因为它可以引用任何长度为 20 的字节串，无论它是否表示地址。）"

#: ../scilla-in-depth.rst:866
msgid ""
"``ByStr20 with end``: A ``ByStr20`` which, when interpreted as a network "
"address, refers to an address that is in use. An address is in use if it "
"either contains a contract, or if the balance or the *nonce* of the "
"address is greater than 0. (The balance of an address is the number of Qa"
" held by the address account. The nonce of an address is the number of "
"transactions that have been initiated from that address)."
msgstr "``ByStr20 with end``：一个 ``ByStr20``，当解释为网络地址时，指的是一个正在使用的地址。 如果地址包含合约，或者地址的余额或随机数大于 0，则该地址正在使用中。（地址余额是地址帐户持有的 Qa 数量。地址的随机数是从该地址发起的交易数量）。"

#: ../scilla-in-depth.rst:874
msgid ""
"``ByStr20 with contract end``: A ``ByStr20`` which, when interpreted as a"
" network address, refers to the address of a contract."
msgstr "``ByStr20 with contract end``：一个 ``ByStr20``，当解释为网络地址时，指的是合约的地址。"

#: ../scilla-in-depth.rst:877
msgid ""
"``ByStr20 with contract field f1 : t1, field f2 : t2, ... end``: A "
"``ByStr20`` which, when interpreted as a network address, refers to the "
"address of a contract containing the mutable fields ``f1`` of type "
"``t1``, ``f2`` of type ``t2``, and so on. The contract in question may "
"define more fields than the ones specified in the type, but the fields "
"specified in the type must be defined in the contract."
msgstr "``ByStr20 with contract field f1 : t1, field f2 : t2, ... end``:  一个 ``ByStr20``，当解释为网络地址时，指的是包含类型为 ``t1`` 的可变字段 ``f1`` 、类型为 ``t2`` 的可变字段 ``f2``  的合约地址， 等等。 有一个问题是合约可以定义比类型中指定的更多的字段，但类型中指定的字段必须在合约中定义。"

#: ../scilla-in-depth.rst:886
msgid ""
"All addresses in use, and therefore by extension all contract addresses, "
"implicitly define a mutable field ``_balance : Uint128``. For user "
"accounts the ``_balance`` field refers to the account balance."
msgstr "所有使用中的地址，以及因此通过扩展的所有合约地址，都隐式定义了一个可变字段 ``_balance : Uint128``。 对于用户帐户，``_balance`` 字段是指帐户余额。"

#: ../scilla-in-depth.rst:893
msgid ""
"Address types specifying immutable parameters or transitions of a "
"contract are not supported."
msgstr "不支持指定不可变参数或合约 transition 的地址类型。"

#: ../scilla-in-depth.rst:897
msgid "Address subtyping"
msgstr "地址子类型"

#: ../scilla-in-depth.rst:899
msgid "The hierarchy of address types defines a subtype relation:"
msgstr "地址类型的层次结构定义了一个子类型关系："

#: ../scilla-in-depth.rst:901
msgid ""
"Any address type ``ByStr20 with ... end`` is as subtype of ``ByStr20``. "
"This means that any address type can be used in place of a ``ByStr20``, "
"e.g., for comparing equality using ``builtin eq``, or as the "
"``_recipient`` value of a message."
msgstr "任何 ``ByStr20 with ... end`` 的地址类型都是 ``ByStr20`` 的子类型。 这意味着可以使用任何地址类型代替 ``ByStr20``，例如，使用 ``builtin eq`` 比较相等性，或作为消息的 ``_recipient`` 值。"

#: ../scilla-in-depth.rst:906
msgid ""
"Any contract address type ``ByStr20 with contract ... end`` is a subtype "
"of ``ByStr20 with end``."
msgstr "任何 ``ByStr20 with contract ... end`` 的合约地址类型 都是 ``ByStr20 with end`` 的子类型。"

#: ../scilla-in-depth.rst:909
msgid ""
"Any contract address type specifying explict fields ``ByStr20 with "
"contract field f1 : t11, field f2 : t12, ... end`` is a subtype of a "
"contract address type specifying a subset of those fields ``ByStr20 with "
"contract field f1 : t21, field f2 : t22, ... end``, provided that ``t11``"
" is a subtype of ``t21``, ``t12`` is a subtype of ``t22``, and so on for "
"each field specified in both contract types."
msgstr "任何指定显式字段 ```ByStr20 with contract field f1: t11, field f2: t12, ... end`` 的合约地址类型都是指定这些字段的子集 ``ByStr20 with contract field f1: t21, field f2: t22 , ... end`` 的合约地址类型的子类型，前提是 ``t11`` 是 ``t21`` 的子类型， ``t12`` 是 ``t22`` 的子类型，两种合同类型中指定的每个字段都依此类推。"

#: ../scilla-in-depth.rst:917
msgid ""
"For ADTs with type parameters such as ``List`` or ``Option``, an ADT ``T "
"t1 t2 ...`` is a subtype of ``S s1 s2 ...`` if ``T`` is the same as "
"``S``, and ``t1`` is a subtype of ``s1``, ``t2`` is a subtype of ``s2``, "
"and so on."
msgstr "对于带有 ``List`` 或 ``Option`` 等类型参数的 ADT，如果 ``T`` 与 ``S`` 相同，并且 ``t1`` 是 ``s1`` 的子类型，``t2`` 是 ``s2`` 的子类型，那么 ``T t1 t2 ...`` 是 ``S s1 s2 ...`` 的子类型，以此类推。"

#: ../scilla-in-depth.rst:922
msgid ""
"A map with key type ``kt1`` and value type ``vt1`` is a subtype of "
"another map with key type ``kt2`` and value type ``vt2`` if ``kt1`` is a "
"subtype of ``kt2`` and ``vt1`` is a subtype of ``vt2``."
msgstr "如果 ``kt1`` 是 ``kt2`` 的子类型且 ``vt1`` 是 ``vt2`` 的子类型，则具有键类型 ``kt1`` 和值类型 ``vt1`` 的映射是具有键类型 ``kt2`` 和值类型 ``vt2`` 的另一个映射的子类型。"

#: ../scilla-in-depth.rst:927
msgid "Dynamic typecheck of addresses"
msgstr "地址的动态类型检查"

#: ../scilla-in-depth.rst:929
msgid ""
"In general, address types cannot be fully typechecked statically by the "
"Scilla checker. This can happen, e.g., because a byte string is a "
"transition parameter and thus not known statically, or because a byte "
"string refers to an address that does not currently contain a contract, "
"but which might contain a contract in the future."
msgstr "通常，Scilla 检查器不能完全静态地对地址类型进行类型检查。 例如下面的情况就可能会发生，由于字节字符串是一个 transition 参数，因此不能静态地知道它的值，或者因为字节字符串指的是当前不包含合约但将来可能包含合约的地址。"

#: ../scilla-in-depth.rst:935
msgid ""
"For this reason immutable parameters (i.e., contract parameters supplied "
"when the contract is deployed) and transition parameters of address types"
" are typechecked dynamically, when the actual byte string is known."
msgstr "出于这个原因，只有当实际字节字符串已知时，不可变参数（即部署合约时提供的合约参数）和地址类型的 transition 参数才可以进行动态类型检查。"

#: ../scilla-in-depth.rst:940
msgid ""
"For example, a contract might specify an immutable field ``init_owner`` "
"as follows:"
msgstr "例如，合约可能会指定一个如下所示的不可变字段 ``init_owner`` ："

#: ../scilla-in-depth.rst:947
msgid ""
"When the contract is deployed, the byte string supplied as ``init_owner``"
" is looked up as an address on the blockchain, and if the contents of "
"that address matches the address type (in this case that the address is "
"in use either by a user or by a contract), then deployment continues, and"
" ``init_owner`` can be treated as a ``ByStr20 with end`` throughout the "
"contract."
msgstr "当合约被部署时，作为 ``init_owner`` 提供的字节字符串被查找为区块链上的地址，如果该地址的内容与地址类型匹配（在地址被用户或合约使用的情况下），那么继续部署，并且 ``init_owner`` 可以在整个合约中被视为一个 ``ByStr20 with end``。"

#: ../scilla-in-depth.rst:954
msgid ""
"Similarly, a transition might specify a parameter ``token_contract`` as "
"follows:"
msgstr "类似地，transition 可能指定如下的参数 ``token_contract``："

#: ../scilla-in-depth.rst:965
msgid ""
"When the transition is invoked, the byte string supplied as the "
"``token_contract`` parameter is looked up as an address on the "
"blockchain, and if the contents of that address matches the address type "
"(in this case that the address contains a contract with a field "
"``balances`` of a type that is assignable to ``Map ByStr20 Uint128``), "
"then the transition parameter is initialised successfully, and "
"``token_contract`` can be treated as a ``ByStr20 with contract field "
"balances : Map ByStr20 Uint128 end`` throughout this transition "
"invocation."
msgstr "当 transition 被调用时，作为 ``token_contract`` 参数提供的字节字符串被查找为区块链上的地址，如果该地址的内容与地址类型匹配（在地址包含一个具有 ``Map ByStr20 Uint128`` 类型的字段 ``balances`` 的合约的情况下），那么 transition 参数成功初始化，并且 ``token_contract`` 可以在整个转换调用中被视为 ``ByStr20 with contract field balances : Map ByStr20 Uint128 end``。"

#: ../scilla-in-depth.rst:975
msgid ""
"In either case, if the contents of the address does not match the "
"specified type, then the dynamic typecheck is unsuccessful, causing "
"deployment (for failed immutable parameters) or transition invocation "
"(for transition parameters) to fail. A failed dynamic typecheck is "
"considered a run-time error, causing the current transaction to abort. "
"(For the purposes of dynamic typechecks of immutable fields the "
"deployment of a contract is considered a transaction)."
msgstr "在任何一种情况下，如果地址的内容与指定的类型不匹配，则动态类型检查不成功，同时会导致部署（对于失败的不可变参数）或 transition 调用（对于 transition 参数）失败。 失败的动态类型检查被视为运行时错误，同时会导致当前事务中止。 （出于对不可变字段的动态类型检查的目的，合约的部署被视为交易）。"

#: ../scilla-in-depth.rst:986
msgid ""
"It is not possible to specify a ``ByStr20`` literal and have it "
"interpreted as an address. In other words, the following code snippet "
"will result in a static type error:"
msgstr "无法指定 ``ByStr20`` 文字并将其解释为地址。 换句话说，以下代码片段将导致静态类型错误："

#: ../scilla-in-depth.rst:994
msgid ""
"The only way for a byte string to be validated against an address type is"
" to pass it as the value of an immutable field or as a transition "
"parameter, of the appropriate type."
msgstr "针对地址类型验证字节字符串的唯一方法是将其作为不可变字段的值或作为适当类型的 transition 参数传递。"

#: ../scilla-in-depth.rst:1000
msgid "Remote fetches"
msgstr ""

#: ../scilla-in-depth.rst:1002
msgid ""
"To perform a remote fetch ``x <- & c.f``, the type of ``c`` must be some "
"address type declaring the field ``f``. For instance, if ``c`` has the "
"type ``ByStr20 with contract field paused : Bool end``, then the value of"
" the field ``paused`` at address ``c`` can be fetched using the statement"
" ``x <- & c.paused``, whereas it is not possible to fetch the value of an"
" undeclared field (e.g., ``admin``) of ``c``, even if the contract at "
"address ``c`` does actually contain a field ``admin``. To be able to "
"fetch the value of the ``admin`` field, the type of ``c`` must contain "
"the ``admin`` field as well, e.g, ``ByStr20 with contract field paused : "
"Bool, field admin : ByStr20 end``"
msgstr ""

#: ../scilla-in-depth.rst:1013
msgid ""
"Remote fetches of map fields can be performed using in-place operations "
"in the same way as for locally declared map fields, i.e., ``x <- & "
"c.m[key]``, ``x <- & c.m[key1][key2]``, ``x <- & exists m[key]``, etc. As"
" with remote fetches of map fields, the remote map field must be declared"
" in the type of ``c``, e.g., ``ByStr20 with contract field m : Map "
"Uint128 (Map Uint32 Bool) end``."
msgstr ""

#: ../scilla-in-depth.rst:1020
msgid "Writing to a remote field is not allowed."
msgstr ""

#: ../scilla-in-depth.rst:1028
msgid "Crypto Built-ins"
msgstr ""

#: ../scilla-in-depth.rst:1030
msgid ""
"A hash in Scilla is declared using the data type ``ByStr32``. A "
"``ByStr32`` represents a hexadecimal byte string of 32 bytes (64 "
"hexadecimal characters). A ``ByStr32`` literal is prefixed with ``0x``."
msgstr ""

#: ../scilla-in-depth.rst:1037
msgid ""
"Scilla supports the following built-in operations on hashes and other "
"cryptographic primitives, including byte sequences. In the description "
"below, ``Any`` can be of type ``IntX``, ``UintX``, ``String``, "
"``ByStr20`` or ``ByStr32``."
msgstr ""

#: ../scilla-in-depth.rst:1042
msgid ""
"``builtin eq h1 h2``: Is ``h1`` equal to ``h2``? Both inputs are of the "
"same type ``ByStrX`` (or both are of type ``ByStr``). Returns a ``Bool``."
msgstr ""

#: ../scilla-in-depth.rst:1045
msgid ""
"``builtin sha256hash x`` : Convert ``x`` of ``Any`` type to its SHA256 "
"hash. Returns a ``ByStr32``."
msgstr ""

#: ../scilla-in-depth.rst:1047
msgid ""
"``builtin keccak256hash x``: Convert ``x`` of ``Any`` type to its "
"Keccak256 hash. Returns a ``ByStr32``."
msgstr ""

#: ../scilla-in-depth.rst:1049
msgid ""
"``builtin ripemd160hash x``: Convert ``x`` of ``Any`` type to its "
"RIPEMD-160 hash. Returns a ``ByStr20``."
msgstr ""

#: ../scilla-in-depth.rst:1051
msgid ""
"``builtin substr h idx len`` : Extract the sub-byte-string of ``h`` of "
"length ``len`` starting from position ``idx``. ``idx`` and ``len`` must "
"be of type ``Uint32``. Character indices in byte strings start from "
"``0``.  Returns a ``ByStr`` or fails with a runtime error."
msgstr ""

#: ../scilla-in-depth.rst:1055
msgid ""
"``builtin strrev h`` : Reverse byte string (either ``ByStr`` or "
"``ByStrX``). Returns a value of the same type as the argument."
msgstr ""

#: ../scilla-in-depth.rst:1058
msgid ""
"``builtin schnorr_verify pubk data sig`` : Verify a signature ``sig`` of "
"type ``ByStr64`` against a byte string ``data`` of type ``ByStr`` with "
"the Schnorr public key ``pubk`` of type ``ByStr33``."
msgstr ""

#: ../scilla-in-depth.rst:1062
msgid ""
"``builtin schnorr_get_address pubk``: Given a public key of type "
"``ByStr33``, returns the ``ByStr20`` Zilliqa address that corresponds to "
"that public key."
msgstr ""

#: ../scilla-in-depth.rst:1065
msgid ""
"``builtin ecdsa_verify pubk data sig`` : Verify a signature ``sig`` of "
"type ``ByStr64`` against a byte string ``data`` of type ``ByStr`` with "
"the ECDSA public key ``pubk`` of type ``ByStr33``."
msgstr ""

#: ../scilla-in-depth.rst:1069
msgid ""
"``builtin ecdsa_recover_pk data sig recid`` : Recover ``data`` (of type "
"``ByStr``), having signature ``sig`` (of type ``ByStr64``) and a "
"``Uint32`` recovery integer ``recid``, whose value is restricted to be 0,"
" 1, 2 or 3, the uncompressed public key, returning a ``ByStr65`` value."
msgstr ""

#: ../scilla-in-depth.rst:1074
msgid ""
"``builtin bech32_to_bystr20 prefix addr``. The builtin takes a network "
"specific prefix (``\"zil\"`` / ``\"tzil\"``) of type ``String`` and an "
"input bech32 string (of type ``String``) and if the inputs are valid, "
"converts it to a raw byte address (`ByStr20`). The return type is "
"``Option ByStr20``. On success, ``Some addr`` is returned and on invalid "
"inputs ``None`` is returned."
msgstr ""

#: ../scilla-in-depth.rst:1079
msgid ""
"``builtin bystr20_to_bech32 prefix addr``. The builtin takes a network "
"specific prefix (``\"zil\"`` / ``\"tzil\"``) of type ``String`` and an "
"input ``ByStr20`` address, and if the inputs are valid, converts it to a "
"bech32 address. The return type is ``Option String``. On success, ``Some "
"addr`` is returned and on invalid inputs ``None`` is returned."
msgstr ""

#: ../scilla-in-depth.rst:1083
msgid ""
"``builtin alt_bn128_G1_add p1 p2``. The builtin takes two points ``p1``, "
"``p2`` on the ``alt_bn128`` curve and returns the sum of the points in "
"the underlying group G1. The input points and the result point are each a"
" ``Pair {Bystr32 ByStr32}``. Each scalar component ``ByStr32`` of a point"
" is a big-endian encoded number. Also see "
"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-196.md"
msgstr ""

#: ../scilla-in-depth.rst:1088
msgid ""
"``builtin alt_bn128_G1_mul p s``. The builtin takes a point ``p`` on the "
"``alt_bn128`` curve (as described previously), and a scalar ``ByStr32`` "
"value ``s`` and returns the sum of the point ``p`` taken ``s`` times. The"
" result is a point on the curve."
msgstr ""

#: ../scilla-in-depth.rst:1092
msgid ""
"``builtin alt_bn128_pairing_product pairs``. This builtin takes in a list"
" of pairs ``pairs`` of points. Each pair consists of a point in group G1 "
"(``Pair {Bystr32 ByStr32}``) as the first component and a point in group "
"G2 (``Pair {Bystr64 ByStr64}``) as the second component. Hence the "
"argument has type ``List {(Pair (Pair ByStr32 ByStr32) (Pair ByStr64 "
"ByStr64)) }``. The function applies a pairing function on each point to "
"check for equality and returns ``True`` or ``False`` depending on whether"
" the pairing check succeeds or fails. Also see "
"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-197.md"
msgstr ""

#: ../scilla-in-depth.rst:1100
msgid "Maps"
msgstr ""

#: ../scilla-in-depth.rst:1103
msgid ""
"A value of type ``Map kt vt`` provides a key-value store where ``kt`` is "
"the type of keys and ``vt`` is the type of values (in some other "
"programming languages datatypes like Scilla's ``Map`` are called "
"associative arrays, symbol tables, or dictionaries). The type of map keys"
" ``kt`` may be any one of the following *primitive* types: ``String``, "
"``IntX``, ``UintX``, ``ByStrX``, ``ByStr`` or ``BNum``. The type of "
"values ``vt`` may be any type except a function type, this includes both "
"builtin and user-defined algebraic datatypes."
msgstr ""

#: ../scilla-in-depth.rst:1111
msgid ""
"Since compound types are not supported as map key types, the way to "
"model, e.g. association of pairs of values to another value is by using "
"*nested* maps. For instance, if one wants to associate with an account "
"and a particular trusted user some money limit the trusted user is "
"allowed to spend on behalf of the account, one can use the following "
"nested map:"
msgstr ""

#: ../scilla-in-depth.rst:1122
msgid ""
"The first and the second key are of type ``ByStr20`` and represent "
"accounts and the trusted users correspondingly. We represent the money "
"limits with the ``Uint128`` type."
msgstr ""

#: ../scilla-in-depth.rst:1126
msgid "Scilla supports a number of operations on map, which can be categorized as"
msgstr ""

#: ../scilla-in-depth.rst:1128
msgid ""
"*in-place* operations which modify *field* maps without making any "
"copies, hence they belong to the imperative fragment of Scilla. These "
"operations are efficient and recommended to use in almost all of the "
"cases;"
msgstr ""

#: ../scilla-in-depth.rst:1131
msgid ""
"*functional* map operations are intended to use in pure functions, e.g. "
"when designing a Scilla library, because they never modify the original "
"map they are called on. These operations may incur significant "
"performance overhead as some of them create a new (modified) copy of the "
"input map. Syntactically, the copying operations are all prefixed with "
"``builtin`` keyword (see below). Note that to call the functional "
"builtins on a field map one first needs to make a *copy* of the field map"
" using a command like so: ``map_copy <- field_map``, which results in gas"
" consumption proportional to the size of ``field_map``."
msgstr ""

#: ../scilla-in-depth.rst:1143
msgid "In-place map operations"
msgstr ""

#: ../scilla-in-depth.rst:1145
msgid ""
"``m[k] := v``: *In-place* insert. Inserts a key ``k`` bound to a value "
"``v`` into a map ``m``. If ``m`` already contains key ``k``, the old "
"value bound to ``k`` gets replaced by ``v`` in the map. ``m`` must refer "
"to a mutable field in the current contract. Insertion into nested maps is"
" supported with the syntax ``m[k1][k2][...] := v``. If the intermediate "
"keys do not exist in the nested maps, they are freshly created along with"
" the map values they are associated with."
msgstr ""

#: ../scilla-in-depth.rst:1154
msgid ""
"``x <- m[k]``: *In-place* local fetch. Fetches the value associated with "
"the key ``k`` in the map ``m``. ``m`` must refer to a mutable field in "
"the current contract. If ``k`` has an associated value ``v`` in ``m``, "
"then the results of the fetch is ``Some v`` (see the ``Option`` type "
"below), otherwise the result is ``None``. After the fetch, the result "
"gets bound to the local variable ``x``. Fetching from nested maps is "
"supported with the syntax ``x <- m[k1][k2][...]``. If one or more of the "
"intermediate keys do not exist in the corresponding map, the result of "
"the fetch is ``None``."
msgstr ""

#: ../scilla-in-depth.rst:1164
msgid ""
"``x <- & c.m[k]``: *In-place* remote fetch. Works in the same way as the "
"local fetch operation, except that ``m`` must refer to a mutable field in"
" the contract at address ``c``."
msgstr ""

#: ../scilla-in-depth.rst:1168
msgid ""
"``x <- exists m[k]``: *In-place* local key existence check. ``m`` must "
"refer to a mutable field in the current contract. If ``k`` has an "
"associated value in the map ``m`` then the result (of type ``Bool``) of "
"the check is ``True``, otherwise the result is ``False``. After the "
"check, the result gets bound to the local variable ``x``. Existence "
"checks through nested maps is supported with the syntax ``x <- exists "
"m[k1][k2][...]``. If one or more of the intermediate keys do not exist in"
" the corresponding map, the result is ``False``."
msgstr ""

#: ../scilla-in-depth.rst:1178
msgid ""
"``b <- & exists c.m[k]``: *In-place* remote key existence check. Works in"
" the same way as the local key existence check, except that ``m`` must "
"refer to a mutable field in the contract at address ``c``."
msgstr ""

#: ../scilla-in-depth.rst:1183
msgid ""
"``delete m[k]``: *In-place* remove. Removes a key ``k`` and its "
"associated value from the map ``m``. The identifier ``m`` must refer to a"
" mutable field in the current contract. Removal from nested maps is "
"supported with the syntax ``delete m[k1][k2][...]``. If one or more of "
"the intermediate keys do not exist in the corresponding map, then the "
"operation has no effect. Note that in the case of a nested removal "
"``delete m[k1][...][kn-1][kn]``, only the key-value association of ``kn``"
" is removed. The key-value bindings of ``k1`` to ``kn-1`` will remain in "
"the map."
msgstr ""

#: ../scilla-in-depth.rst:1196
msgid "Functional map operations"
msgstr ""

#: ../scilla-in-depth.rst:1198
msgid ""
"``builtin put m k v``: Insert a key ``k`` bound to a value ``v`` into a "
"map ``m``. Returns a new map which is a copy of the ``m`` but with ``k`` "
"associated with ``v``. If ``m`` already contains key ``k``, the old value"
" bound to ``k`` gets replaced by ``v`` in the result map. The value of "
"``m`` is unchanged. The ``put`` function is typically used in library "
"functions. Note that ``put`` makes a copy of ``m`` before inserting the "
"key-value pair."
msgstr ""

#: ../scilla-in-depth.rst:1206
msgid ""
"``builtin get m k``: Fetch the value associated with the key ``k`` in the"
" map ``m``. Returns an optional value (see the ``Option`` type below) -- "
"if ``k`` has an associated value ``v`` in ``m``, then the result is "
"``Some v``, otherwise the result is ``None``. The ``get`` function is "
"typically used in library functions."
msgstr ""

#: ../scilla-in-depth.rst:1212
msgid ""
"``builtin contains m k``: Is the key ``k`` associated with a value in the"
" map ``m``?  Returns a ``Bool``. The ``contains`` function is typically "
"used in library functions."
msgstr ""

#: ../scilla-in-depth.rst:1216
msgid ""
"``builtin remove m k``: Remove a key ``k`` and its associated value from "
"the map ``m``. Returns a new map which is a copy of ``m`` but with ``k`` "
"being unassociated with a value. The value of ``m`` is unchanged. If "
"``m`` does not contain key ``k`` the ``remove`` function simply returns a"
" copy of ``m`` with no indication that ``k`` is missing. The ``remove`` "
"function is typically used in library functions. Note that ``remove`` "
"makes a copy of ``m`` before removing the key-value pair."
msgstr ""

#: ../scilla-in-depth.rst:1224
msgid ""
"``builtin to_list m``: Convert a map ``m`` to a ``List (Pair kt vt)`` "
"where ``kt`` and ``vt`` are key and value types, respectively (see the "
"``List`` type below)."
msgstr ""

#: ../scilla-in-depth.rst:1228
msgid ""
"``builtin size m``: Return the number of bindings in map ``m``. The "
"result type is ``Uint32``. Calling this builtin consumes a small "
"*constant* amount of gas. But calling it directly on a *field* map is not"
" supported, meaning that getting the size of field maps while avoiding "
"expensive copying needs some more scaffolding, which you can find out "
"about in the :ref:`Field map size <field_map_size>` section."
msgstr ""

#: ../scilla-in-depth.rst:1237
msgid ""
"Builtin functions ``put`` and ``remove`` return a new map, which is a "
"possibly modified copy of the original map. This may affect performance!"
msgstr ""

#: ../scilla-in-depth.rst:1242
msgid ""
"Empty maps can be constructed using the ``Emp`` keyword, specifying the "
"key and value types as its arguments. This is the way to initialise "
"``Map`` fields to be empty. For example ``field foomap : Map Uint128 "
"String = Emp Uint128 String`` declares a ``Map`` field with keys of type "
"``Uint128`` and values of type ``String``, which is initialized to be the"
" empty map."
msgstr ""

#: ../scilla-in-depth.rst:1249
msgid "Block Numbers"
msgstr ""

#: ../scilla-in-depth.rst:1251
msgid ""
"Block numbers have a dedicated type ``BNum`` in Scilla. Variables of this"
" type are specified with the keyword ``BNum`` followed by an integer "
"value (for example ``BNum 101``)."
msgstr ""

#: ../scilla-in-depth.rst:1255
msgid "Scilla supports the following built-in operations on block numbers:"
msgstr ""

#: ../scilla-in-depth.rst:1257
msgid "``eq b1 b2``: Is ``b1`` equal to ``b2``? Returns a ``Bool``."
msgstr ""

#: ../scilla-in-depth.rst:1258
msgid "``blt b1 b2``: Is ``b1`` less than ``b2``? Returns a ``Bool``."
msgstr ""

#: ../scilla-in-depth.rst:1259
msgid ""
"``badd b1 i1``: Add ``i1`` of type ``UintX`` to ``b1`` of type ``BNum``. "
"Returns a ``BNum``."
msgstr ""

#: ../scilla-in-depth.rst:1261
msgid ""
"``bsub b1 b2``: Subtract ``b2`` from ``b1``, both of type ``BNum``. "
"Returns an ``Int256``."
msgstr ""

#: ../scilla-in-depth.rst:1265
msgid "Algebraic Datatypes"
msgstr ""

#: ../scilla-in-depth.rst:1268
msgid ""
"An `algebraic datatype` (ADT) is a composite type used commonly in "
"functional programming. Each ADT is defined as a set of **constructors**."
" Each constructor takes a set of arguments of certain types."
msgstr ""

#: ../scilla-in-depth.rst:1273
msgid ""
"Scilla is equipped with a number of built-in ADTs, which are described "
"below. Additionally, Scilla allows users to define their own ADTs."
msgstr ""

#: ../scilla-in-depth.rst:1278
msgid "Boolean"
msgstr ""

#: ../scilla-in-depth.rst:1280
msgid ""
"Boolean values are specified using the type ``Bool``. The ``Bool`` ADT "
"has two constructors ``True`` and ``False``, neither of which take any "
"arguments. Thus the following code fragment constructs a value of type "
"``Bool`` by using the constructor ``True``:"
msgstr ""

#: ../scilla-in-depth.rst:1291
msgid "Option"
msgstr ""

#: ../scilla-in-depth.rst:1293
msgid ""
"Optional values are specified using the type ``Option t``, where ``t`` is"
" some type. The ``Option`` ADT has two constructors:"
msgstr ""

#: ../scilla-in-depth.rst:1296
msgid ""
"``Some`` represents the presence of a value. The ``Some`` constructor "
"takes one argument (the value, of type ``t``)."
msgstr ""

#: ../scilla-in-depth.rst:1299
msgid ""
"``None`` represents the absence of a value. The ``None`` constructor "
"takes no arguments."
msgstr ""

#: ../scilla-in-depth.rst:1302
msgid ""
"The following code snippet constructs two optional values. The first "
"value is an absent string value, constructed using ``None``. The second "
"value is the ``Int32`` value 10, which, because the value is present, is "
"constructed using ``Some``:"
msgstr ""

#: ../scilla-in-depth.rst:1316
msgid ""
"Optional values are useful for initialising fields where the value is not"
" yet known:"
msgstr ""

#: ../scilla-in-depth.rst:1323
msgid ""
"Optional values are also useful for functions that might not have a "
"result, such as the ``get`` function for maps:"
msgstr ""

#: ../scilla-in-depth.rst:1341
msgid "List"
msgstr ""

#: ../scilla-in-depth.rst:1343
msgid ""
"Lists of values are specified using the type ``List t``, where ``t`` is "
"some type. The ``List`` ADT has two constructors:"
msgstr ""

#: ../scilla-in-depth.rst:1346
msgid ""
"``Nil`` represents an empty list. The ``Nil`` constructor takes no "
"arguments."
msgstr ""

#: ../scilla-in-depth.rst:1349
msgid ""
"``Cons`` represents a non-empty list. The ``Cons`` constructor takes two "
"arguments: The first element of the list (of type ``t``), and another "
"list (of type ``List t``) representing the rest of the list."
msgstr ""

#: ../scilla-in-depth.rst:1354
msgid ""
"All elements in a list must be of the same type ``t``. In other words, "
"two values of different types cannot be added to the same list."
msgstr ""

#: ../scilla-in-depth.rst:1357
msgid ""
"The following example shows how to build a list of ``Int32`` values. "
"First we create an empty list using the ``Nil`` constructor. We then add "
"four other values one by one using the ``Cons`` constructor. Notice how "
"the list is constructed backwards by adding the last element, then the "
"second-to-last element, and so on, so that the final list is ``[11; 10; "
"2; 1]``:"
msgstr ""

#: ../scilla-in-depth.rst:1377
msgid ""
"Scilla provides three structural recursion primitives for lists, which "
"can be used to traverse all the elements of any list:"
msgstr ""

#: ../scilla-in-depth.rst:1380
msgid ""
"``list_foldl: ('B -> 'A -> 'B) -> 'B -> (List 'A) -> 'B`` : Recursively "
"process the elements in a list from front to back, while keeping track of"
" an *accumulator* (which can be thought of as a running total). "
"``list_foldl`` takes three arguments, which all depend on the two type "
"variables ``'A`` and ``'B``:"
msgstr ""

#: ../scilla-in-depth.rst:1386
msgid ""
"The function processing the elements. This function takes two arguments. "
"The first argument is the current value of the accumulator (of type "
"``'B``). The second argument is the next list element to be processed (of"
" type ``'A``). The result of the function is the next value of the "
"accumulator (of type ``'B``)."
msgstr ""

#: ../scilla-in-depth.rst:1392
msgid "The initial value of the accumulator (of type ``'B``)."
msgstr ""

#: ../scilla-in-depth.rst:1394
msgid "The list of elements to be processed (of type ``(List 'A)``)."
msgstr ""

#: ../scilla-in-depth.rst:1396
msgid ""
"The result of applying ``list_foldl`` is the value of the accumulator (of"
" type ``'B``) when all list elements have been processed."
msgstr ""

#: ../scilla-in-depth.rst:1400
msgid ""
"``list_foldr: ('A -> 'B -> 'B) -> 'B -> (List 'A) -> 'B`` : Similar to "
"``list_foldl``, except the list elements are processed from back to "
"front. Notice also that the processing function takes the list element "
"and the accumulator in the opposite order from the order in "
"``list_foldl``."
msgstr ""

#: ../scilla-in-depth.rst:1406
msgid ""
"``list_foldk: ('B -> 'A -> ('B -> 'B) -> 'B) -> 'B -> (List 'A) -> 'B`` :"
" Recursively process the elements in a list according to a *folding "
"function*, while keeping track of an *accumulator*. ``list_foldk`` is a "
"more general version of the left and right folds, which, by the way, can "
"be both implemented in terms of it. ``list_foldk`` takes three arguments,"
" which all depend on the two type variables ``'A`` and ``'B``:"
msgstr ""

#: ../scilla-in-depth.rst:1414
msgid ""
"The function describing the fold step. This function takes three "
"arguments. The first argument is the current value of the accumulator (of"
" type ``'B``). The second argument is the next list element to be "
"processed (of type ``'A``). The third argument represents the postponed "
"recursive call (of type ``'B -> 'B``). The result of the function is the "
"next value of the accumulator (of type ``'B``). The computation "
"*terminates* if the programmer does not invoke the postponed recursive "
"call. This is a major difference between ``list_foldk`` and the left and "
"right folds which process their input lists from the beginning to the end"
" unconditionally."
msgstr ""

#: ../scilla-in-depth.rst:1425
msgid "The initial value of the accumulator ``z`` (of type ``'B``)."
msgstr ""

#: ../scilla-in-depth.rst:1427
msgid "The list of elements to be processed (of type ``List 'A``)."
msgstr ""

#: ../scilla-in-depth.rst:1431
msgid ""
"When an ADT takes type arguments (such as ``List 'A``), and occurs inside"
" a bigger type (such as the type of ``list_foldl``), the ADT and its "
"arguments must be grouped using parentheses ``( )``. This is the case "
"even when the ADT occurs as the only argument to another ADT. For "
"instance, when constructing an empty list of optional values of type "
"``Int32``, one must instantiate the list type using the syntax ``Nil "
"{(Option Int32)}``."
msgstr ""

#: ../scilla-in-depth.rst:1440
msgid ""
"To further illustrate the ``List`` type in Scilla, we show a small "
"example using ``list_foldl`` to count the number of elements in a list. "
"For an example of ``list_foldk`` see list_find_."
msgstr ""

#: ../scilla-in-depth.rst:1460
msgid ""
"``list_length`` defines a function that takes a type argument ``'A``, and"
" a normal (value) argument ``l`` of type ``List 'A``."
msgstr ""

#: ../scilla-in-depth.rst:1463
msgid ""
"``'A`` is a *type variable* which must be instantiated by the code that "
"intends to use ``list_length``. The type variable is specified in line 2."
msgstr ""

#: ../scilla-in-depth.rst:1467
msgid ""
"In line 4 we instantiate the types for ``list_foldl``. Since we are "
"traversing a list of values of type ``'A``, we pass ``'A`` as the first "
"type argument to ``list_foldl``, and since we are calculating the length "
"of the list (a non-negative integer), we pass ``Uint32`` as the "
"accumulator type."
msgstr ""

#: ../scilla-in-depth.rst:1473
msgid ""
"In line 5 we define the initial value of the accumulator. Since an empty "
"list has length 0, the initial value of the accumulator is 0 (of type "
"``Uint32``, to match the accumulator type)."
msgstr ""

#: ../scilla-in-depth.rst:1477
msgid ""
"In lines 6-10 we specify the processing function ``iter``, which takes "
"the current accumulator value ``z`` and the current list element ``h``. "
"In this case the processing function ignores the list element, and "
"increments the accumulator by 1. When all elements in the list have been "
"processed, the accumulator will have been incremented as many times as "
"there are elements in the list, and hence the final value of the "
"accumulator will be equal to the length of the list."
msgstr ""

#: ../scilla-in-depth.rst:1485
msgid ""
"In line 12 we apply the type-instantiated version of ``list_foldl`` from "
"line 4 to the processing function, the initial accumulator, and the list "
"of values."
msgstr ""

#: ../scilla-in-depth.rst:1489
msgid ""
"Common utilities for the ``List`` type (including ``list_length``) are "
"provided in the ``ListUtils`` library as part of the standard library "
"distribution for Scilla."
msgstr ""

#: ../scilla-in-depth.rst:1496
msgid "Pair"
msgstr ""

#: ../scilla-in-depth.rst:1499
msgid ""
"Pairs of values are specified using the type ``Pair t1 t2``, where ``t1``"
" and ``t2`` are types. The ``Pair`` ADT has one constructor:"
msgstr ""

#: ../scilla-in-depth.rst:1502
msgid ""
"``Pair`` represents a pair of values. The ``Pair`` constructor takes two "
"arguments, namely the two values of the pair, of types ``t1`` and ``t2``,"
" respectively."
msgstr ""

#: ../scilla-in-depth.rst:1508
msgid ""
"``Pair`` is both the name of a type and the name of a constructor of that"
" type. An ADT and a constructor typically only share their names when the"
" constructor is the only constructor of the ADT."
msgstr ""

#: ../scilla-in-depth.rst:1512
msgid ""
"A ``Pair`` value may contain values of different types. In other words, "
"``t1`` and ``t2`` need not be the same type."
msgstr ""

#: ../scilla-in-depth.rst:1515
msgid ""
"Below is an example where we declare a field ``pp`` of type ``Pair String"
" Uint32``, which we then initialise by constructing a pair consisting of "
"a value of type ``String`` and a value of type ``Uint32``:"
msgstr ""

#: ../scilla-in-depth.rst:1527
msgid ""
"Notice the difference in how we specify the type of the field as ``Pair "
"A' B'``, and how we specify the types of values given to the constructor "
"as ``Pair { A' B' }``."
msgstr ""

#: ../scilla-in-depth.rst:1533
msgid ""
"We now illustrate how pattern matching can be used to extract the first "
"element from a ``Pair``. The function ``fst`` shown below is defined in "
"the ``PairUtils`` library of the Scilla standard library."
msgstr ""

#: ../scilla-in-depth.rst:1547
msgid ""
"To apply ``fst`` to one must first instantiate the type variables ``'A`` "
"and ``'B``, which is done as follows:"
msgstr ""

#: ../scilla-in-depth.rst:1556
msgid ""
"The value associated with the identifier ``p_fst`` will be the string "
"``\"Hello\"``."
msgstr ""

#: ../scilla-in-depth.rst:1561
msgid ""
"Using ``Pair`` is generally discouraged. Instead, the programmer should "
"define an ADT which is specialised to the particular type of pairs that "
"is needed in the particular use case. See the section on `User-defined "
"ADTs`_ below."
msgstr ""

#: ../scilla-in-depth.rst:1568
msgid "Nat"
msgstr ""

#: ../scilla-in-depth.rst:1570
msgid ""
"Peano numbers are specified using the type ``Nat``. The ``Nat`` ADT has "
"two constructors:"
msgstr ""

#: ../scilla-in-depth.rst:1573
msgid ""
"``Zero`` represents the number 0. The ``Zero`` constructor takes no "
"arguments."
msgstr ""

#: ../scilla-in-depth.rst:1576
msgid ""
"``Succ`` represents the successor of another Peano number. The ``Succ`` "
"constructor takes one argument (of type ``Nat``) which represents the "
"Peano number that is one less than the current number."
msgstr ""

#: ../scilla-in-depth.rst:1581
msgid ""
"The following code shows how to build the Peano number corresponding to "
"the integer 3:"
msgstr ""

#: ../scilla-in-depth.rst:1592
msgid ""
"Scilla provides two structural recursion primitives for Peano numbers, "
"which can be used to traverse all the Peano numbers from a given ``Nat`` "
"down to ``Zero``:"
msgstr ""

#: ../scilla-in-depth.rst:1596
msgid ""
"``nat_fold: ('A -> Nat -> 'A) -> 'A -> Nat -> 'A``: Recursively process "
"the succession of numbers from a ``Nat`` down to ``Zero``, while keeping "
"track of an accumulator. ``nat_fold`` takes three arguments, two of which"
" depend on the type variable ``'A``:"
msgstr ""

#: ../scilla-in-depth.rst:1601
msgid ""
"The function processing the numbers. This function takes two arguments. "
"The first argument is the current value of the accumulator (of type "
"``'A``). The second argument is the next Peano number to be processed (of"
" type ``Nat``). Incidentally, the next number to be processed is the "
"predecessor of the current number being processed. The result of the "
"function is the next value of the accumulator (of type ``'A``)."
msgstr ""

#: ../scilla-in-depth.rst:1609
msgid "The initial value of the accumulator (of type ``'A``)."
msgstr ""

#: ../scilla-in-depth.rst:1611
msgid "The first Peano number to be processed (of type ``Nat``)."
msgstr ""

#: ../scilla-in-depth.rst:1613
msgid ""
"The result of applying ``nat_fold`` is the value of the accumulator (of "
"type ``'A``) when all Peano numbers down to ``Zero`` have been processed."
msgstr ""

#: ../scilla-in-depth.rst:1617
msgid ""
"``nat_foldk: ('A -> Nat -> ('A -> 'A) -> 'A) -> 'A -> Nat -> 'A``: "
"Recursively process the Peano numbers down to zero according to a "
"*folding function*, while keeping track of an *accumulator*. "
"``nat_foldk`` is a more general version of the left fold allowing for "
"early termination. It takes three arguments, two depending on the type "
"variable ``'A``."
msgstr ""

#: ../scilla-in-depth.rst:1624
msgid ""
"The function describing the fold step. This function takes three "
"arguments. The first argument is the current value of the accumulator (of"
" type ``'A``). The second argument is the predecessor of the Peano number"
" being processed (of type ``Nat``). The third argument represents the "
"postponed recursive call (of type ``'A -> 'A``). The result of the "
"function is the next value of the accumulator (of type ``'A``). The "
"computation *terminates* if the programmer does not invoke the postponed "
"recursive call. Left folds inevitably process the whole list whereas "
"``nat_foldk`` can differ in this regard."
msgstr ""

#: ../scilla-in-depth.rst:1636
msgid "The initial value of the accumulator ``z`` (of type ``'A``)."
msgstr ""

#: ../scilla-in-depth.rst:1638
msgid "The Peano number to be processed (of type ``Nat``)."
msgstr ""

#: ../scilla-in-depth.rst:1640
msgid ""
"To better understand ``nat_foldk``, we explain how ``nat_eq`` works. "
"``nat_eq`` checks to see if two Peano numbers are equivalent. Below is "
"the program, with line numbers and an explanation."
msgstr ""

#: ../scilla-in-depth.rst:1662
msgid ""
"Line 2 specifies that we take two Peano numbers ``m`` and ``n``. Line 3 "
"instantiates the type of ``nat_foldk``, we give it ``Nat`` because we "
"will be passing a ``Nat`` value as the fold accumulator."
msgstr ""

#: ../scilla-in-depth.rst:1666
msgid ""
"Lines 4 to 8 specify the fold description, this is the first argument "
"that ``nat_foldk`` takes usually of type ``'A -> Nat -> ('A -> 'A) -> "
"'A`` but we have specified that ``'A`` is ``Nat`` in this case. Our "
"function takes the accumulator ``n`` and ``ignore : Nat`` is the "
"predecessor of the number being processed which we don't care about in "
"this particular case."
msgstr ""

#: ../scilla-in-depth.rst:1672
msgid ""
"Essentially, we start accumulating the end result from ``n`` and iterate "
"at most ``m`` times (see line 10), decrementing both ``n`` and ``m`` at "
"each recursive step (lines 4 - 9). The ``m`` variable gets decremented "
"implicitly because this is how ``nat_foldk`` works under the hood. And we"
" explicitly decrement ``n`` using pattern matching (lines 6, 7). To "
"continue iteratively decrement both ``m`` and ``n`` we use ``recurse`` on"
" line 7. If the two input numbers are equal, we will get the accumulator "
"(``n``) equal to zero in the end. We call the final value of the "
"accumulator ``remaining`` on line 10. At the end we will be checking to "
"see if our accumulator ended up at ``Zero`` to say if the input numbers "
"are equal. The last lines, return ``True`` when the result of the fold is"
" ``Zero`` and ``False`` otherwise as described above."
msgstr ""

#: ../scilla-in-depth.rst:1687
msgid ""
"In the case when accumulator ``n`` reaches zero (line 8) while ``m`` "
"still has not been fully processed, we stop iteration (hence no "
"``recurse`` on that line) and return a non-zero natural number to "
"indicate inequality. Any number (e.g. ``Succ Zero``) would do, but to "
"make the code concise we return the original input number ``m`` because "
"we know ``iter`` gets called on ``m`` only if it's not zero."
msgstr ""

#: ../scilla-in-depth.rst:1695
msgid ""
"In the symmetrical case when ``m`` reaches zero while the accumulator "
"``n`` is still strictly positive, we indicate inequality, because "
"``remaining`` gets this final value of ``n``."
msgstr ""

#: ../scilla-in-depth.rst:1700
msgid "User-defined ADTs"
msgstr ""

#: ../scilla-in-depth.rst:1702
msgid ""
"In addition to the built-in ADTs described above, Scilla supports user-"
"defined ADTs."
msgstr ""

#: ../scilla-in-depth.rst:1705
msgid ""
"ADT definitions may only occur in the library parts of a program, either "
"in the library part of the contract, or in an imported library. An ADT "
"definition is in scope in the entire library in which it is defined, "
"except that an ADT definition may only refer to other ADT definitions "
"defined earlier in the same library, or in imported libraries. In "
"particular, an ADT definition may not refer to itself in an "
"inductive/recursive manner."
msgstr ""

#: ../scilla-in-depth.rst:1713
msgid ""
"Each ADT defines a set of constructors. Each constructor specifies a "
"number of types which corresponds to the number and types of arguments "
"that the constructor takes. A constructor may be specified as taking no "
"arguments."
msgstr ""

#: ../scilla-in-depth.rst:1718
msgid ""
"The ADTs of a contract must have distinct names, and the set of all "
"constructors of all ADTs in a contract must also have distinct names. "
"Both the ADT and constructor names must begin with a capital letter ('A' "
"- 'Z'). However, a constructor and an ADT may have the same name, as is "
"the case with the ``Pair`` type whose only constructor is also called "
"``Pair``."
msgstr ""

#: ../scilla-in-depth.rst:1725
msgid ""
"As an example of user-defined ADTs, consider the following type "
"declarations from a contract implementing a chess-like game called Shogi "
"or Japanese Chess (https://en.wikipedia.org/wiki/Shogi). When in turn, a "
"player can choose to either move one of his pieces, place a previously "
"captured piece back onto the board, or resign and award the victory to "
"the opponent."
msgstr ""

#: ../scilla-in-depth.rst:1732
msgid "The pieces of the game can be defined using the following type ``Piece``:"
msgstr ""

#: ../scilla-in-depth.rst:1747
msgid ""
"Each of the constructors represents a type of piece in the game. None of "
"the constructors take any arguments."
msgstr ""

#: ../scilla-in-depth.rst:1750
msgid ""
"The board is represented as a set of squares, where each square has two "
"coordinates:"
msgstr ""

#: ../scilla-in-depth.rst:1758
msgid ""
"The type ``Square`` is an example of a type where a constructor has the "
"same name as the type. This usually happens when a type has only one "
"constructor. The constructor ``Square`` takes two arguments, both of type"
" ``Uint32``, which are the coordinates (the row and the column) of the "
"square on the board."
msgstr ""

#: ../scilla-in-depth.rst:1764
msgid ""
"Similar to the definition of the type ``Piece``, we can define the type "
"of direction of movement using a constructor for each of the legal "
"directions as follows:"
msgstr ""

#: ../scilla-in-depth.rst:1780
msgid ""
"We are now in a position to define the type of possible actions that a "
"user may choose to perform when in turn:"
msgstr ""

#: ../scilla-in-depth.rst:1790
msgid ""
"If a player chooses to move a piece, she should use the constructor "
"``Move``, and provide four arguments:"
msgstr ""

#: ../scilla-in-depth.rst:1793
msgid ""
"An argument of type ``Square``, indicating the current position of the "
"piece she wants to move."
msgstr ""

#: ../scilla-in-depth.rst:1796
msgid "An argument of type ``Direction``, indicating the direction of movement."
msgstr ""

#: ../scilla-in-depth.rst:1799
msgid ""
"An argument of type ``Uint32``, indicating the distance the piece should "
"move."
msgstr ""

#: ../scilla-in-depth.rst:1802
msgid ""
"An argument of type ``Bool``, indicating whether the moved piece should "
"be promoted after being moved."
msgstr ""

#: ../scilla-in-depth.rst:1805
msgid ""
"If instead the player chooses to place a previously captured piece back "
"onto the board, she should use the constructor ``Place``, and provide two"
" arguments:"
msgstr ""

#: ../scilla-in-depth.rst:1809
msgid ""
"An argument of type ``Piece``, indicating which piece to place on the "
"board."
msgstr ""

#: ../scilla-in-depth.rst:1812
msgid ""
"An argument of type ``Square``, indicating the position the piece should "
"be placed in."
msgstr ""

#: ../scilla-in-depth.rst:1815
msgid ""
"Finally, if the player chooses to resign and award the victory to her "
"opponent, she should use the constructor ``Resign``. Since ``Resign`` "
"does not take any arguments, no arguments should be provided."
msgstr ""

#: ../scilla-in-depth.rst:1819
msgid ""
"To check which action a player has chosen we use a match statement or a "
"match expression:"
msgstr ""

#: ../scilla-in-depth.rst:1839
msgid "Type identity for user-defined ADTs"
msgstr ""

#: ../scilla-in-depth.rst:1843
msgid ""
"Due to a bug in the Scilla implementation the information in this section"
" is only valid from Scilla version 0.10.0 and forwards. Contracts written"
" in Scilla versions prior to 0.10.0 and which exploit this bug will have "
"to be rewritten and redeployed, as they will no longer work from version "
"0.10.0 and onwards."
msgstr ""

#: ../scilla-in-depth.rst:1849
msgid ""
"Each type declaration defines a unique type. In particular this means "
"that even if two libraries both define identical types, the types are "
"considered different."
msgstr ""

#: ../scilla-in-depth.rst:1853
msgid "As an example, consider the following two contracts:"
msgstr ""

#: ../scilla-in-depth.rst:1896
msgid ""
"Even though both contracts define identical types ``T``, the two types "
"are considered different in Scilla. In particlar this means that the "
"message sent from ``Contract1`` to ``Contract2`` will not trigger the "
"``Receiving`` transition, because the value sent as the ``param`` message"
" field has the type ``T`` from ``Contract1``, whereas the type ``T`` from"
" ``Contract2`` is expected."
msgstr ""

#: ../scilla-in-depth.rst:1903
msgid ""
"In order to pass a value of a user-defined ADT as a parameter to a "
"transition, the type must be defined in a user-defined library, which "
"both the sending and the receiving contract must import:"
msgstr ""

#: ../scilla-in-depth.rst:1955
msgid ""
"The section :ref:`user-defined_libraries` has more information on how to "
"define and use libraries."
msgstr ""

#: ../scilla-in-depth.rst:1959
msgid "More ADT examples"
msgstr ""

#: ../scilla-in-depth.rst:1961
msgid ""
"To further illustrate how ADTs can be used, we provide some more examples"
" and describe them in detail. Versions of both the functions described "
"below can be found in the ``ListUtils`` part of the :doc:`Scilla standard"
" library <stdlib>`."
msgstr ""

#: ../scilla-in-depth.rst:1967
msgid "Computing the Head of a List"
msgstr ""

#: ../scilla-in-depth.rst:1969
msgid "The function ``list_head`` returns the first element of a list."
msgstr ""

#: ../scilla-in-depth.rst:1971
msgid ""
"Since a list may be empty, ``list_head`` may not always be able to "
"compute a result, and thus should return a value of the ``Option`` type. "
"If the list is non-empty, and the first element is ``h``, then "
"``list_head`` should return ``Some h``. Otherwise, if the list is empty, "
"``list_head`` should return ``None``."
msgstr ""

#: ../scilla-in-depth.rst:1977
msgid ""
"The following code snippet shows the implementation of ``list_head``, and"
" how to apply it:"
msgstr ""

#: ../scilla-in-depth.rst:2005
msgid ""
"Line 2 specifies that ``'A`` is a type parameter to the function, while "
"line 3 specifies that ``l`` is a (value) parameter of type ``List 'A``. "
"In other words, lines 1-3 specify a function ``list_head`` which can be "
"instantiated for any type ``'A``, and which takes as an argument a value "
"of type ``List 'A``."
msgstr ""

#: ../scilla-in-depth.rst:2011
msgid ""
"The pattern-match in lines 4-9 matches on the value of ``l``. In line 5 "
"we match on the list constructor ``Cons h t``, where ``h`` is the first "
"element of the list, and ``t`` is the rest of the list. If the list is "
"not empty then the match is successful, and we return the first element "
"as an optional value ``Some h``. In line 7 we match on the list "
"constructor ``Nil``. If the list is empty then the match is successful, "
"and we return the optional value ``None`` indicating that there was no "
"head element of the list."
msgstr ""

#: ../scilla-in-depth.rst:2020
msgid ""
"Line 11 instantiates the ``list_head`` function for the type ``Int32``, "
"so that ``list_head`` can be applied to values of type ``List Int32``. "
"Lines 13-20 build a list of type ``List Int32``, and line 21 invokes the "
"instantiated ``list_head`` function on the list that was built."
msgstr ""

#: ../scilla-in-depth.rst:2027
msgid "Computing a Left Fold"
msgstr ""

#: ../scilla-in-depth.rst:2029
msgid ""
"The function ``list_foldl`` returns the result of a left fold given a "
"function ``f : 'B -> 'A -> 'B``, accumulator ``z : 'B`` and list ``xs : "
"List 'A``. This can be implemented as a recursion primitive or a list "
"utility function."
msgstr ""

#: ../scilla-in-depth.rst:2033
msgid ""
"A left fold is a recursive application of an accumulator ``z`` and next "
"list element ``x : 'A`` with ``f`` repetitively until there are no more "
"list elements. For example the left fold on ``[1,2,3]`` using subtraction"
" starting with accumulator 0 would be ``((0-1)-2)-3 = -6``. The left fold"
" is explained in pseudocode below, note that the result is always the "
"accumulator type."
msgstr ""

#: ../scilla-in-depth.rst:2045
msgid ""
"The same can be achieved with ``list_foldk`` by partially applying a left"
" fold description; this avoids illegal direct recursion. Our fold "
"description ``left_f : 'B -> 'A -> ('B -> 'B) -> 'B`` takes arguments "
"accumulator, next list element and recursive call. The recursive call "
"will be supplied by the ``list_foldk`` function. An implementation is "
"explained below."
msgstr ""

#: ../scilla-in-depth.rst:2063
msgid ""
"On line 1, we declare the name and type signature as according to the "
"first paragraph. On the second line, we say that the function takes two "
"types as arguments ``'A`` and ``'B``. The third line says that we take "
"some function ``f`` to process the list element and accumulator, as in "
"paragraph two."
msgstr ""

#: ../scilla-in-depth.rst:2068
msgid ""
"On line 4, we define the fold description using ``f``. The fold "
"description does not take a function but instead it should be implemented"
" in terms of some function, as according to the type signature, ``left_f "
": 'B -> 'A -> ('B -> 'B) -> 'B``. ``left_f`` takes arguments as described"
" in paragraph two. We calculate the new accumulator ``f z x`` and call it"
" ``res``. Then we recursively call with the new accumulator."
msgstr ""

#: ../scilla-in-depth.rst:2075
msgid ""
"On line 7, we instantiate an instance of ``list_foldk`` that has the "
"right types for the job using a type application."
msgstr ""

#: ../scilla-in-depth.rst:2078
msgid ""
"On line 8, we partially apply ``folder`` with the left fold description. "
". What is significant about ``list_foldk`` is that when calling the "
"description, it provides a recursive call to itself, changing to the next"
" element in the list and respective tail each time. This results in a "
"function that just needs the user to provide the updated accumulator in "
"the description."
msgstr ""

#: ../scilla-in-depth.rst:2085
msgid "Computing a Right Fold"
msgstr ""

#: ../scilla-in-depth.rst:2087
msgid ""
"The function ``list_foldr`` returns the result of a right fold given some"
" function ``f : 'A -> 'B -> 'B``, accumulator ``z : 'B`` and list ``xs : "
"List 'A``. Like ``list_foldl``, this can be a recursion primitive or a "
"list utility function."
msgstr ""

#: ../scilla-in-depth.rst:2092
msgid ""
"A right fold is similar to a left fold but is reversed in a way. The "
"right fold applies a function ``f`` with an accumulator ``z`` starting "
"from the end and then combines with the second last element, third last "
"element, etc... until it reaches the beginning. For example a right fold "
"on the list ``[1,2,3]`` with subtraction starting with accumulator 0 "
"would be equal to ``1-(2-(3-0)) = 2``. It is listed below in pseudocode, "
"note that the result is always the accumulator type."
msgstr ""

#: ../scilla-in-depth.rst:2106
msgid ""
"Like before, the same can be achieved with ``list_foldk`` by partially "
"applying a right fold description. The fold description takes arguments "
"accumulator ``z : 'B``, next list element ``x : 'A`` and recursive call "
"``recurse : 'B -> 'B``. The recursive call will be supplied by the "
"``list_foldk`` function. An implementation is explained below."
msgstr ""

#: ../scilla-in-depth.rst:2123
msgid ""
"This is very similar to before. On line 1 we declare the name and type "
"signature, according to the first paragraph. On line 2, we take two type "
"arguments ``'A`` and ``'B``. The third line says that we take some "
"function ``f`` to process the list element ``x : 'A`` and accumulator "
"``z``. The argument order is necessarily different to that of a left "
"fold."
msgstr ""

#: ../scilla-in-depth.rst:2129
msgid ""
"Following that we write a fold description like before. ``list_foldk`` "
"processes lists from left to right. But we need ``list_foldr`` to emulate"
" the right-to-left traversal. By calling ``recurse z`` on line 5 as our "
"first action, we postpone actual computation with the combining function "
"``f`` preserving the original accumulator until the very end. Once the "
"recursive call reaches an empty list it returns the original accumulator."
" Then the function calls ``f x res`` (line 5) will evaluate outwards "
"combining from the end to the beginning, see paragraph two."
msgstr ""

#: ../scilla-in-depth.rst:2138
msgid ""
"The recursive call ``recurse z`` on line 5 may seem to be the same each "
"time but what is changing is the list element we process."
msgstr ""

#: ../scilla-in-depth.rst:2141
msgid ""
"On line 6, we instantiate ``list_foldk`` by applying the types ``'A`` and"
" ``'B`` to make a type-specific function. The last line we partially "
"apply ``folder`` with the right fold description. Like before what is "
"special about ``list_foldk`` is that it calls this function with a "
"recursive call to itself that each time slightly truncates the list; this"
" provides the recursion."
msgstr ""

#: ../scilla-in-depth.rst:2148
msgid "Checking for Existence in a List"
msgstr ""

#: ../scilla-in-depth.rst:2150
msgid ""
"The function ``list_exists`` takes a predicate function and a list, and "
"returns a value indicating whether the predicate holds for at least one "
"element in the list."
msgstr ""

#: ../scilla-in-depth.rst:2154
msgid ""
"A predicate function is a function returning a Boolean value, and since "
"we want to apply it to elements in the list, the argument type of the "
"function should be the same as the element type of the list."
msgstr ""

#: ../scilla-in-depth.rst:2158
msgid ""
"``list_exists`` should return either ``True`` (if the predicate holds for"
" at least one element) or ``False`` (if the predicate does not hold for "
"any element in the list), so the return type of ``list_exists`` should be"
" ``Bool``."
msgstr ""

#: ../scilla-in-depth.rst:2163
msgid ""
"The following code snippet shows the implementation of ``list_exists``, "
"and how to apply it:"
msgstr ""

#: ../scilla-in-depth.rst:2201
msgid ""
"As in the previous example ``'A`` is a type variable to the function. The"
" function takes two arguments:"
msgstr ""

#: ../scilla-in-depth.rst:2204
msgid ""
"A predicate ``f``, i.e., a function that returns a ``Bool``. In this "
"case, ``f`` will be applied to elements of the list, so the argument type"
" of the predicate should be ``'A``. Hence, ``f`` should have the type "
"``'A -> Bool``."
msgstr ""

#: ../scilla-in-depth.rst:2209
msgid ""
"A list of elements ``l`` of type ``List 'A``, so that the type of the "
"elements in the list matches the argument type of ``f``."
msgstr ""

#: ../scilla-in-depth.rst:2212
msgid ""
"To traverse the elements of the input list ``l`` we use ``list_foldl``. "
"In line 5 we instantiate ``list_foldl`` for lists with elements of type "
"``'A`` and for the accumulator type ``Bool``. In line 6 we set the "
"initial accumulator value to ``False`` to indicate that no element "
"satisfying the predicate has yet been seen."
msgstr ""

#: ../scilla-in-depth.rst:2218
msgid ""
"The processing function ``iter`` defined in lines 7-16 tests the "
"predicate on the current list element, and returns an updated "
"accumulator. If an element has been found which satisfies the predicate, "
"the accumulator is set to ``True`` and remains so for the rest of the "
"traversal."
msgstr ""

#: ../scilla-in-depth.rst:2224
msgid ""
"The final value of the accumulator is either ``True``, indicating that "
"``f`` returned ``True`` for at least one element in the list, or "
"``False``, indicating that ``f`` returned ``False`` for all elements in "
"the list."
msgstr ""

#: ../scilla-in-depth.rst:2229
msgid ""
"In line 20 we instantiate ``list_exists`` to work on lists of type "
"``Int128``. In lines 21-24 we define the predicate, which returns "
"``True`` if its argument is less than 3, and returns ``False`` otherwise."
msgstr ""

#: ../scilla-in-depth.rst:2234
msgid ""
"Omitted in line 27 is building the same list ``l3`` as in the previous "
"example. In line 30 we apply the instantiated ``list_exists`` to the "
"predicate and the list."
msgstr ""

#: ../scilla-in-depth.rst:2241
msgid "Finding the first occurrence satisfying a predicate"
msgstr ""

#: ../scilla-in-depth.rst:2243
msgid ""
"The function ``list_find`` searches for the first occurrence in a list "
"that satisfies some predicate ``p : 'A -> Bool``. It takes the predicate "
"and the list, returning ``Some {'A} x :: Option 'A`` if ``x`` is the "
"first element such that ``p x`` and ``None {'A} :: Option 'A`` otherwise."
msgstr ""

#: ../scilla-in-depth.rst:2249
msgid ""
"Below we have an implementation of ``list_find`` that illustrates how to "
"use ``list_foldk``."
msgstr ""

#: ../scilla-in-depth.rst:2271
msgid ""
"Like before, we take a type variable ``'A`` on line 2 and take the "
"predicate on the next line. We begin by using this type variable to "
"instantiate ``foldk``, by giving it our processing type and return type. "
"The processing type being the list element type and the result type being"
" ``Option 'A``. The next line is our accumulator, we assume that at the "
"start of the search there is no satisfier."
msgstr ""

#: ../scilla-in-depth.rst:2278
msgid ""
"On line 7, we write a fold description for ``foldk``. This embodies the "
"order of the recursion and conditions for recursion. ``predicate_step`` "
"has the type ``Option 'A -> 'A -> (Option 'A -> Option 'A) -> Option "
"'A``. The first argument is the accumulator, the second ``x`` is the next"
" element to process and the third ``recurse`` is the recursive call. We "
"do not care what the accumulator ``ignore`` is since if it mattered we "
"will have already terminated."
msgstr ""

#: ../scilla-in-depth.rst:2286
msgid ""
"On lines 10 to 12 check for ``p x`` and if so return ``Some {'A} x``. In "
"the case that ``p x`` does not hold, try again from scratch with the next"
" element and so on via recursion. ``recurse init`` is in pseudo-code "
"equal to ``λk. foldk predicate_step init k xs`` where ``xs`` is the tail "
"of our list of to be processed elements."
msgstr ""

#: ../scilla-in-depth.rst:2292
msgid ""
"With the final line we partially apply ``foldk`` so that it just takes a "
"list argument and gives us our final answer. The first argument of "
"``foldk`` gives us the specific fold we want, for example if you wanted a"
" left fold you would replace ``predicate_step`` with something else."
msgstr ""

#: ../scilla-in-depth.rst:2298
msgid "Standard Libraries"
msgstr ""

#: ../scilla-in-depth.rst:2299
msgid "The Scilla standard library is :doc:`documented<stdlib>` separately."
msgstr ""

#: ../scilla-in-depth.rst:2304
msgid "User-defined Libraries"
msgstr ""

#: ../scilla-in-depth.rst:2306
msgid ""
"In addition to the standard library provided by Scilla, users are allowed"
" to deploy library code on the blockchain. Library files are allowed to "
"only contain pure Scilla code (which is the same restriction that in-"
"contract library code has). Library files must use the ``.scillib`` file "
"extension."
msgstr ""

#: ../scilla-in-depth.rst:2311
msgid ""
"Below is an example of a user-defined library that defines a single "
"function ``add_if_equal`` that adds to ``Uint128`` values if they are "
"equal and returns ``0`` otherwise."
msgstr ""

#: ../scilla-in-depth.rst:2328
msgid ""
"The structure of a library file is similar to the structure of the "
"library part of a Scilla contract. A library file contains definitions of"
" variables and pure library functions, but does not contain an actual "
"contract definition with parameters, fields, transitions and so on."
msgstr ""

#: ../scilla-in-depth.rst:2333
msgid ""
"Of particular importance is that a library cannot declare fields. "
"Therefore, all libraries are stateless and can only contain pure code."
msgstr ""

#: ../scilla-in-depth.rst:2336
msgid ""
"Similar to how contracts can import libraries, a library can import other"
" libraries (including user-defined libraries) too. The scope of variables"
" in an imported library is restricted to the immediate importer. So if "
"``X`` imports library ``Y`` which in turn imports library ``Z``, then the"
" names in ``Z`` are not in scope in `X``, but only in ``Y``. Cyclic "
"dependencies in imports are not allowed and flagged as errors during the "
"checking phase."
msgstr ""

#: ../scilla-in-depth.rst:2345
msgid "Local Development with User-defined Libraries"
msgstr ""

#: ../scilla-in-depth.rst:2347
msgid ""
"To use variables and functions declared in an external (user-defined) "
"library module, the command line argument to the Scilla executables must "
"include a ``-libdir`` option, along with a list of directories  as an "
"argument. If the Scilla file imports a library ``ALib``, then the Scilla "
"executable will search for a library file called ``ALib.scillib`` in the "
"directories provided. If more than one directory contains a file with the"
" correct name, then the directories are given priority in the same order "
"as they are provided to the Scilla executable. Alternatively, the "
"environment variable ``SCILLA_STDLIB_PATH`` can be set to a list of "
"library directories."
msgstr ""

#: ../scilla-in-depth.rst:2355
msgid ""
"``scilla-checker`` typechecks library modules in the same way as contract"
" modules. Similarly, ``scilla-runner`` can deploy libraries. Note that "
"``scilla-runner`` takes a ``blockhain.json`` as argument (the way it does"
" for :ref:`Contract Creation <calling-interface>`) to be command line "
"argument compatible with contract creation."
msgstr ""

#: ../scilla-in-depth.rst:2361
msgid "User-defined Libraries on the Blockchain"
msgstr ""

#: ../scilla-in-depth.rst:2363
msgid ""
"While the Zilliqa blockchain is designed to provide the standard Scilla "
"libraries to an executing contract, it must be provided with extra "
"information to support user-defined libraries."
msgstr ""

#: ../scilla-in-depth.rst:2367
msgid ""
"The ``init.json`` of a library must include a ``Bool`` entry named "
"``_library``, set to ``True``. Additionally, A contract or a library that"
" imports user-defined libraries must include in its `init.json` an entry "
"named ``_extlibs``, of Scilla type ``List (Pair String ByStr20)``. Each "
"entry in the list maps an imported library's name to its address in the "
"blockchain."
msgstr ""

#: ../scilla-in-depth.rst:2373
msgid ""
"Continuing the previous example, a contract or library that imports "
"``Examplelib`` should have the following entry in its ``init.json``:"
msgstr ""

#: ../scilla-in-depth.rst:2400
msgid "Namespaces"
msgstr ""

#: ../scilla-in-depth.rst:2401
msgid ""
"Import statements can be used to define separate namespaces for imported "
"names. To push the names from a library ``Foo`` into the namespace "
"``Bar``, use the statement ``import Foo as Bar``. Accessing a variable "
"``v`` in Foo must now be done using the qualified name ``Bar.v``. This is"
" useful when importing multiple libraries that define the same name."
msgstr ""

#: ../scilla-in-depth.rst:2406
msgid ""
"The same variable name must not be defined more than once in the same "
"namespace, so if multiple imported libraries define the same name, then "
"at most one of the libraries may reside in the default (unqualified) "
"namespace. All other conflicting libraries must be pushed to separate "
"namespaces."
msgstr ""

#: ../scilla-in-depth.rst:2411
msgid ""
"Extending our previous example, shown below is a contract that imports "
"``ExampleLib`` in namespace ``Bar``, to use the function "
"``add_if_equal``."
msgstr ""

#: ../scilla-in-depth.rst:2430
msgid "Scilla versions"
msgstr ""

#: ../scilla-in-depth.rst:2434
msgid "Major and Minor versions"
msgstr ""

#: ../scilla-in-depth.rst:2436
msgid ""
"Scilla releases have a major version, minor version and a patch number, "
"denoted as ``X.Y.Z`` where ``X`` is the major version, ``Y`` is the minor"
" version, and ``Z`` the patch number."
msgstr ""

#: ../scilla-in-depth.rst:2440
msgid ""
"Patches are usually bug fixes that do not impact the behaviour of "
"existing contracts. Patches are backward compatible."
msgstr ""

#: ../scilla-in-depth.rst:2443
msgid ""
"Minor versions typically include performance improvements and feature "
"additions that do not affect the behaviour of existing contracts. Minor "
"versions are backward compatible until the latest major version."
msgstr ""

#: ../scilla-in-depth.rst:2448
msgid ""
"Major versions are not backward compatible. It is expected that miners "
"have access to implementations of each major version of Scilla for "
"running contracts set to that major version."
msgstr ""

#: ../scilla-in-depth.rst:2452
msgid ""
"Within a major version, miners are advised to use the latest minor "
"revision."
msgstr ""

#: ../scilla-in-depth.rst:2455
msgid ""
"The command ``scilla-runner -version`` will print major, minor and patch "
"versions of the interpreter being invoked."
msgstr ""

#: ../scilla-in-depth.rst:2460
msgid "Contract Syntax"
msgstr ""

#: ../scilla-in-depth.rst:2462
msgid ""
"Every Scilla contract must begin with a major version declaration. The "
"syntax is shown below:"
msgstr ""

#: ../scilla-in-depth.rst:2490
msgid ""
"When deploying a contract the output of the interpreter contains the "
"field ``scilla_version : X.Y.Z``, to be used by the blockchain code to "
"keep track of the version of the contract. Similarly, ``scilla-checker`` "
"also reports the version of the contract on a successful check."
msgstr ""

#: ../scilla-in-depth.rst:2497
msgid "The ``init.json`` file"
msgstr ""

#: ../scilla-in-depth.rst:2499
msgid ""
"In addition to the version specified in the contract source code, it is "
"also required that the contract's ``init.json`` specifies the same "
"version when the contract is deployed and when the contract's transitions"
" are invoked. This eases the process for the blockchain code to decide "
"which interpreter to invoke."
msgstr ""

#: ../scilla-in-depth.rst:2505
msgid ""
"A mismatch in the versions specified in ``init.json`` and the source code"
" will lead to a gas-charged error by the interpreter."
msgstr ""

#: ../scilla-in-depth.rst:2508
msgid "An example ``init.json``:"
msgstr ""

#: ../scilla-in-depth.rst:2527
msgid "Chain Calls"
msgstr ""

#: ../scilla-in-depth.rst:2530
msgid ""
"When a user invokes a transition on a contract by sending a message with "
"the contract's address as the recipient, then that transition may then "
"send one or more messages onwards, possibly invoking other transitions on"
" other contracts. The resulting collection of messages, fund transfers, "
"transition invocations, and contract state changes are referred to as a "
"*transaction*."
msgstr ""

#: ../scilla-in-depth.rst:2537
msgid ""
"A transition that sends a message invoking another transition (typically "
"on another contract) is referred to as a *chain call*."
msgstr ""

#: ../scilla-in-depth.rst:2540
msgid ""
"During a transaction a LIFO queue (i.e., a stack) of unprocessed messages"
" is maintained. Initially, the message queue contains only the single "
"message sent by the original user, but additional messages may be added "
"to the queue when a transition performs a chain call."
msgstr ""

#: ../scilla-in-depth.rst:2545
msgid ""
"When a transition finishes, its outgoing messages are added to the "
"message queue. The first message in the queue is then removed from the "
"queue for processing. If there are no messages left to process, then the "
"transaction finishes, and all state changes and fund transfers are "
"committed to the blockchain."
msgstr ""

#: ../scilla-in-depth.rst:2551
msgid ""
"When a transition sends multiple messages, the messages are added to the "
"queue in the following order:"
msgstr ""

#: ../scilla-in-depth.rst:2554
msgid ""
"If multiple ``send`` statements are executed, then the messages of the "
"last ``send`` are added first. This means that the messages of the first "
"``send`` get processed first."
msgstr ""

#: ../scilla-in-depth.rst:2558
msgid ""
"If a ``send`` statement is given a list with multiple messages in it, "
"then the head of the list is added to the queue before the messages in "
"the tail of the list are added. This means that the last message in the "
"list (the one that that was added to the list first) gets processed "
"first."
msgstr ""

#: ../scilla-in-depth.rst:2564
msgid ""
"Any run-time failure during the execution of a transaction causes the "
"entire transaction to be aborted, with no further statements being "
"executed, no further messages being processed, all state changes being "
"rolled back, and all transferred funds returned to their respective "
"senders. However, gas is still charged for the transcaction up until the "
"point of the failure."
msgstr ""

#: ../scilla-in-depth.rst:2571
msgid ""
"The total number of messages that can be sent in a single transaction is "
"currently set at 10. The number is subject to revision in the future."
msgstr ""

#: ../scilla-in-depth.rst:2575
msgid ""
"Contracts of different Scilla versions may invoke transitions on each "
"other. The semantics of message passing between contracts is guaranteed "
"to be backward compatible between major versions."
msgstr ""

#: ../scilla-in-depth.rst:2581
msgid "Accounting"
msgstr ""

#: ../scilla-in-depth.rst:2583
msgid ""
"For the transfer of native ZIL funds, Scilla follows an `acceptance "
"semantics`. For a transfer to take place the funds must explicitly be "
"accepted by the recipient by executing an ``accept`` statement - it is "
"not sufficient that the sender executes a ``send`` statement."
msgstr ""

#: ../scilla-in-depth.rst:2588
msgid ""
"When a contract executes an ``accept`` statement the ``_amount`` of the "
"incoming message is added to the contract's ``_balance`` field. "
"Simultaneously, the ``_amount`` is deducted from the sender's balance "
"(the ``_balance`` field if the sender is a contract, or the user account "
"balance if the sender is a user)."
msgstr ""

#: ../scilla-in-depth.rst:2594
msgid ""
"Conversely, when a contract executes a ``send`` statement the ``_amount``"
" values of the outgoing messages are `not` deducted from the ``_balance``"
" field, because the outgoing funds have not yet been accepted by the "
"recipients."
msgstr ""

#: ../scilla-in-depth.rst:2601
msgid ""
"A user account (i.e., an address that does not hold a contract) "
"implicitly accepts all incoming funds, but does not do so until the "
"message carrying the funds is processed."
msgstr ""

#: ../scilla-in-depth.rst:2605
msgid ""
"Using an acceptance semantics for transfers means that it is possible for"
" a transition to send out more funds than its contract's current "
"``_balance``. Care must be taken to only do so either if one or more of "
"the recipients do not accept the funds, or if one of multiple outgoing "
"messages causes a series of chain calls which results in the current "
"contract receiving (and accepting) additional funds to cover the "
"outgoings of the yet-to-be-processed messages."
msgstr ""

#: ../scilla-in-depth.rst:2613
msgid ""
"If at any point during a transaction a recipient accepts more funds than "
"are available in the sender's balance, then a run-time error occurs, and "
"the entire transaction is aborted. In other words, no account balance may"
" drop below 0 at any point during a transaction."
msgstr ""

