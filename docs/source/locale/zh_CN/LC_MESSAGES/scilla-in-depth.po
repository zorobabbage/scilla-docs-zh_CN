# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Zilliqa Research
# This file is distributed under the same license as the scilla中文文档 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: scilla中文文档 \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-21 15:18+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../scilla-in-depth.rst:2
msgid "Scilla in Depth"
msgstr "Scilla深度解析"

#: ../scilla-in-depth.rst:5
msgid "Structure of a Scilla Contract"
msgstr "Scilla 合约结构"

#: ../scilla-in-depth.rst:8
msgid ""
"The general structure of a Scilla contract is given in the code fragment "
"below:"
msgstr "Scilla 合约的一般结构在下面的代码片段中给出："

#: ../scilla-in-depth.rst:10
msgid ""
"The contract starts with the declaration of ``scilla_version``, which "
"indicates which major Scilla version the contract uses."
msgstr "合约以 ``scilla_version`` 的声明开始，它指明合约使用的 Scilla 主版本号。"

#: ../scilla-in-depth.rst:13
msgid ""
"Then follows the declaration of a ``library`` that contains purely "
"mathematical functions, e.g., a function to compute the Boolean ``AND`` "
"of two bits, or a function computing the factorial of a given natural "
"number."
msgstr "然后是一个包含纯数学函数的 ``library`` 声明，例如，一个计算两位布尔 ``AND`` 的函数，或一个计算给定自然数阶乘的函数。"

#: ../scilla-in-depth.rst:18
msgid ""
"Then follows the actual contract definition declared using the keyword "
"``contract``."
msgstr "然后是遵循使用关键字 ``contract`` 声明的实际合约定义。"

#: ../scilla-in-depth.rst:21
msgid "Within a contract, there are then four distinct parts:"
msgstr "在合约中，有四个不同的部分："

#: ../scilla-in-depth.rst:23
msgid "The first part declares the immutable parameters of the contract."
msgstr "第一部分声明了合约的不可变参数。"

#: ../scilla-in-depth.rst:24
msgid ""
"The second part describes the contract's constraint, which must be valid "
"when the contract is deployed."
msgstr "第二部分描述了合约的约束，约束指明在部署合约时必须是有效的。"

#: ../scilla-in-depth.rst:26
msgid "The third part declares the mutable fields."
msgstr "第三部分声明了可变字段。"

#: ../scilla-in-depth.rst:27
msgid "The fourth part contains all ``transition`` and ``procedure`` definitions."
msgstr "第四部分包含所有 ``transition`` 和 ``procedure`` 定义。"

#: ../scilla-in-depth.rst:102
msgid "Immutable Contract Parameters"
msgstr "不可变合约参数"

#: ../scilla-in-depth.rst:104
msgid ""
"`Immutable parameters` are the contract's initial parameters whose values"
" are defined when the contract is deployed, and cannot be modified "
"afterwards."
msgstr "不可变参数是合约的初始参数，其值在合约部署时定义，之后无法修改。"

#: ../scilla-in-depth.rst:108
msgid "Immutable parameters are declared using the following syntax:"
msgstr "不可变参数使用以下语法声明："

#: ../scilla-in-depth.rst:116
msgid ""
"Each declaration consists of a parameter name (an identifier) and "
"followed by its type, separated by ``:``. Multiple parameter declarations"
" are separated by ``,``. The initialization values for parameters are to "
"be specified when the contract is deployed."
msgstr "每个声明都包含一个参数名称（一个标识符），后跟它的类型，用 ``:`` 分隔。 多个参数声明由 ``,`` 分隔。 参数的初始化值将在部署合约时指定。"

#: ../scilla-in-depth.rst:123
msgid ""
"In addition to the explicitly declared immutable parameters, a Scilla "
"contract has the following implicitly declared immutable contract "
"parameters"
msgstr "除了显式声明的不可变参数外，Scilla 合约还具有以下隐式声明的不可变合约参数"

#: ../scilla-in-depth.rst:126
msgid ""
"1. ``_this_address`` of type ``ByStr20``, which is initialised to the "
"address of the contract when the contract is deployed."
msgstr "1. ``ByStr20`` 类型的 ``_this_address`` ，在合约部署时初始化为合约地址。"

#: ../scilla-in-depth.rst:129
msgid ""
"2. ``_creation_block`` of type ``BNum``, which is initialized to the "
"block number at which the contract is / was deployed."
msgstr "2. ``BNum`` 类型的 ``_creation_block`` ，不管在过去还是现在，它都被初始化为合约部署时的区块号。"

#: ../scilla-in-depth.rst:132
msgid ""
"These parameters can be freely read within the implementation without "
"having to dereference it using ``<-`` and cannot be modified with ``:=``."
msgstr "这些参数可以在实现中自由读取，而不必使用  ``<-``  来取消它的引用调用，并且不能使用 ``:=`` 修改。"

#: ../scilla-in-depth.rst:136
msgid "Contract Constraints"
msgstr "合约约束"

#: ../scilla-in-depth.rst:138
msgid ""
"A `contract constraint` is a requirement placed on the contract's "
"immutable parameters. A contract constraint provides a way of "
"establishing a contract invariant as soon as the contract is deployed, "
"thus preventing the contract being deployed with nonsensical parameters."
msgstr "合约约束是对合约不可变参数的要求。 合约约束提供了一种在合约部署后立即建立合约不变性的方法，从而防止合约使用无意义的参数进行部署。"

#: ../scilla-in-depth.rst:144
msgid "A contract constraint is declared using the following syntax:"
msgstr "使用以下语法声明合约约束："

#: ../scilla-in-depth.rst:152
msgid "The constraint must be an expression of type ``Bool``."
msgstr "约束必须是 ``Bool`` 类型的表达式。"

#: ../scilla-in-depth.rst:154
msgid ""
"The constraint is checked when the contract is deployed. Contract "
"deployment only succeeds if the constraint evaluates to ``True``. If it "
"evaluates to ``False``, then the deployment fails."
msgstr "在部署合约时检查约束。 仅当约束判定为 ``True`` 时，合同部署才会成功。 如果判定结果为 ``False`` ，则部署失败。"

#: ../scilla-in-depth.rst:158
msgid ""
"Here is a simple example of using contract constraints to make sure a "
"contract with a limited period of functioning is not deployed `after` "
"that period:"
msgstr "下面是一个简单的例子，它使用合约约束来确保在该期限之后不会部署具有有限功能期限的合约："

#: ../scilla-in-depth.rst:169
msgid ""
"The snippet above uses the implicit contract parameter "
"``_creation_block`` described in :ref:`immutable-contract-parameters`."
msgstr "上面的代码片段使用了 :ref:`immutable-contract-parameters` 中描述的隐式合约参数 ``_creation_block`` 。"

#: ../scilla-in-depth.rst:174
msgid ""
"Declaring a contract constraint is optional. If no constraint is "
"declared, then the constraint is assumed to simply be ``True``."
msgstr "声明合同约束是可选的。 如果未声明约束，则假定该约束被简单地默认为 ``True`` 。"

#: ../scilla-in-depth.rst:180
msgid "Mutable Fields"
msgstr "可变字段"

#: ../scilla-in-depth.rst:182
msgid ""
"`Mutable fields` represent the mutable state (mutable variables) of the "
"contract. They are declared after the immutable parameters, with each "
"declaration prefixed with the keyword ``field``."
msgstr "可变字段代表合约的可变状态（可变变量）。 它们在不可变参数之后声明，每个声明都以关键字 ``field`` 为前缀。"

#: ../scilla-in-depth.rst:192
msgid ""
"Each expression here is an initialiser for the field in question. The "
"definitions complete the initial state of the contract, at the time of "
"creation.  As the contract executes a transition, the values of these "
"fields get modified."
msgstr "这里的每个表达式都是相关字段的初始值设定项。 这些定义在创建时完成了合约的初始状态。 当合约执行 transition 时，这些字段的值会被修改。"

#: ../scilla-in-depth.rst:199
msgid ""
"In addition to the explicitly declared mutable fields, a Scilla contract "
"has an implicitly declared mutable field ``_balance`` of type "
"``Uint128``, which is initialised to 0 when the contract is deployed. The"
" ``_balance`` field keeps the amount of funds held by the contract, "
"measured in QA (1 ZIL = 1,000,000,000,000 QA).  This field can be freely "
"read within the implementation, but can only modified by explicitly "
"transferring funds to other accounts (using ``send``), or by accepting "
"money from incoming messages (using ``accept``)."
msgstr "除了显式声明的可变字段之外，Scilla 合约还有一个隐式声明的 ``Uint128`` 类型的可变字段 ``_balance`` ，在部署合约时将其初始化为 0。 ``_balance`` 字段保存合约持有的资金量，以 QA 衡量（1 ZIL = 1,000,000,000,000 QA）。 该字段可以在实现中自由读取，但只能通过明确地将资金转移到其他帐户（使用 ``send`` ）或通过接收来自传入消息的资金（使用 ``accept`` ）来修改。"

#: ../scilla-in-depth.rst:211
msgid "Both mutable fields and immutable parameters must be of a *storable* type:"
msgstr "可变字段和不可变参数都必须是可存储类型："

#: ../scilla-in-depth.rst:214
msgid ""
"Messages, events and the special ``Unit`` type are not storable. All "
"other primitive types like integers and strings are storable."
msgstr "消息、事件和特殊 ``Unit`` 类型不可存储。 所有其他原始类型（如整数和字符串）都是可存储的。"

#: ../scilla-in-depth.rst:218
msgid "Function types are not storable."
msgstr "函数类型不可存储。"

#: ../scilla-in-depth.rst:220
msgid "Complex types involving uninstantiated type variables are not storable."
msgstr "涉及未实例化类型变量的复杂类型不可存储。"

#: ../scilla-in-depth.rst:223
msgid ""
"Maps and ADT are storable if the types of their subvalues are storable. "
"For maps this means that the key type and the value type must both be "
"storable, and for ADTs this means that the type of every constructor "
"argument must be storable."
msgstr "如果映射和 ADT 的子值类型是可存储的，则它们是可存储的。 对于映射，这意味着键类型和值类型都必须是可存储的，对于 ADT，这意味着每个构造函数参数的类型都必须是可存储的。"

#: ../scilla-in-depth.rst:230
msgid "Units"
msgstr "单位"

#: ../scilla-in-depth.rst:232
msgid ""
"The Zilliqa protocol supports three basic tokens units - ZIL, LI (10^-6 "
"ZIL) and QA (10^-12 ZIL)."
msgstr "Zilliqa 协议支持三种基本的代币单元——ZIL、LI (10^-6 ZIL) 和 QA (10^-12 ZIL)。"

#: ../scilla-in-depth.rst:234
msgid ""
"The base unit used in Scilla smart contracts is QA. Hence, when using "
"money variables, it is important to attach the trailing zeroes that are "
"needed to represent it in QAs."
msgstr "Scilla 智能合约中使用的基本单位是 QA。 因此，在使用货币变量时，重要的是需要明确表明最后有多少个0附加在 QA 中。"

#: ../scilla-in-depth.rst:249
msgid "Transitions"
msgstr "Transitions"

#: ../scilla-in-depth.rst:251
msgid ""
"`Transitions` are a way to define how the state of the contract may "
"change. The transitions of a contract define the public interface for the"
" contract, since transitions may be invoked by sending a message to the "
"contract."
msgstr "transition 是一种定义合约状态如何改变的方式。 合约的 transition 定义了合约的公共接口，因为可以通过向合约发送消息来调用 transition。"

#: ../scilla-in-depth.rst:256
msgid ""
"Transitions are defined with the keyword ``transition`` followed by the "
"parameters to be passed. The definition ends with the ``end`` keyword."
msgstr "transition 是用关键字 ``transition`` 定义的，后跟要传递的参数。 定义以 ``end`` 关键字结束。"

#: ../scilla-in-depth.rst:266 ../scilla-in-depth.rst:334
msgid ""
"where ``vname : vtype`` specifies the name and type of each parameter and"
" multiple parameters are separated by ``,``."
msgstr "其中 ``vname : vtype`` 指定每个参数的名称和类型，多个参数之间用 ``,`` 分隔。"

#: ../scilla-in-depth.rst:272
msgid ""
"In addition to the parameters that are explicitly declared in the "
"definition, each transition has the following implicit parameters:"
msgstr "除了定义中显式声明的参数外，每个 transition  都有以下隐式参数："

#: ../scilla-in-depth.rst:275
msgid ""
"``_amount : Uint128`` : Incoming amount, in QA (see section above on the "
"units), sent by the sender. To transfer the money from the sender to the "
"contract, the transition must explicitly accept the money using the "
"``accept`` instruction. The money transfer does not happen if the "
"transition does not execute an ``accept``."
msgstr "``_amount : Uint128`` : 发送方发送的传入金额，在 QA 中（请参阅上面有关单位的部分）。 要将钱从发送方转移到合约，transition 必须使用 ``accept`` 指令明确接受资金。 如果 transition 不执行 ``accept`` ，则不会发生汇款。"

#: ../scilla-in-depth.rst:282
msgid ""
"``_sender : ByStr20 with end`` : The account address that triggered this "
"transition. If the transition was called by a contract account instead of"
" a user account, then ``_sender`` is the address of the contract that "
"called this transition. In a chain call, this is the contract that sent "
"the message invoking the current transition."
msgstr "``_sender : ByStr20 with end`` : 触发此 transition 的帐户地址。 如果 transition 是由合约账户而不是用户账户调用的，则 ``_sender`` 是调用此 transition 的合约的地址。 在链式调用中，这是发送调用当前 transition 的消息的合约。"

#: ../scilla-in-depth.rst:288
msgid ""
"``_origin : ByStr20 with end`` : The account address that initiated the "
"current transaction (which can possibly be a chain call). This is always "
"a user address, since contracts can never initiate transactions."
msgstr "``_origin : ByStr20 with end`` : 发起当前交易的账户地址（可能是链式调用）。 这始终是用户地址，因为合约永远无法发起交易。"

#: ../scilla-in-depth.rst:292
msgid ""
"The type ``ByStr20 with end`` is an `address type`. Address types are "
"explained in detail in the :ref:`Addresses <Addresses>` section."
msgstr "``ByStr20 with end`` 的类型是地址类型。 地址类型在 :ref:`地址 <Addresses>` 部分有详细说明。"

#: ../scilla-in-depth.rst:297
msgid "Transition parameters must be of a *serialisable* type:"
msgstr "transition 的参数必须是可序列化的类型："

#: ../scilla-in-depth.rst:299
msgid "Messages, events and the special ``Unit`` type are not serialisable."
msgstr "消息、事件和特殊 ``Unit`` 类型不可序列化。"

#: ../scilla-in-depth.rst:302
msgid ""
"Byte strings are serialisable. Addresses are serialisable only as "
"``ByStr20`` values. All other primitive types like integers and strings "
"are serialisable."
msgstr "字节字符串是可序列化的。 地址只能作为 ``ByStr20`` 值进行序列化。 所有其他原始类型（如整数和字符串）都是可序列化的。"

#: ../scilla-in-depth.rst:306
msgid "Function types and map types are not serialisable."
msgstr "函数类型和映射类型不可序列化。"

#: ../scilla-in-depth.rst:308
msgid ""
"Complex types involving uninstantiated type variables are not "
"serialisable."
msgstr "涉及未实例化类型变量的复杂类型不可序列化。"

#: ../scilla-in-depth.rst:311
msgid ""
"ADT are serialisable if the types of their subvalues are serialisable. "
"This means that the type of every constructor argument must be "
"serialisable."
msgstr "如果 ADT 的子值的类型是可序列化的，则 ADT 是可序列化的。 这意味着每个构造函数参数的类型都必须是可序列化的。"

#: ../scilla-in-depth.rst:316
msgid "Procedures"
msgstr "Procedures"

#: ../scilla-in-depth.rst:318
msgid ""
"`Procedures` are another way to define now the state of the contract may "
"change, but in contrast to transitions, procedures are not part of the "
"public interface of the contract, and may not be invoked by sending a "
"message to the contract. The only way to invoke a procedure is to call it"
" from a transition or from another procedure."
msgstr "procedure 是另一种定义合约状态的方法，现在合约的状态可能会改变，但与 transition 相反，procedure 不是合约公共接口的一部分，并且不能通过向合约发送消息来调用。 调用 procedure 的唯一方法是从 transition 或从另一个 procedure 调用它。"

#: ../scilla-in-depth.rst:324
msgid ""
"Procedures are defined with the keyword ``procedure`` followed by the "
"parameters to be passed. The definition ends with the ``end`` keyword."
msgstr "procedure 是用关键字 ``procedure`` 定义的，后跟要传递的参数。 定义以 ``end`` 关键字结束。"

#: ../scilla-in-depth.rst:337
msgid ""
"Once a procedure is defined it is available to be invoked from "
"transitions and procedures in the rest of the contract file. It is not "
"possible to invoke a procedure from transition or procedure defined "
"earlier in the contract, nor is it possible for a procedure to call "
"itself recursively."
msgstr "一旦定义了 procedure，就可以从合约文件其余部分的 transition 和 procedure 中调用它。 但是不能从合约中之前定义的 transition 或 procedure 中调用它，procedure 也不能递归调用自身。"

#: ../scilla-in-depth.rst:343
msgid ""
"Procedures are invoked using the name of the procedure followed by the "
"actual arguments to the procedure:"
msgstr "使用 procedure 名称后跟 procedure 的实际参数来调用 procedure："

#: ../scilla-in-depth.rst:352
msgid ""
"All arguments must be supplied when the procedure is invoked. A procedure"
" does not return a result."
msgstr "调用 procedure  时必须提供所有参数。 procedure 不返回结果。"

#: ../scilla-in-depth.rst:358
msgid ""
"The implicit transition parameters ``_sender``, ``_origin`` and "
"``_amount`` are implicitly passed to all the procedures that a transition"
" calls. There is therefore no need to declare those parameters explicitly"
" when defining a procedure."
msgstr "隐式 transition  参数 ``_sender`` 、``_origin`` 和 ``_amount`` 被隐式传递给 transition  调用的所有 procedure。 因此，在定义 procedure 时无需显式声明这些参数。"

#: ../scilla-in-depth.rst:365
msgid ""
"Procedure parameters cannot be (or contain) maps. If a procedure needs to"
" access a map, it is therefore necessary to either make the procedure "
"directly access the contract field containing the map, or use a library "
"function to perform the necessary computations on the map."
msgstr "procedure 参数不能是（或包含）映射。 如果一个 procedure  需要访问一个映射，就必须让该 procedure  直接访问包含该映射的合约字段，或者使用库函数在映射上执行必要的计算。"

#: ../scilla-in-depth.rst:373
msgid "Expressions"
msgstr "表达式"

#: ../scilla-in-depth.rst:375
msgid ""
"`Expressions` handle pure operations. Scilla contains the following types"
" of expressions:"
msgstr "表达式处理纯操作。 Scilla 包含以下类型的表达式："

#: ../scilla-in-depth.rst:377
msgid ""
"``let x = f`` : Give  ``f`` the name ``x`` in the contract. The binding "
"of ``x`` to ``f`` is **global** and extends to the end of the contract. "
"The following code fragment defines a constant ``one`` whose values is "
"``1`` of type ``Int32`` throughout the contract."
msgstr "``let x = f`` ：在合约中把 ``f`` 命名为 ``x``。 ``x`` 到 ``f`` 的绑定是全局的，并延伸到合约结束。 以下代码片段定义了一个常量 ``one`` ，其值在整个合约中都是 ``Int32`` 类型的 ``1`` 。"

#: ../scilla-in-depth.rst:386
msgid ""
"``let x = f in expr`` :  Bind ``f`` to the name ``x`` within expression "
"``expr``.  The binding here is **local** to ``expr`` only. The following "
"example binds the value of ``one`` to ``1`` of type ``Int32`` and ``two``"
" to ``2`` of type ``Int32`` in the expression ``builtin add one two``, "
"which adds ``1`` to ``2`` and hence evaluates to ``3`` of type ``Int32``."
msgstr "``let x = f in expr`` ：将 ``f`` 绑定到表达式 ``expr`` 中的名称 ``x`` 。 这里的绑定对 ``expr`` 来说仅仅是 **local** 。 以下示例将 ``Int32`` 类型的 ``1`` 的值绑定到 ``one`` 以及将 ``Int32`` 类型的 ``2`` 的值绑定到 ``two`` 并使用内置表达式 ``builtin add one two`` 计算，该表达式将 ``1`` 与 ``2`` 相加，因此计算结果为 ``Int32`` 类型的 ``3``。"

#: ../scilla-in-depth.rst:399
msgid ""
"``{ <entry>_1 ; <entry>_2 ... }``: Message or event expression, where "
"each entry has the following form: ``b : x``. Here ``b`` is an identifier"
" and ``x`` a variable, whose value is bound to the identifier in the "
"message."
msgstr "``{ <entry>_1 ; <entry>_2 ... }`` ：消息或事件表达式，其中每个条目具有以下形式： ``b : x`` 。 这里 ``b`` 是一个标识符， ``x`` 是一个变量，其值绑定到消息中的标识符。"

#: ../scilla-in-depth.rst:404
msgid ""
"``fun (x : T) => expr`` : A function that takes an input ``x`` of type "
"``T`` and returns the value to which expression ``expr`` evaluates."
msgstr "``fun (x : T) => expr`` ：一个函数，它接受类型为 ``T`` 的输入 ``x`` 并返回表达式 ``expr`` 求值结果。"

#: ../scilla-in-depth.rst:407
msgid "``f x`` : Apply the function ``f`` to the parameter ``x``."
msgstr "``f x`` ：将函数 ``f`` 应用于参数 ``x`` 。"

#: ../scilla-in-depth.rst:409
msgid ""
"``tfun 'T => expr`` : A type function that takes ``'T`` as a parametric "
"type and returns the value to which expression ``expr`` evaluates. These "
"are typically used to build library functions. See the implementation of "
"fst_ for an example."
msgstr "``tfun 'T => expr`` ：一个类型函数，它将 ``'T`` 作为参数类型并返回表达式 ``expr`` 求值结果。 这些通常用于构建库函数。 有关示例，请参阅 fst_ 的实现。"

#: ../scilla-in-depth.rst:415
msgid ""
"Shadowing of type variables is not currently allowed. E.g. ``tfun 'T => "
"tfun 'T => expr`` is not a valid expression."
msgstr "当前不允许隐藏类型变量。 例如。 ``tfun 'T => tfun 'T => expr`` 不是有效的表达式。"

#: ../scilla-in-depth.rst:418
msgid ""
"``@x T``: Apply the type function ``x`` to the type ``T``. This "
"specialises the type function ``x`` by instantiating the first type "
"variable of ``x`` to ``T``. Type applications are typically used when a "
"library function is about to be applied. See the example application of "
"fst_ for an example."
msgstr "``@x T`` ：将类型函数 ``x`` 应用于类型 ``T`` 。这通过将 ``x`` 的第一个类型变量实例化为 ``T`` 来专门化类型函数 ``x`` 。类型应用程序通常在即将应用库函数时使用。 有关示例，请参阅 fst_ 的示例应用程序。"

#: ../scilla-in-depth.rst:424
msgid "``builtin f x``: Apply the built-in function ``f`` on ``x``."
msgstr "``builtin f x`` ：在 ``x`` 上应用内置函数 ``f`` 。"

#: ../scilla-in-depth.rst:426
msgid ""
"``match`` expression: Matches a bound variable with patterns and "
"evaluates the expression in that clause. The ``match`` expression is "
"similar to the ``match`` expression in OCaml. The pattern to be matched "
"can be an ADT constructor (see ADTs_) with subpatterns, a variable, or a "
"wildcard ``_``. An ADT constructor pattern matches values constructed "
"with the same constructor if the subpatterns match the corresponding "
"subvalues. A variable matches anything, and binds the variable to the "
"value it matches in the expression of that clause. A wildcard matches "
"anything, but the value is then ignored."
msgstr "``match`` 表达式：将绑定变量与模式匹配并判断该子句中的表达式。  ``match`` 表达式类似于 OCaml 中的 ``match`` 表达式。 要匹配的模式可以是带有子模式、变量或通配符 ``_`` 的 ADT 构造函数（请参阅 ADTs_ ）。 如果子模式匹配相应的子值，则 ADT 构造函数模式匹配使用相同构造函数构造的值。 变量匹配任何内容，并将变量绑定到它在该子句的表达式中匹配的值。 通配符匹配任何内容，但随后会忽略该值。"

#: ../scilla-in-depth.rst:449
msgid ""
"A pattern-match must be exhaustive, i.e., every legal (type-safe) value "
"of ``x`` must be matched by a pattern. Additionally, every pattern must "
"be reachable, i.e., for each pattern there must be a legal (type-safe) "
"value of ``x`` that matches that pattern, and which does not match any "
"pattern preceding it."
msgstr "模式匹配必须是详尽的，即 ``x`` 的每个合法（类型安全）值都必须与模式匹配。 此外，每个模式都必须是可达的，即对于每个模式，必须有一个合法（类型安全）的 ``x`` 值与该模式匹配，并且不匹配它之前的任何模式。"

#: ../scilla-in-depth.rst:456
msgid "Statements"
msgstr "语句"

#: ../scilla-in-depth.rst:458
msgid ""
"Statements in Scilla are operations with effect, and hence not purely "
"mathematical. Scilla contains the following types of statements:"
msgstr "Scilla 中的语句是有效的运算，因此不是纯粹的数学运算。 Scilla 包含以下类型的语句："

#: ../scilla-in-depth.rst:461
msgid ""
"``x <- f`` : Fetch the value of the contract field ``f``, and store it "
"into the local variable ``x``."
msgstr "``x <- f`` ：获取合约字段 ``f`` 的值，并将其存储到局部变量 ``x`` 中。"

#: ../scilla-in-depth.rst:464
msgid ""
"``f := x`` : Update the mutable contract field ``f`` with the value of "
"``x``. ``x`` may be a local variable, or another contract field."
msgstr "``f := x`` ：用 ``x`` 的值更新可变合约字段 ``f`` 。 ``x`` 可能是一个局部变量，或另一个合约字段。"

#: ../scilla-in-depth.rst:467
msgid ""
"``x <- & BLOCKNUMBER`` : Fetch the value of the blockchain state variable"
" ``BLOCKNUMBER``, and store it into the local variable ``x``."
msgstr "``x <- & BLOCKNUMBER`` ：获取区块链状态变量 ``BLOCKNUMBER`` 的值，并将其存储到局部变量 ``x`` 中。"

#: ../scilla-in-depth.rst:471
msgid ""
"``x <- & c.f`` : Remote fetch. Fetch the value of the contract field "
"``f`` at address ``c``, and store it into the local variable ``x``. Note "
"that the type of ``c`` must be an address type containing the field "
"``f``. See the secion on :ref:`Addresses <Addresses>` for details on "
"address types."
msgstr "``x <- & c.f`` ：远程获取。 获取地址 ``c`` 处的合约字段 ``f`` 的值，并将其存储到局部变量 ``x`` 中。 请注意， ``c`` 的类型必须是包含字段 ``f`` 的地址类型。 有关地址类型的详细信息，请参阅 :ref:`地址 <Addresses>` 部分。"

#: ../scilla-in-depth.rst:477
msgid ""
"``v = e`` : Evaluate the expression ``e``, and assign the value to the "
"local variable ``v``."
msgstr "``v = e`` ：计算表达式 ``e`` ，并将值赋给局部变量 ``v`` 。"

#: ../scilla-in-depth.rst:480
msgid ""
"``p x y z`` : Invoke the procedure ``p`` with the arguments ``x``, ``y`` "
"and ``z``. The number of arguments supplied must correspond to the number"
" of arguments the procedure takes."
msgstr "``p x y z`` ：使用参数 ``x``、``y``  和 ``z`` 调用 procedure ``p``。 提供的参数数量必须与 procedure 采用的参数数量相对应。"

#: ../scilla-in-depth.rst:484
msgid ""
"``forall ls p`` : Invoke procedure ``p`` for each element in the list "
"``ls``. ``p`` should be defined to take exactly one argument whose type "
"is equal to an element of the list ``ls``."
msgstr "``forall ls p`` ：为列表 ``ls`` 中的每个元素调用 procedure ``p``。 ``p`` 应该被定义为只接受一个类型等于列表 ``ls`` 元素的参数。"

#: ../scilla-in-depth.rst:488
msgid "``match`` : Pattern-matching at statement level:"
msgstr "``match`` ：语句级别的模式匹配："

#: ../scilla-in-depth.rst:507
msgid ""
"``accept`` : Accept the QA of the message that invoked the transition. "
"The amount is automatically added to the ``_balance`` field of the "
"contract. If a message contains QA, but the invoked transition does not "
"accept the money, the money is transferred back to the sender of the "
"message. Not accepting the incoming amount (when it is non-zero) is not "
"an error."
msgstr "``accept`` ：接受调用 transition 的消息的 QA。 该金额会自动添加到合约的 ``_balance`` 字段中。 如果消息包含 QA，但调用的 transition 不接受这笔钱，则将钱转回给消息的发送者。 不接受传入金额（当它非零时）不是错误。"

#: ../scilla-in-depth.rst:514
msgid ""
"``send`` and ``event`` : Communication with the blockchain. See the next "
"section for details."
msgstr "``send`` 和 ``event``：与区块链的通信。 有关详细信息，请参阅下一节。"

#: ../scilla-in-depth.rst:517
msgid ""
"In-place map operations : Operations on contract fields of type ``Map``. "
"See the Maps_ section for details."
msgstr "原位映射操作：对 ``Map`` 类型的合约字段的操作。 有关详细信息，请参阅 Maps_ 部分。"

#: ../scilla-in-depth.rst:520
msgid "A sequence of statements must be separated by semicolons ``;``:"
msgstr "语句序列必须用分号分隔 ``;``："

#: ../scilla-in-depth.rst:531
msgid ""
"Notice that the final statement does not have a trailing ``;``, since "
"``;`` is used to separate statements rather than terminate them."
msgstr "请注意，最后的语句没有尾随 ``;``，因为 ``;`` 用于分隔语句而不是终止它们。"

#: ../scilla-in-depth.rst:536
msgid "Communication"
msgstr "通信"

#: ../scilla-in-depth.rst:538
msgid ""
"A contract can communicate with other contract and user accounts through "
"the ``send`` instruction:"
msgstr "一个合约可以通过 ``send`` 指令与其他合约和用户账户进行通信："

#: ../scilla-in-depth.rst:541
msgid "``send msgs`` : Send a list of messages ``msgs``."
msgstr "``send msgs``：发送 ``msgs`` 消息列表。"

#: ../scilla-in-depth.rst:543
msgid ""
"The following code snippet defines a ``msg`` with four entries ``_tag``, "
"``_recipient``, ``_amount`` and ``param``."
msgstr "以下代码片段定义了一条 ``msg``，其中包含四个条目 ``_tag``、``_recipient``、``_amount`` 和 ``param``。"

#: ../scilla-in-depth.rst:551
msgid ""
"A message passed to ``send`` must contain the mandatory fields ``_tag``, "
"``_recipient`` and ``_amount``."
msgstr "传递给 ``send`` 的消息必须包含必填字段 ``_tag``、``_recipient`` 和 ``_amount``。"

#: ../scilla-in-depth.rst:554
msgid ""
"The ``_recipient`` field (of type ``ByStr20``) is the blockchain address "
"that the message is to be sent to, and the ``_amount`` field (of type "
"``Uint128``) is the number of QA to be transferred to that account."
msgstr "``_recipient`` 字段（``ByStr20`` 类型）是消息要发送到的区块链地址，``_amount`` 字段（``Uint128`` 类型）是要转移到该帐户的 QA 数量。"

#: ../scilla-in-depth.rst:559
msgid ""
"The ``_tag`` field (of type ``String``) is only used when the value of "
"the ``_recipient`` field is the address of a contract. In this case, the "
"value of the ``_tag`` field is the name of the transition that is to be "
"invoked on the recipient contract. If the recipient is a user account, "
"the ``_tag`` field is ignored."
msgstr "``_tag`` 字段（``String`` 类型）仅在 ``_recipient`` 字段的值为合约地址时使用。 在这种情况下，``_tag`` 字段的值是要在接收方合约上调用的 transition 的名称。 如果收件人是用户帐户，则忽略 ``_tag`` 字段。"

#: ../scilla-in-depth.rst:567
msgid ""
"To make it possible to transfer funds from a contract to both contracts "
"and user accounts, use a standard transition name as per `ZRC-5 "
"<https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-5.md>`_, i.e. "
"``AddFunds``. Please make sure to check if a contract to which you intend"
" to send funds is implemented in adherence with ZRC-5 convention."
msgstr "为了能够将资金从合约转移到合约和用户账户，请使用 `ZRC-5 <https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-5.md>`_  中的标准 transition 名称，即 ``AddFunds``。 请务必检查您打算向其发送资金的合约是否符合 ZRC-5 公约。"

#: ../scilla-in-depth.rst:573
msgid ""
"In addition to the compulsory fields the message may contain other fields"
" (of any type), such as ``param`` above. However, if the message "
"recipient is a contract, the additional fields must have the same names "
"and types as the parameters of the transition being invoked on the "
"recipient contract."
msgstr "除了必填字段之外，消息还可以包含其他字段（任何类型），例如上面的 ``param``。 但是，如果消息接收者是合约，则附加字段的名称和类型必须与在接收者合约上调用的 transition 参数相同。"

#: ../scilla-in-depth.rst:579
msgid "Here's an example that sends multiple messages."
msgstr "这是一个发送多条消息的示例。"

#: ../scilla-in-depth.rst:594
msgid ""
"A transition may execute a ``send`` at any point during execution "
"(including during the execution of the procedures it invokes), but the "
"messages will not sent onwards until after the transition has finished. "
"More details can be found in the :ref:`Chain Calls <Chaincalls>` section."
msgstr "transition 可以在执行期间的任何时候执行 ``send``（包括在它调用的 procedure 的执行期间），但是直到 transition 完成后才会继续发送消息。 更多细节可以在 :ref:`链式调用 <Chaincalls>` 部分找到。"

#: ../scilla-in-depth.rst:600
msgid ""
"A contract can also communicate to the outside world by emitting events. "
"An event is a signal that gets stored on the blockchain for everyone to "
"see. If a user uses a client application invoke a transition on a "
"contract, the client application can listen for events that the contract "
"may emit, and alert the user."
msgstr "合约还可以通过发出事件与外界进行通信。 事件是存储在区块链上供所有人查看的信号。 如果用户使用客户端应用程序调用合约上的 transition，则客户端应用程序可以侦听合约可能发出的事件，并提醒用户。"

#: ../scilla-in-depth.rst:606
msgid ""
"``event e``: Emit a message ``e`` as an event. The following code emits "
"an event with name ``e_name``."
msgstr "``event e``：将消息 ``e`` 作为事件发出。 以下代码发出一个名为 ``e_name`` 的事件。"

#: ../scilla-in-depth.rst:614
msgid ""
"An emitted event must contain the compulsory field ``_eventname`` (of "
"type ``String``), and may contain other entries as well. The value of the"
" ``_eventname`` entry must be a string literal. All events with the same "
"name must have the same entry names and types."
msgstr "发出的事件必须包含强制字段 ``_eventname`` （``String`` 类型），并且还可以包含其他条目。 ``_eventname`` 条目的值必须是字符串文字。 所有具有相同名称的事件必须具有相同的条目名称和类型。"

#: ../scilla-in-depth.rst:621
msgid ""
"As with the sending of messages, a transition may emit events at any "
"point during execution (including during the execution of the procedures "
"it invokes), but the event will not be visible on the blockchain before "
"the transition has finished. More details can be found in the :ref:`Chain"
" Calls <Chaincalls>` section."
msgstr "与发送消息一样，transition 可以在执行期间的任何时候（包括在它调用的过程的执行期间）发出事件，但在 transition 完成之前，该事件在区块链上是不可见的。 更多细节可以在 :ref:`链式调用 <Chaincalls>` 部分找到。"

#: ../scilla-in-depth.rst:629
msgid "Run-time Errors"
msgstr "运行时错误"

#: ../scilla-in-depth.rst:631
msgid ""
"A transition may encounter a run-time error during execution, such as "
"out-of-gas errors, integer overflows, or deliberately thrown exceptions. "
"A run-time error causes the transition to terminate abruptly, and the "
"entire transaction to be aborted. However, gas is still charged up until "
"the point of the error."
msgstr "transition 在执行过程中可能会遇到运行时错误，例如 out-of-gas 错误、整数溢出或故意抛出的异常。 运行时错误会导致 transition 突然终止，并中止整个事务。 但是gas费用仍旧会被扣除，直到出现错误为止。"

#: ../scilla-in-depth.rst:637
msgid ""
"The syntax for throwing an exception is similar to that of events and "
"messages."
msgstr "抛出异常的语法类似于事件和消息的语法。"

#: ../scilla-in-depth.rst:644
msgid ""
"Unlike that for ``event`` or ``send``, The argument to ``throw`` is "
"optional and can be omitted. An empty throw will result in an error that "
"just conveys the location of where the ``throw`` happened without more "
"information."
msgstr "与 ``event`` 或 ``send`` 不同， ``throw`` 的参数是可选的，可以省略。 不带参数的抛出异常将导致错误，该错误只会展示发生 ``throw`` 的位置而没有更多信息。"

#: ../scilla-in-depth.rst:650
msgid ""
"If a run-time error occurs during the execution of a transition, then the"
" entire transaction is aborted, and any state changes in both the current"
" and other contracts are rolled back. (The state of other contracts may "
"have changed due to a chain call)."
msgstr "如果在执行 transition 期间发生运行时错误，则整个交易将被中止，并且当前合约和其他合约中的任何状态更改都将回滚。 （其他合约的状态可能因链式调用而发生变化）。"

#: ../scilla-in-depth.rst:655
msgid "In particular:"
msgstr "特别是："

#: ../scilla-in-depth.rst:657
msgid ""
"All transferred funds are returned to their respective senders, even if "
"an ``accept`` was executed before the error."
msgstr "即使在错误发生之前执行了 ``accept``，所有转移的资金都会返回给各自的发送者。"

#: ../scilla-in-depth.rst:660
msgid ""
"The message queue is cleared, so that as yet unprocessed messages will no"
" longer be sent onwards even if a ``send`` was executed before the error."
msgstr "消息队列被清除，因此即使在错误之前执行了 ``send``，也不会再继续发送尚未处理的消息。"

#: ../scilla-in-depth.rst:664
msgid ""
"The event list is cleared, so that no events are emitted even if an "
"``event`` was executed before the error."
msgstr "事件列表被清除，因此即使在错误之前执行了 ``event``，也不会发出任何事件。"

#: ../scilla-in-depth.rst:667
msgid ""
"Gas is still charged for the transaction up until the point the run-time "
"error occurs."
msgstr "在发生运行时错误之前，仍会为交易收取 Gas 费用。"

#: ../scilla-in-depth.rst:672
msgid ""
"Scilla does not have exception handlers. Throwing an exception always "
"aborts the entire transaction."
msgstr "Scilla 没有异常处理程序。 抛出异常总是会中止整个事务。"

#: ../scilla-in-depth.rst:677
msgid "Gas consumption in Scilla"
msgstr "Scilla 的 Gas 消耗量"

#: ../scilla-in-depth.rst:679
msgid ""
"Deploying contracts and executing transitions in them cost gas. The "
"detailed cost mechanism is explained `here <https://github.com/Zilliqa"
"/scilla-docs/tree/master/docs/texsources/gas-costs/gas-doc.pdf>`_."
msgstr "部署合约并在其中执行 transition 会消耗 gas。 `这里  <https://github.com/Zilliqa/scilla-docs/tree/master/docs/texsources/gas-costs/gas-doc.pdf>`_ 解释了详细的成本机制。"

#: ../scilla-in-depth.rst:683
msgid ""
"The `Nucleus Wallet <https://dev-wallet.zilliqa.com/calculate>`_ page can"
" be used to estimate gas costs for some transactions ."
msgstr "`Nucleus 钱包 <https://dev-wallet.zilliqa.com/calculate>`_ 页面可用于估算某些交易的 gas 成本。"

#: ../scilla-in-depth.rst:688
msgid "Primitive Data Types & Operations"
msgstr "原始数据类型和操作"

#: ../scilla-in-depth.rst:691
msgid "Integer Types"
msgstr "整数类型"

#: ../scilla-in-depth.rst:693
msgid ""
"Scilla defines signed and unsigned integer types of 32, 64, 128, and 256 "
"bits.  These integer types can be specified with the keywords ``IntX`` "
"and ``UintX`` where ``X`` can be 32, 64, 128, or 256. For example, the "
"type of an unsigned integer of 32 bits is ``Uint32``."
msgstr "Scilla 定义了 32、64、128 和 256 位的有符号和无符号整数类型。 这些整数类型可以用关键字 ``IntX`` 和 ``UintX`` 指定，其中 ``X`` 可以是 32、64、128 或 256。例如，32 位无符号整数的类型是 ``Uint32``。"

#: ../scilla-in-depth.rst:698
msgid "The following code snippet declares a variable of type ``Uint32``:"
msgstr "以下代码片段声明了一个 ``Uint32`` 类型的变量："

#: ../scilla-in-depth.rst:705
msgid ""
"Scilla supports the following built-in operations on integers. Each "
"operation takes two integers ``IntX`` / ``UintX`` (of the same type) as "
"arguments. Exceptions are ``pow`` whose second argument is always "
"``Uint32`` and ``isqrt`` which takes in a single ``UintX`` argument."
msgstr "Scilla 支持以下内置的整数运算。 每个操作都采用两个整数 ``IntX`` / ``UintX`` （相同类型）作为参数。 有两个除外，即 ``pow`` 的第二个参数始终是 ``Uint32`` 以及 ``isqrt`` 接受单个 ``UintX`` 参数。"

#: ../scilla-in-depth.rst:710
msgid "``builtin eq i1 i2`` : Is ``i1`` equal to ``i2``? Returns a ``Bool``."
msgstr "``builtin eq i1 i2`` ：判断 ``i1`` 是否等于 ``i2``。 返回 ``Bool``。"

#: ../scilla-in-depth.rst:711
msgid ""
"``builtin add i1 i2``: Add integer values ``i1`` and ``i2``. Returns an "
"integer of the same type."
msgstr "``builtin add i1 i2``：整数值 ``i1`` 和 ``i2`` 相加。 返回相同类型的整数。"

#: ../scilla-in-depth.rst:713
msgid ""
"``builtin sub i1 i2``: Subtract ``i2`` from ``i1``. Returns an integer of"
" the same type."
msgstr "``builtin sub i1 i2``：从 ``i1`` 中减去 ``i2``。 返回相同类型的整数。"

#: ../scilla-in-depth.rst:715
msgid ""
"``builtin mul i1 i2``: Integer product of ``i1`` and ``i2``. Returns an "
"integer of the same type."
msgstr "``builtin mul i1 i2``：``i1`` 和 ``i2`` 的整数乘积。 返回相同类型的整数。"

#: ../scilla-in-depth.rst:717
msgid ""
"``builtin div i1 i2``: Integer division of ``i1`` by ``i2``. Returns an "
"integer of the same type."
msgstr "``builtin div i1 i2``：``i1`` 除以 ``i2`` 的整数。 返回相同类型的整数。"

#: ../scilla-in-depth.rst:719
msgid ""
"``builtin rem i1 i2``: The remainder of integer division of ``i1`` by "
"``i2``. Returns an integer of the same type."
msgstr "``builtin rem i1 i2``：``i1`` 除以 ``i2`` 的整数余数。 返回相同类型的整数。"

#: ../scilla-in-depth.rst:721
msgid "``builtin lt i1 i2``: Is ``i1`` less than ``i2``? Returns a ``Bool``."
msgstr "``builtin lt i1 i2``：``i1`` 是否小于 ``i2``， 返回 ``Bool``。"

#: ../scilla-in-depth.rst:722
msgid ""
"``builtin pow i1 i2``: ``i1`` raised to the power of ``i2``. Returns an "
"integer of the same type as ``i1``."
msgstr "``builtin pow i1 i2``：``i1`` 提升到 ``i2`` 的幂运算。 返回与 ``i1`` 类型相同的整数。"

#: ../scilla-in-depth.rst:723
msgid ""
"``builtin isqrt i``: Computes the integer square root of ``i``, i.e. the "
"largest integer ``j`` such that ``j * j <= i``. Returns an integer of the"
" same type as ``i``."
msgstr "``builtin isqrt i``：计算 ``i`` 的整数平方根，即最大整数 ``j`` 使得 ``j * j <= i``。 返回与 ``i`` 类型相同的整数。"

#: ../scilla-in-depth.rst:725
msgid ""
"``builtin to_nat i1``: Convert a value of type ``Uint32`` to the "
"equivalent value of type ``Nat``."
msgstr "``builtin to_nat i1``：将 ``Uint32`` 类型的值转换为 ``Nat`` 类型的等效值。"

#: ../scilla-in-depth.rst:726
msgid ""
"``builtin to_(u)int32/64/128/256``: Convert a ``UintX`` / ``IntX`` or a "
"``String`` (that represents a decimal number) value to the result of "
"``Option UintX`` or ``Option IntX`` type. Returns ``Some res`` if the "
"conversion succeeded and ``None`` otherwise. The conversion may fail when"
msgstr "``builtin to_(u)int32/64/128/256``：将 ``UintX`` / ``IntX`` 或 ``String`` （表示十进制数）值转换为 ``Option UintX`` 或 ``Option IntX`` 类型的结果。 如果转换成功，则返回 ``Some res``，否则返回 ``None``。 转换可能会在下面这些情况下失败"

#: ../scilla-in-depth.rst:731
msgid "there is not enough bits to represent the result;"
msgstr "没有足够的位来表示结果；"

#: ../scilla-in-depth.rst:732
msgid ""
"when converting a negative integer (or a string representing a negative "
"integer) into a value of an unsigned type;"
msgstr "将负整数（或表示负整数的字符串）转换为无符号类型的值时；"

#: ../scilla-in-depth.rst:734
msgid "the input string cannot be parsed as an integer."
msgstr "输入字符串不能解析为整数。"

#: ../scilla-in-depth.rst:736
msgid ""
"Here is the list of concrete conversion builtins for better "
"discoverability: ``to_int32``, ``to_int64``, ``to_int128``, "
"``to_int256``, ``to_uint32``, ``to_uint64``, ``to_uint128``, "
"``to_uint256``."
msgstr "以下是具体转换内置函数列表：``to_int32``、``to_int64``、``to_int128``、``to_int256``、``to_uint32``、``to_uint64``、``to_uint128``、``to_uint256``。"

#: ../scilla-in-depth.rst:740
msgid ""
"Addition, subtraction, multiplication, pow, division and remainder "
"operations may raise integer overflow, underflow and division_by_zero "
"errors. This aborts the execution of the current transition and unrolls "
"all the state changes made so far."
msgstr "加法、减法、乘法、幂、除法和余数运算可能会引发整数溢出、下溢和除零错误。 这会中止当前 transition 的执行并还原迄今为止所做的所有状态更改。"

#: ../scilla-in-depth.rst:747
msgid ""
"Variables related to blockchain money, such as the ``_amount`` entry of a"
" message or the ``_balance`` field of a contract, are of type "
"``Uint128``."
msgstr "与区块链货币相关的变量，例如消息的 ``_amount`` 条目或合约的 ``_balance`` 字段，属于 ``Uint128`` 类型。"

#: ../scilla-in-depth.rst:754
msgid "Strings"
msgstr "字符串"

#: ../scilla-in-depth.rst:756
msgid ""
"``String`` literals in Scilla are expressed using a sequence of "
"characters enclosed in double quotes. Variables can be declared by "
"specifying using keyword ``String``."
msgstr "Scilla 中的 ``String`` 文字使用双引号括起来的字符序列表示。 可以通过使用关键字 ``String`` 指定来声明变量。"

#: ../scilla-in-depth.rst:760
msgid "The following code snippet declares a variable of type ``String``:"
msgstr "以下代码片段声明了一个 ``String`` 类型的变量："

#: ../scilla-in-depth.rst:766
msgid "Scilla supports the following built-in operations on strings:"
msgstr "Scilla 支持以下对字符串的内置操作："

#: ../scilla-in-depth.rst:768
msgid ""
"``builtin eq s1 s2`` : Is ``s1`` equal to ``s2``? Returns a ``Bool``. "
"``s1`` and ``s2`` must be of type ``String``."
msgstr "``builtin eq s1 s2`` ： ``s1`` 是否等于 ``s2``。 返回 ``Bool``。 ``s1`` 和 ``s2`` 必须都是字符串类型。"

#: ../scilla-in-depth.rst:770
msgid ""
"``builtin concat s1 s2`` : Concatenate string ``s1`` with string ``s2``. "
"Returns a ``String``."
msgstr "``builtin concat s1 s2`` ：将字符串 ``s1`` 与字符串 ``s2`` 连接起来。 返回一个 ``String``。"

#: ../scilla-in-depth.rst:772
msgid ""
"``builtin substr s idx len`` : Extract the substring of ``s`` of length "
"``len`` starting from position ``idx``. ``idx`` and ``len`` must be of "
"type ``Uint32``. Character indices in strings start from ``0``.  Returns "
"a ``String`` or fails with a runtime error if the combination of the "
"input parameters results in an invalid substring."
msgstr "``builtin substr s idx len`` ：从位置 ``idx`` 开始提取长度为 ``len`` 的 ``s`` 子串。 ``idx`` 和 len 必须是 ``Uint32`` 类型。 字符串中的字符索引从 ``0`` 开始。如果输入参数的组合导致无效的子字符串，则返回 ``String`` 或失败并显示运行时错误。"

#: ../scilla-in-depth.rst:777
msgid ""
"``builtin to_string x``: Convert ``x`` to a string literal. Valid types "
"of ``x`` are ``IntX``, ``UintX``, ``ByStrX`` and ``ByStr``. Returns a "
"``String``. Byte strings are converted to textual hexadecimal "
"representation."
msgstr "``builtin to_string x``：将 ``x`` 转换为字符串文字。 ``x`` 的有效类型是 ``IntX``、``UintX``、``ByStrX`` 和 ``ByStr``。 返回一个 ``String``。 字节字符串被转换为文本十六进制表示。"

#: ../scilla-in-depth.rst:780
msgid ""
"``builtin strlen s`` : Calculate the length of ``s`` (of type "
"``String``). Returns a ``Uint32``."
msgstr "``builtin strlen s`` ：计算 ``s`` （``String`` 类型）的长度。 返回一个 ``Uint32``。"

#: ../scilla-in-depth.rst:782
msgid "``builtin strrev s`` : Returns the reverse of the string ``s``."
msgstr "``builtin strrev s`` ：返回字符串 ``s`` 的反转。"

#: ../scilla-in-depth.rst:783
msgid ""
"``builtin to_ascii h`` : Reinterprets a byte string (``ByStr`` or "
"``ByStrX``) as a printable ASCII string and returns an equivalent "
"``String`` value. If the byte string contains any non-printable "
"characters, a runtime error is raised."
msgstr "``builtin to_ascii h`` ：将字节字符串（``ByStr`` 或 ``ByStrX``）重新解释为可打印的 ASCII 字符串并返回等效的 ``String`` 值。 如果字节字符串包含任何不可打印的字符，则会引发运行时错误。"

#: ../scilla-in-depth.rst:788
msgid "Byte strings"
msgstr "字节字符串"

#: ../scilla-in-depth.rst:790
msgid ""
"Byte strings in Scilla are represented using the types ``ByStr`` and "
"``ByStrX``, where ``X`` is a number. ``ByStr`` refers to a byte string of"
" arbitrary length, whereas for any ``X``, ``ByStrX`` refers to a byte "
"string of fixed length ``X``. For instance, ``ByStr20`` is the type of "
"byte strings of length 20, ``ByStr32`` is the type of byte strings of "
"length 32, and so on."
msgstr "Scilla 中的字节字符串使用 ``ByStr`` 和 ``ByStrX`` 类型表示，其中 ``X`` 是一个数字。 ``ByStr`` 是指任意长度的字节串，从而对应于任意 ``X``，``ByStrX`` 是指固定长度 ``X`` 的字节串。例如，``ByStr20`` 是长度为20的字节串类型，``ByStr32`` 是长度为32的字节串类型 ， 等等。"

#: ../scilla-in-depth.rst:797
msgid ""
"Byte strings literals in Scilla are written using hexadecimal characters "
"prefixed with ``0x``. Note that it takes 2 hexadecimal characters to "
"specify 1 byte, so a ``ByStrX`` literal requires ``2 * X`` hexadecimal "
"characters. The following code snippet declares a variable of type "
"``ByStr32``:"
msgstr "Scilla 中的字节字符串文字是使用以 ``0x`` 为前缀的十六进制字符编写的。 请注意，指定 1 个字节需要 2 个十六进制字符，因此 ``ByStrX`` 文字需要 ``2 * X`` 个十六进制字符。 以下代码片段声明了一个 ``ByStr32`` 类型的变量："

#: ../scilla-in-depth.rst:807
msgid ""
"Scilla supports the following built-in operations for computing on and "
"converting between byte string types:"
msgstr "Scilla 支持以下用于计算和转换字节字符串类型的内置操作："

#: ../scilla-in-depth.rst:810
msgid ""
"``builtin to_bystr h`` : Convert a value ``h`` of type ``ByStrX`` (for "
"some known ``X``) to one of arbitrary length of type ``ByStr``."
msgstr "``builtin to_bystr h`` ：将 ``ByStrX`` 类型的值 ``h`` （对于某些已知的 ``X``）转换为 ``ByStr`` 类型的任意长度之一。"

#: ../scilla-in-depth.rst:813
msgid ""
"``builtin to_bystrX h`` : (note that ``X`` is a numerical paratemeter "
"here and not a part of the builtin name, see the examples below)"
msgstr "``builtin to_bystrX h`` :（请注意，这里的 ``X`` 是数字参数，而不是内置名称的一部分，请参见下面的示例）"

#: ../scilla-in-depth.rst:816
msgid ""
"if the argument ``h`` is of type ``ByStr``: Convert an arbitrary size "
"byte string value ``h`` (of type ``ByStr``) to a fixed sized byte string "
"of type ``ByStrX``, with length ``X``. The result is of type ``Option "
"ByStrX`` in this case: the builtin returns ``Some res`` if the length of "
"the argument is equal to ``X`` and ``None`` otherwise. E.g. ``builtin "
"to_bystr42 bs`` returns ``Some bs'`` if the length of ``bs`` is 42."
msgstr "如果参数 ``h`` 的类型为 ``ByStr``：将任意大小的字节字符串值 ``h`` （类型为 ``ByStr``）转换为固定大小的 ``ByStrX`` 类型的字节字符串，长度为 ``X``。在这种情况下，结果为 ``Option ByStrX`` 类型：如果参数的长度等于 ``X``，内置函数返回 ``Some res`` ，否则为 ``None`` 。 例如，如果 ``bs`` 的长度为 42，则 ``builtin to_bystr42 bs`` 返回 ``Some bs'``。"

#: ../scilla-in-depth.rst:822
msgid ""
"if the argument ``h`` is of type ``Uint(32/64/128/256)``: Convert "
"unsigned integers to their big endian byte representation, returning a "
"``ByStr(4/8/16/32)`` value (notice it's not an optional type in this "
"case). For instance, ``builtin to_bystr4 x`` (this only typechecks if "
"``x`` has type ``Uint32``) or ``builtin to_bystr16 x`` (this only "
"typechecks if ``x`` is of type ``Uint128``)."
msgstr "如果参数 ``h`` 是 ``Uint(32/64/128/256)`` 类型：将无符号整数转换为它们的大端字节表示，返回一个 ``ByStr(4/8/16/32)`` 值（注意在这个情况下它不是一个可选类型）。 例如，``builtin to_bystr4 x`` （仅在 ``x`` 的类型为 ``Uint32`` 时进行类型检查）或 ``builtin to_bystr16 x`` （仅在 ``x`` 的类型为 ``Uint128`` 时进行类型检查）。"

#: ../scilla-in-depth.rst:829
msgid ""
"``builtin to_uint(32/64/128/256) h`` : Convert a fixed sized byte string "
"value ``h`` to an equivalent value of type ``Uint(32/64/128/256)``. ``h``"
" must be of type ``ByStrX`` for some known ``X`` less than or equal to "
"(4/8/16/32). A big-endian representation is assumed."
msgstr "``builtin to_uint(32/64/128/256) h`` ：将固定大小的字节字符串值 ``h`` 转换为 ``Uint(32/64/128/256)`` 类型的等效值。 对于一些小于或等于 (4/8/16/32) 的已知 ``X``，``h`` 必须是 ``ByStrX`` 类型。 假设采用大端表示。"

#: ../scilla-in-depth.rst:833
msgid "``builtin concat h1 h2``: Concatenate byte strings ``h1`` and ``h2``."
msgstr "``builtin concat h1 h2``：连接字节字符串 ``h1`` 和 ``h2``。"

#: ../scilla-in-depth.rst:835
msgid ""
"If ``h1`` has type ``ByStrX`` and ``h2`` has type ``ByStrY``, then the "
"result will have type ``ByStr(X+Y)``."
msgstr "如果 ``h1`` 的类型为 ``ByStrX`` 而 ``h2`` 的类型为 ``ByStrY``，则结果的类型为 ``ByStr(X+Y)``。"

#: ../scilla-in-depth.rst:837
msgid ""
"If the arguments are of type ``ByStr``, the result is also of type "
"``ByStr``."
msgstr "如果参数是 ``ByStr`` 类型，则结果也是 ``ByStr`` 类型。"

#: ../scilla-in-depth.rst:839
msgid ""
"``builtin strlen h``: The length of byte string (``ByStr``) ``h``. "
"Returns ``Uint32``."
msgstr "``builtin strlen h``：字节串 (``ByStr``) ``h`` 的长度。 返回 ``Uint32``。"

#: ../scilla-in-depth.rst:841
msgid "``eq a1 a2``: Is ``a1`` equal to ``a2``? Returns a ``Bool``."
msgstr "``eq a1 a2``: a1 是否等于 a2 ， 返回一个 ``Bool``。"

#: ../scilla-in-depth.rst:846
msgid "Addresses"
msgstr "地址"

#: ../scilla-in-depth.rst:848
msgid ""
"Addresses on the Zilliqa network are strings of 20 bytes, and raw "
"addresses are therefore represented by values of type ``ByStr20``."
msgstr "Zilliqa 网络上的地址是 20 字节的字符串，因此原始地址由 ``ByStr20`` 类型的值表示。"

#: ../scilla-in-depth.rst:851
msgid ""
"Additionally, Scilla supports structured address types, i.e., types that "
"are equivalent to ``ByStr20``, but which, when interpreted as an address "
"on the network, provide additional information about the contents of that"
" address. Address types are written using the form ``ByStr20 with "
"<address contents> end``, where ``<address contents>`` refers to what the"
" address contains."
msgstr "此外，Scilla 支持结构化地址类型，即等价于 ``ByStr20`` 的类型，但当被解释为网络上的地址时，会提供有关该地址内容的附加信息。 地址类型使用形式为 ``ByStr20 with <address contents> end``，其中 ``<address contents>`` 指地址包含的内容。"

#: ../scilla-in-depth.rst:858
msgid "The hierarchy of address types is as follows:"
msgstr "地址类型的层次结构如下："

#: ../scilla-in-depth.rst:860
msgid ""
"``ByStr20``: A raw byte string of length 20. The type does not provide "
"any guarantee as to what is located at the address. (Generally, "
"``ByStr20`` is not regarded as an address type, because it can refer to "
"any byte string of length 20, whether it is meant to represent an address"
" or not.)"
msgstr "``ByStr20``：长度为 20 的原始字节字符串。该类型不提供任何关于地址处的内容的保证。 （通常，``ByStr20`` 不被视为地址类型，因为它可以引用任何长度为 20 的字节串，无论它是否表示地址。）"

#: ../scilla-in-depth.rst:866
msgid ""
"``ByStr20 with end``: A ``ByStr20`` which, when interpreted as a network "
"address, refers to an address that is in use. An address is in use if it "
"either contains a contract, or if the balance or the *nonce* of the "
"address is greater than 0. (The balance of an address is the number of Qa"
" held by the address account. The nonce of an address is the number of "
"transactions that have been initiated from that address)."
msgstr "``ByStr20 with end``：一个 ``ByStr20``，当解释为网络地址时，指的是一个正在使用的地址。 如果地址包含合约，或者地址的余额或随机数大于 0，则该地址正在使用中。（地址余额是地址帐户持有的 Qa 数量。地址的随机数是从该地址发起的交易数量）。"

#: ../scilla-in-depth.rst:874
msgid ""
"``ByStr20 with contract end``: A ``ByStr20`` which, when interpreted as a"
" network address, refers to the address of a contract."
msgstr "``ByStr20 with contract end``：一个 ``ByStr20``，当解释为网络地址时，指的是合约的地址。"

#: ../scilla-in-depth.rst:877
msgid ""
"``ByStr20 with contract field f1 : t1, field f2 : t2, ... end``: A "
"``ByStr20`` which, when interpreted as a network address, refers to the "
"address of a contract containing the mutable fields ``f1`` of type "
"``t1``, ``f2`` of type ``t2``, and so on. The contract in question may "
"define more fields than the ones specified in the type, but the fields "
"specified in the type must be defined in the contract."
msgstr "``ByStr20 with contract field f1 : t1, field f2 : t2, ... end``:  一个 ``ByStr20``，当解释为网络地址时，指的是包含类型为 ``t1`` 的可变字段 ``f1`` 、类型为 ``t2`` 的可变字段 ``f2``  的合约地址， 等等。 有一个问题是合约可以定义比类型中指定的更多的字段，但类型中指定的字段必须在合约中定义。"

#: ../scilla-in-depth.rst:886
msgid ""
"All addresses in use, and therefore by extension all contract addresses, "
"implicitly define a mutable field ``_balance : Uint128``. For user "
"accounts the ``_balance`` field refers to the account balance."
msgstr "所有使用中的地址，以及因此通过扩展的所有合约地址，都隐式定义了一个可变字段 ``_balance : Uint128``。 对于用户帐户，``_balance`` 字段是指帐户余额。"

#: ../scilla-in-depth.rst:893
msgid ""
"Address types specifying immutable parameters or transitions of a "
"contract are not supported."
msgstr "不支持指定不可变参数或合约 transition 的地址类型。"

#: ../scilla-in-depth.rst:897
msgid "Address subtyping"
msgstr "地址子类型"

#: ../scilla-in-depth.rst:899
msgid "The hierarchy of address types defines a subtype relation:"
msgstr "地址类型的层次结构定义了一个子类型关系："

#: ../scilla-in-depth.rst:901
msgid ""
"Any address type ``ByStr20 with ... end`` is as subtype of ``ByStr20``. "
"This means that any address type can be used in place of a ``ByStr20``, "
"e.g., for comparing equality using ``builtin eq``, or as the "
"``_recipient`` value of a message."
msgstr "任何 ``ByStr20 with ... end`` 的地址类型都是 ``ByStr20`` 的子类型。 这意味着可以使用任何地址类型代替 ``ByStr20``，例如，使用 ``builtin eq`` 比较相等性，或作为消息的 ``_recipient`` 值。"

#: ../scilla-in-depth.rst:906
msgid ""
"Any contract address type ``ByStr20 with contract ... end`` is a subtype "
"of ``ByStr20 with end``."
msgstr "任何 ``ByStr20 with contract ... end`` 的合约地址类型 都是 ``ByStr20 with end`` 的子类型。"

#: ../scilla-in-depth.rst:909
msgid ""
"Any contract address type specifying explict fields ``ByStr20 with "
"contract field f1 : t11, field f2 : t12, ... end`` is a subtype of a "
"contract address type specifying a subset of those fields ``ByStr20 with "
"contract field f1 : t21, field f2 : t22, ... end``, provided that ``t11``"
" is a subtype of ``t21``, ``t12`` is a subtype of ``t22``, and so on for "
"each field specified in both contract types."
msgstr "任何指定显式字段 ```ByStr20 with contract field f1: t11, field f2: t12, ... end`` 的合约地址类型都是指定这些字段的子集 ``ByStr20 with contract field f1: t21, field f2: t22 , ... end`` 的合约地址类型的子类型，前提是 ``t11`` 是 ``t21`` 的子类型， ``t12`` 是 ``t22`` 的子类型，两种合同类型中指定的每个字段都依此类推。"

#: ../scilla-in-depth.rst:917
msgid ""
"For ADTs with type parameters such as ``List`` or ``Option``, an ADT ``T "
"t1 t2 ...`` is a subtype of ``S s1 s2 ...`` if ``T`` is the same as "
"``S``, and ``t1`` is a subtype of ``s1``, ``t2`` is a subtype of ``s2``, "
"and so on."
msgstr "对于带有 ``List`` 或 ``Option`` 等类型参数的 ADT，如果 ``T`` 与 ``S`` 相同，并且 ``t1`` 是 ``s1`` 的子类型，``t2`` 是 ``s2`` 的子类型，那么 ``T t1 t2 ...`` 是 ``S s1 s2 ...`` 的子类型，以此类推。"

#: ../scilla-in-depth.rst:922
msgid ""
"A map with key type ``kt1`` and value type ``vt1`` is a subtype of "
"another map with key type ``kt2`` and value type ``vt2`` if ``kt1`` is a "
"subtype of ``kt2`` and ``vt1`` is a subtype of ``vt2``."
msgstr "如果 ``kt1`` 是 ``kt2`` 的子类型且 ``vt1`` 是 ``vt2`` 的子类型，则具有键类型 ``kt1`` 和值类型 ``vt1`` 的映射是具有键类型 ``kt2`` 和值类型 ``vt2`` 的另一个映射的子类型。"

#: ../scilla-in-depth.rst:927
msgid "Dynamic typecheck of addresses"
msgstr "地址的动态类型检查"

#: ../scilla-in-depth.rst:929
msgid ""
"In general, address types cannot be fully typechecked statically by the "
"Scilla checker. This can happen, e.g., because a byte string is a "
"transition parameter and thus not known statically, or because a byte "
"string refers to an address that does not currently contain a contract, "
"but which might contain a contract in the future."
msgstr "通常，Scilla 检查器不能完全静态地对地址类型进行类型检查。 例如下面的情况就可能会发生，由于字节字符串是一个 transition 参数，因此不能静态地知道它的值，或者因为字节字符串指的是当前不包含合约但将来可能包含合约的地址。"

#: ../scilla-in-depth.rst:935
msgid ""
"For this reason immutable parameters (i.e., contract parameters supplied "
"when the contract is deployed) and transition parameters of address types"
" are typechecked dynamically, when the actual byte string is known."
msgstr "出于这个原因，只有当实际字节字符串已知时，不可变参数（即部署合约时提供的合约参数）和地址类型的 transition 参数才可以进行动态类型检查。"

#: ../scilla-in-depth.rst:940
msgid ""
"For example, a contract might specify an immutable field ``init_owner`` "
"as follows:"
msgstr "例如，合约可能会指定一个如下所示的不可变字段 ``init_owner`` ："

#: ../scilla-in-depth.rst:947
msgid ""
"When the contract is deployed, the byte string supplied as ``init_owner``"
" is looked up as an address on the blockchain, and if the contents of "
"that address matches the address type (in this case that the address is "
"in use either by a user or by a contract), then deployment continues, and"
" ``init_owner`` can be treated as a ``ByStr20 with end`` throughout the "
"contract."
msgstr "当合约被部署时，作为 ``init_owner`` 提供的字节字符串被查找为区块链上的地址，如果该地址的内容与地址类型匹配（在地址被用户或合约使用的情况下），那么继续部署，并且 ``init_owner`` 可以在整个合约中被视为一个 ``ByStr20 with end``。"

#: ../scilla-in-depth.rst:954
msgid ""
"Similarly, a transition might specify a parameter ``token_contract`` as "
"follows:"
msgstr "类似地，transition 可能指定如下的参数 ``token_contract``："

#: ../scilla-in-depth.rst:965
msgid ""
"When the transition is invoked, the byte string supplied as the "
"``token_contract`` parameter is looked up as an address on the "
"blockchain, and if the contents of that address matches the address type "
"(in this case that the address contains a contract with a field "
"``balances`` of a type that is assignable to ``Map ByStr20 Uint128``), "
"then the transition parameter is initialised successfully, and "
"``token_contract`` can be treated as a ``ByStr20 with contract field "
"balances : Map ByStr20 Uint128 end`` throughout this transition "
"invocation."
msgstr "当 transition 被调用时，作为 ``token_contract`` 参数提供的字节字符串被查找为区块链上的地址，如果该地址的内容与地址类型匹配（在地址包含一个具有 ``Map ByStr20 Uint128`` 类型的字段 ``balances`` 的合约的情况下），那么 transition 参数成功初始化，并且 ``token_contract`` 可以在整个转换调用中被视为 ``ByStr20 with contract field balances : Map ByStr20 Uint128 end``。"

#: ../scilla-in-depth.rst:975
msgid ""
"In either case, if the contents of the address does not match the "
"specified type, then the dynamic typecheck is unsuccessful, causing "
"deployment (for failed immutable parameters) or transition invocation "
"(for transition parameters) to fail. A failed dynamic typecheck is "
"considered a run-time error, causing the current transaction to abort. "
"(For the purposes of dynamic typechecks of immutable fields the "
"deployment of a contract is considered a transaction)."
msgstr "在任何一种情况下，如果地址的内容与指定的类型不匹配，则动态类型检查不成功，同时会导致部署（对于失败的不可变参数）或 transition 调用（对于 transition 参数）失败。 失败的动态类型检查被视为运行时错误，同时会导致当前事务中止。 （出于对不可变字段的动态类型检查的目的，合约的部署被视为交易）。"

#: ../scilla-in-depth.rst:986
msgid ""
"It is not possible to specify a ``ByStr20`` literal and have it "
"interpreted as an address. In other words, the following code snippet "
"will result in a static type error:"
msgstr "无法指定 ``ByStr20`` 文字并将其解释为地址。 换句话说，以下代码片段将导致静态类型错误："

#: ../scilla-in-depth.rst:994
msgid ""
"The only way for a byte string to be validated against an address type is"
" to pass it as the value of an immutable field or as a transition "
"parameter, of the appropriate type."
msgstr "针对地址类型验证字节字符串的唯一方法是将其作为不可变字段的值或作为适当类型的 transition 参数传递。"

#: ../scilla-in-depth.rst:1000
msgid "Remote fetches"
msgstr "远程获取"

#: ../scilla-in-depth.rst:1002
msgid ""
"To perform a remote fetch ``x <- & c.f``, the type of ``c`` must be some "
"address type declaring the field ``f``. For instance, if ``c`` has the "
"type ``ByStr20 with contract field paused : Bool end``, then the value of"
" the field ``paused`` at address ``c`` can be fetched using the statement"
" ``x <- & c.paused``, whereas it is not possible to fetch the value of an"
" undeclared field (e.g., ``admin``) of ``c``, even if the contract at "
"address ``c`` does actually contain a field ``admin``. To be able to "
"fetch the value of the ``admin`` field, the type of ``c`` must contain "
"the ``admin`` field as well, e.g, ``ByStr20 with contract field paused : "
"Bool, field admin : ByStr20 end``"
msgstr "要执行远程获取 ``x <- & c.f``，``c`` 的类型必须是某种声明字段 ``f`` 的地址类型。 例如，如果 ``c`` 的类型为 ``ByStr20 with contract field paused : Bool end``，则可以使用语句 ``x <- & c.paused`` 获取在地址 ``c`` 处 ``paused`` 字段的值，而无法获取 ``c`` 中未声明字段的值（例如，``admin``），即使地址 ``c`` 的合约确实包含字段 ``admin``。 为了能够获取 ``admin`` 字段的值，``c`` 的类型也必须包含 ``admin`` 字段，例如，``ByStr20 with contract field paused : Bool, field admin : ByStr20 end``"

#: ../scilla-in-depth.rst:1013
msgid ""
"Remote fetches of map fields can be performed using in-place operations "
"in the same way as for locally declared map fields, i.e., ``x <- & "
"c.m[key]``, ``x <- & c.m[key1][key2]``, ``x <- & exists m[key]``, etc. As"
" with remote fetches of map fields, the remote map field must be declared"
" in the type of ``c``, e.g., ``ByStr20 with contract field m : Map "
"Uint128 (Map Uint32 Bool) end``."
msgstr "可以使用与本地声明的地图字段相同的方式使用就地操作执行映射字段的远程获取，即 ``x <- & cm[key]``，``x <- & cm[key1][key2]``，``x <- & exists m[key]``  等。与远程获取映射字段一样，远程映射字段必须以 ``c`` 类型声明，例如，``ByStr20 with contract field m : Map Uint128 (Map Uint32 Bool) end``。"

#: ../scilla-in-depth.rst:1020
msgid "Writing to a remote field is not allowed."
msgstr "不允许写入远程字段。"

#: ../scilla-in-depth.rst:1028
msgid "Crypto Built-ins"
msgstr "加密内置插件"

#: ../scilla-in-depth.rst:1030
msgid ""
"A hash in Scilla is declared using the data type ``ByStr32``. A "
"``ByStr32`` represents a hexadecimal byte string of 32 bytes (64 "
"hexadecimal characters). A ``ByStr32`` literal is prefixed with ``0x``."
msgstr "Scilla 中的散列是使用数据类型 ``ByStr32`` 声明的。 一个 ``ByStr32`` 代表一个 32 字节（64 个十六进制字符）的十六进制字节串。 ``ByStr32`` 文字以 ``0x`` 为前缀。"

#: ../scilla-in-depth.rst:1037
msgid ""
"Scilla supports the following built-in operations on hashes and other "
"cryptographic primitives, including byte sequences. In the description "
"below, ``Any`` can be of type ``IntX``, ``UintX``, ``String``, "
"``ByStr20`` or ``ByStr32``."
msgstr "Scilla 支持以下对哈希和其他加密原语（包括字节序列）的内置操作。 在下面的描述中，``Any`` 可以是 ``IntX``、``UintX``、``String``、``ByStr20`` 或 ``ByStr32`` 类型。"

#: ../scilla-in-depth.rst:1042
msgid ""
"``builtin eq h1 h2``: Is ``h1`` equal to ``h2``? Both inputs are of the "
"same type ``ByStrX`` (or both are of type ``ByStr``). Returns a ``Bool``."
msgstr "``builtin eq h1 h2``：``h1`` 是否等于 ``h2``？ 两个输入都是相同类型的 ``ByStrX`` （或者都是 ``ByStr`` 类型）。 返回一个布尔值。"

#: ../scilla-in-depth.rst:1045
msgid ""
"``builtin sha256hash x`` : Convert ``x`` of ``Any`` type to its SHA256 "
"hash. Returns a ``ByStr32``."
msgstr "``builtin sha256hash x`` ：将 ``Any`` 类型的 ``x`` 转换为其 SHA256 哈希。 返回一个 ``ByStr32``。"

#: ../scilla-in-depth.rst:1047
msgid ""
"``builtin keccak256hash x``: Convert ``x`` of ``Any`` type to its "
"Keccak256 hash. Returns a ``ByStr32``."
msgstr "``builtin keccak256hash x``：将 ``Any`` 类型的 ``x`` 转换为其 ``Keccak256`` 哈希。 返回一个 ``ByStr32``。"

#: ../scilla-in-depth.rst:1049
msgid ""
"``builtin ripemd160hash x``: Convert ``x`` of ``Any`` type to its "
"RIPEMD-160 hash. Returns a ``ByStr20``."
msgstr "``builtin ripemd160hash x``：将 ``Any`` 类型的 ``x`` 转换为其 RIPEMD-160 哈希。 返回一个 ``ByStr20``。"

#: ../scilla-in-depth.rst:1051
msgid ""
"``builtin substr h idx len`` : Extract the sub-byte-string of ``h`` of "
"length ``len`` starting from position ``idx``. ``idx`` and ``len`` must "
"be of type ``Uint32``. Character indices in byte strings start from "
"``0``.  Returns a ``ByStr`` or fails with a runtime error."
msgstr "``builtin substr h idx len`` ：从位置 ``idx`` 开始提取长度为 ``len`` 的 ``h`` 的子字节串。 ``idx`` 和 ``len`` 必须是 ``Uint32`` 类型。 字节字符串中的字符索引从 ``0`` 开始。返回 ``ByStr`` 或失败（导致运行时错误）。"

#: ../scilla-in-depth.rst:1055
msgid ""
"``builtin strrev h`` : Reverse byte string (either ``ByStr`` or "
"``ByStrX``). Returns a value of the same type as the argument."
msgstr "``builtin strrev h`` ：反向字节字符串（``ByStr`` 或 ``ByStrX``）。 返回与参数类型相同的值。"

#: ../scilla-in-depth.rst:1058
msgid ""
"``builtin schnorr_verify pubk data sig`` : Verify a signature ``sig`` of "
"type ``ByStr64`` against a byte string ``data`` of type ``ByStr`` with "
"the Schnorr public key ``pubk`` of type ``ByStr33``."
msgstr "``builtin schnorr_verify pubk data sig`` ：使用类型为 ``ByStr33`` 的 Schnorr 公钥 ``pubk`` 对类型为 ``ByStr`` 的字节字符串 ``data`` 验证类型为 ``ByStr64`` 的签名 ``sig``。"

#: ../scilla-in-depth.rst:1062
msgid ""
"``builtin schnorr_get_address pubk``: Given a public key of type "
"``ByStr33``, returns the ``ByStr20`` Zilliqa address that corresponds to "
"that public key."
msgstr "``builtin schnorr_get_address pubk``：给定一个 ``ByStr33`` 类型的公钥，返回与该公钥对应的 ``ByStr20`` Zilliqa 地址。"

#: ../scilla-in-depth.rst:1065
msgid ""
"``builtin ecdsa_verify pubk data sig`` : Verify a signature ``sig`` of "
"type ``ByStr64`` against a byte string ``data`` of type ``ByStr`` with "
"the ECDSA public key ``pubk`` of type ``ByStr33``."
msgstr "``builtin ecdsa_verify pubk data sig`` ：使用类型为 ``ByStr33`` 的 ECDSA 公钥 ``pubk`` 验证类型为 ``ByStr64`` 的签名 ``sig`` 与类型为 ``ByStr`` 的字节字符串 ``data``。"

#: ../scilla-in-depth.rst:1069
msgid ""
"``builtin ecdsa_recover_pk data sig recid`` : Recover ``data`` (of type "
"``ByStr``), having signature ``sig`` (of type ``ByStr64``) and a "
"``Uint32`` recovery integer ``recid``, whose value is restricted to be 0,"
" 1, 2 or 3, the uncompressed public key, returning a ``ByStr65`` value."
msgstr "``builtin ecdsa_recover_pk data sig recid`` ：恢复 ``data`` （``ByStr`` 类型），同时具有签名 ``sig`` （``ByStr64`` 类型）和 ``Uint32`` 类型的恢复整数 ``recid``，其值限制为 0、1、2 或 3，未压缩的公钥，返回一个 ``ByStr65`` 的值。"

#: ../scilla-in-depth.rst:1074
msgid ""
"``builtin bech32_to_bystr20 prefix addr``. The builtin takes a network "
"specific prefix (``\"zil\"`` / ``\"tzil\"``) of type ``String`` and an "
"input bech32 string (of type ``String``) and if the inputs are valid, "
"converts it to a raw byte address (`ByStr20`). The return type is "
"``Option ByStr20``. On success, ``Some addr`` is returned and on invalid "
"inputs ``None`` is returned."
msgstr "``builtin bech32_to_bystr20 prefix addr``。 内置函数采用 ``String`` 类型的网络特定前缀（``\"zil\"`` / ``\"tzil\"``）和输入 ``bech32`` 字符串（``String`` 类型），如果输入有效，则将其转换为原始字节地址 (ByStr20)。 返回类型是 ``Option ByStr20``。 成功时，返回 ``Some addr`` ，输入无效时返回 ``None``。"

#: ../scilla-in-depth.rst:1079
msgid ""
"``builtin bystr20_to_bech32 prefix addr``. The builtin takes a network "
"specific prefix (``\"zil\"`` / ``\"tzil\"``) of type ``String`` and an "
"input ``ByStr20`` address, and if the inputs are valid, converts it to a "
"bech32 address. The return type is ``Option String``. On success, ``Some "
"addr`` is returned and on invalid inputs ``None`` is returned."
msgstr "``builtin bystr20_to_bech32 prefix addr``。 内置函数采用 ``String`` 类型的网络特定前缀（``\"zil\"`` / ``\"tzil\"`` ）和输入 ``ByStr20`` 地址，如果输入有效，则将其转换为 ``bech32`` 地址。 返回类型是 ``Option String``。 成功时，返回 ``Some addr`` ，无效输入 返回 ``None`。"

#: ../scilla-in-depth.rst:1083
msgid ""
"``builtin alt_bn128_G1_add p1 p2``. The builtin takes two points ``p1``, "
"``p2`` on the ``alt_bn128`` curve and returns the sum of the points in "
"the underlying group G1. The input points and the result point are each a"
" ``Pair {Bystr32 ByStr32}``. Each scalar component ``ByStr32`` of a point"
" is a big-endian encoded number. Also see "
"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-196.md"
msgstr "``builtin alt_bn128_G1_add p1 p2``。 内置函数在 ``alt_bn128`` 曲线上取两个点 ``p1``、``p2``，并返回基础组 G1 中的点的总和。 输入点和结果点都是一个 ``Pair {Bystr32 ByStr32}``。 一个点的每个标量分量 ``ByStr32`` 都是一个大端编码的数字。 另见 https://github.com/ethereum/EIPs/blob/master/EIPS/eip-196.md"

#: ../scilla-in-depth.rst:1088
msgid ""
"``builtin alt_bn128_G1_mul p s``. The builtin takes a point ``p`` on the "
"``alt_bn128`` curve (as described previously), and a scalar ``ByStr32`` "
"value ``s`` and returns the sum of the point ``p`` taken ``s`` times. The"
" result is a point on the curve."
msgstr "``builtin alt_bn128_G1_mul p s``。 内置函数取 ``alt_bn128`` 曲线上的一个点 ``p`` （如前所述）和一个标量 ``ByStr32`` 的值 ``s`` 并返回点 ``p`` 取 ``s`` 次的总和。 结果是曲线上的一个点。"

#: ../scilla-in-depth.rst:1092
msgid ""
"``builtin alt_bn128_pairing_product pairs``. This builtin takes in a list"
" of pairs ``pairs`` of points. Each pair consists of a point in group G1 "
"(``Pair {Bystr32 ByStr32}``) as the first component and a point in group "
"G2 (``Pair {Bystr64 ByStr64}``) as the second component. Hence the "
"argument has type ``List {(Pair (Pair ByStr32 ByStr32) (Pair ByStr64 "
"ByStr64)) }``. The function applies a pairing function on each point to "
"check for equality and returns ``True`` or ``False`` depending on whether"
" the pairing check succeeds or fails. Also see "
"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-197.md"
msgstr "``builtin alt_bn128_pairing_product pairs``。 这个内置函数接受一对点的 ``pairs`` 的列表。 每对由 G1 组中的一个点（``Pair {Bystr32 ByStr32}``）作为第一个分量和 G2 组中的一个点（``Pair {Bystr64 ByStr64}``）作为第二个分量。 因此，参数的类型为 ``List {(Pair (Pair ByStr32 ByStr32) (Pair ByStr64 ByStr64)) }``。 该函数在每个点上应用一个配对函数来检查是否相等，并根据配对检查是成功还是失败返回 ``True`` 或 ``False``。 另见 https://github.com/ethereum/EIPs/blob/master/EIPS/eip-197.md"

#: ../scilla-in-depth.rst:1100
msgid "Maps"
msgstr "映射"

#: ../scilla-in-depth.rst:1103
msgid ""
"A value of type ``Map kt vt`` provides a key-value store where ``kt`` is "
"the type of keys and ``vt`` is the type of values (in some other "
"programming languages datatypes like Scilla's ``Map`` are called "
"associative arrays, symbol tables, or dictionaries). The type of map keys"
" ``kt`` may be any one of the following *primitive* types: ``String``, "
"``IntX``, ``UintX``, ``ByStrX``, ``ByStr`` or ``BNum``. The type of "
"values ``vt`` may be any type except a function type, this includes both "
"builtin and user-defined algebraic datatypes."
msgstr "``Map kt vt`` 类型的值提供了一个键值存储，其中 ``kt`` 是键的类型，``vt`` 是值的类型（在其他一些编程语言中，像 Scilla 的 ``Map`` 这样的数据类型被称为关联数组、符号表或字典）。 映射键 ``kt`` 的类型可以是以下 *基元* 类型中的任意一种：``String``、``IntX``、``UintX``、``ByStrX``、``ByStr`` 或 ``BNum``。 值 ``vt`` 的类型可以是除函数类型之外的任何类型，这包括内置和用户定义的代数数据类型。"

#: ../scilla-in-depth.rst:1111
msgid ""
"Since compound types are not supported as map key types, the way to "
"model, e.g. association of pairs of values to another value is by using "
"*nested* maps. For instance, if one wants to associate with an account "
"and a particular trusted user some money limit the trusted user is "
"allowed to spend on behalf of the account, one can use the following "
"nested map:"
msgstr "由于不支持复合类型作为映射键类型，因此建模的方式是通过使用诸如一对值与另一个值的关联的 *嵌套* 映射实现的。 例如，如果一个帐户要与一个特定的受信任用户相关联，同时允许受信任用户代表该帐户花费一定的资金限制，可以使用以下嵌套映射："

#: ../scilla-in-depth.rst:1122
msgid ""
"The first and the second key are of type ``ByStr20`` and represent "
"accounts and the trusted users correspondingly. We represent the money "
"limits with the ``Uint128`` type."
msgstr "第一个和第二个键是 ``ByStr20`` 类型的，分别代表账户和可信用户。 我们用 ``Uint128`` 类型表示资金限制。"

#: ../scilla-in-depth.rst:1126
msgid "Scilla supports a number of operations on map, which can be categorized as"
msgstr "Scilla 支持多种映射操作，可以归纳为"

#: ../scilla-in-depth.rst:1128
msgid ""
"*in-place* operations which modify *field* maps without making any "
"copies, hence they belong to the imperative fragment of Scilla. These "
"operations are efficient and recommended to use in almost all of the "
"cases;"
msgstr "*就地* 操作修改字段映射而不制作任何副本，因此它们属于 Scilla 的命令式片段。 这些操作是非常有效的，建议在所有情况下都使用；"

#: ../scilla-in-depth.rst:1131
msgid ""
"*functional* map operations are intended to use in pure functions, e.g. "
"when designing a Scilla library, because they never modify the original "
"map they are called on. These operations may incur significant "
"performance overhead as some of them create a new (modified) copy of the "
"input map. Syntactically, the copying operations are all prefixed with "
"``builtin`` keyword (see below). Note that to call the functional "
"builtins on a field map one first needs to make a *copy* of the field map"
" using a command like so: ``map_copy <- field_map``, which results in gas"
" consumption proportional to the size of ``field_map``."
msgstr "*函数* 映射操作旨在用于纯函数，例如，在设计 Scilla 库时，因为它们从不修改调用它们的原始映射。 这些操作可能会导致显着的性能开销，因为其中一些操作会创建输入映射的新（修改）副本。 在语法上，复制操作都以 ``builtin`` 关键字为前缀（见下文）。 请注意，要在字段映射上调用函数内置函数，首先需要使用如下命令复制字段映射：``map_copy <- field_map``，这会导致 gas 消耗与 field_map 的大小成正比。"

#: ../scilla-in-depth.rst:1143
msgid "In-place map operations"
msgstr "就地映射操作"

#: ../scilla-in-depth.rst:1145
msgid ""
"``m[k] := v``: *In-place* insert. Inserts a key ``k`` bound to a value "
"``v`` into a map ``m``. If ``m`` already contains key ``k``, the old "
"value bound to ``k`` gets replaced by ``v`` in the map. ``m`` must refer "
"to a mutable field in the current contract. Insertion into nested maps is"
" supported with the syntax ``m[k1][k2][...] := v``. If the intermediate "
"keys do not exist in the nested maps, they are freshly created along with"
" the map values they are associated with."
msgstr "``m[k] := v``: *就地* 插入。 将绑定到值 ``v`` 的键 ``k`` 插入到映射 ``m`` 中。 如果 ``m`` 已经包含键 ``k``，则绑定到 ``k`` 的旧值将被映射中的 ``v`` 替换。 ``m`` 必须引用当前合约中的可变字段。 使用语法 ``m[k1][k2][...] := v`` 支持插入嵌套映射。如果嵌套映射中不存在中间键，则将它们连同与其关联的映射值一起重新创建。"

#: ../scilla-in-depth.rst:1154
msgid ""
"``x <- m[k]``: *In-place* local fetch. Fetches the value associated with "
"the key ``k`` in the map ``m``. ``m`` must refer to a mutable field in "
"the current contract. If ``k`` has an associated value ``v`` in ``m``, "
"then the results of the fetch is ``Some v`` (see the ``Option`` type "
"below), otherwise the result is ``None``. After the fetch, the result "
"gets bound to the local variable ``x``. Fetching from nested maps is "
"supported with the syntax ``x <- m[k1][k2][...]``. If one or more of the "
"intermediate keys do not exist in the corresponding map, the result of "
"the fetch is ``None``."
msgstr "``x <- m[k]``：*就地* 本地获取。 获取与映射 ``m`` 中的键 ``k`` 关联的值。 ``m`` 必须引用当前合约中的可变字段。 如果 ``k`` 在 ``m`` 中具有关联值 ``v``，则获取的结果为 ``Some v`` （请参阅下面的 ``Option`` 类型），否则结果为 ``None``。 在获取之后，结果被绑定到局部变量 ``x``。 使用语法 ``x <- m[k1][k2][...]`` 支持从嵌套映射中获取。 如果对应的映射中不存在一个或多个中间键，则获取的结果为 ``None``。"

#: ../scilla-in-depth.rst:1164
msgid ""
"``x <- & c.m[k]``: *In-place* remote fetch. Works in the same way as the "
"local fetch operation, except that ``m`` must refer to a mutable field in"
" the contract at address ``c``."
msgstr "``x <- & c.m[k]``：*就地* 远程获取。 除了 ``m`` 必须引用地址 ``c`` 处合约中的可变字段，其他以与本地获取操作相同的方式工作。"

#: ../scilla-in-depth.rst:1168
msgid ""
"``x <- exists m[k]``: *In-place* local key existence check. ``m`` must "
"refer to a mutable field in the current contract. If ``k`` has an "
"associated value in the map ``m`` then the result (of type ``Bool``) of "
"the check is ``True``, otherwise the result is ``False``. After the "
"check, the result gets bound to the local variable ``x``. Existence "
"checks through nested maps is supported with the syntax ``x <- exists "
"m[k1][k2][...]``. If one or more of the intermediate keys do not exist in"
" the corresponding map, the result is ``False``."
msgstr "``x <- exists m[k]``：*就地* 本地密钥存在检查。 ``m`` 必须引用当前合约中的可变字段。 如果 ``k`` 在映射 ``m`` 中具有关联值，则检查的结果（``Bool`` 类型）为 ``True``，否则结果为 ``False``。 检查后，结果绑定到局部变量 ``x``。 语法 ``x <- exists m[k1][k2][...]`` 支持通过嵌套映射进行存在检查。 如果对应的映射中不存在一个或多个中间键，则结果为 ``False``。"

#: ../scilla-in-depth.rst:1178
msgid ""
"``b <- & exists c.m[k]``: *In-place* remote key existence check. Works in"
" the same way as the local key existence check, except that ``m`` must "
"refer to a mutable field in the contract at address ``c``."
msgstr "``b <- & exists c.m[k]``：*就地* 远程密钥存在检查。 除了 ``m`` 必须引用地址 ``c`` 处合约中的可变字段，其他以与本地密钥存在性检查相同的方式工作。"

#: ../scilla-in-depth.rst:1183
msgid ""
"``delete m[k]``: *In-place* remove. Removes a key ``k`` and its "
"associated value from the map ``m``. The identifier ``m`` must refer to a"
" mutable field in the current contract. Removal from nested maps is "
"supported with the syntax ``delete m[k1][k2][...]``. If one or more of "
"the intermediate keys do not exist in the corresponding map, then the "
"operation has no effect. Note that in the case of a nested removal "
"``delete m[k1][...][kn-1][kn]``, only the key-value association of ``kn``"
" is removed. The key-value bindings of ``k1`` to ``kn-1`` will remain in "
"the map."
msgstr "``delete m[k]``：*就地* 删除。 从映射 ``m`` 中删除键 ``k`` 及其关联值。 标识符 ``m`` 必须引用当前合约中的可变字段。 使用语法 ``delete m[k1][k2][...]`` 支持从嵌套映射中删除。 如果对应的映射中不存在一个或多个中间键，则该操作无效。 请注意，在嵌套删除 ``delete m[k1][...][kn-1][kn]`` 的情况下，仅删除 ``kn`` 的键值关联。 ``k1`` 到 ``kn-1`` 的键值绑定将保留在映射中。"

#: ../scilla-in-depth.rst:1196
msgid "Functional map operations"
msgstr "函数式映射操作"

#: ../scilla-in-depth.rst:1198
msgid ""
"``builtin put m k v``: Insert a key ``k`` bound to a value ``v`` into a "
"map ``m``. Returns a new map which is a copy of the ``m`` but with ``k`` "
"associated with ``v``. If ``m`` already contains key ``k``, the old value"
" bound to ``k`` gets replaced by ``v`` in the result map. The value of "
"``m`` is unchanged. The ``put`` function is typically used in library "
"functions. Note that ``put`` makes a copy of ``m`` before inserting the "
"key-value pair."
msgstr "``builtin put m k v``：将绑定到值 ``v`` 的键 ``k`` 插入到映射 ``m`` 中。 返回一个新映射，它是 ``m`` 的副本，但 ``k`` 与 ``v`` 关联。如果 ``m`` 已经包含键 ``k``，则绑定到 ``k`` 的旧值在结果映射中被 ``v`` 替换。 ``m`` 的值不变。 ``put`` 函数通常用于库函数中。 请注意， ``put`` 在插入键值对之前制作了 ``m`` 的副本。"

#: ../scilla-in-depth.rst:1206
msgid ""
"``builtin get m k``: Fetch the value associated with the key ``k`` in the"
" map ``m``. Returns an optional value (see the ``Option`` type below) -- "
"if ``k`` has an associated value ``v`` in ``m``, then the result is "
"``Some v``, otherwise the result is ``None``. The ``get`` function is "
"typically used in library functions."
msgstr "``builtin get m k``：获取映射 ``m`` 中与键 ``k`` 关联的值。 返回一个可选值（参见下面的 ``Option`` 类型）——如果 ``k`` 在 ``m`` 中有一个关联值 ``v``，那么结果是 ``Some v``，否则结果是 ``None``。 ``get`` 函数通常用于库函数中。"

#: ../scilla-in-depth.rst:1212
msgid ""
"``builtin contains m k``: Is the key ``k`` associated with a value in the"
" map ``m``?  Returns a ``Bool``. The ``contains`` function is typically "
"used in library functions."
msgstr "``builtin contains m k``：键 ``k`` 是否与映射 ``m`` 中的值相关联？ 返回一个 ``Bool`` 值。 ``contains`` 函数通常用于库函数中。"

#: ../scilla-in-depth.rst:1216
msgid ""
"``builtin remove m k``: Remove a key ``k`` and its associated value from "
"the map ``m``. Returns a new map which is a copy of ``m`` but with ``k`` "
"being unassociated with a value. The value of ``m`` is unchanged. If "
"``m`` does not contain key ``k`` the ``remove`` function simply returns a"
" copy of ``m`` with no indication that ``k`` is missing. The ``remove`` "
"function is typically used in library functions. Note that ``remove`` "
"makes a copy of ``m`` before removing the key-value pair."
msgstr "``builtin remove m k``：从映射 ``m`` 中删除键 ``k`` 及其关联值。 返回一个新映射，它是 ``m`` 的副本，但 ``k`` 与值无关。 ``m`` 的值不变。 如果 ``m`` 不包含键 ``k``，则 ``remove`` 函数仅返回 ``m`` 的副本，而不会指示缺少 ``k``。 ``remove`` 函数通常用于库函数中。 请注意，在删除键值对之前，``remove`` 会复制 ``m``。"

#: ../scilla-in-depth.rst:1224
msgid ""
"``builtin to_list m``: Convert a map ``m`` to a ``List (Pair kt vt)`` "
"where ``kt`` and ``vt`` are key and value types, respectively (see the "
"``List`` type below)."
msgstr "``builtin to_list m``：将映射 ``m`` 转换为 ``List (Pair kt vt)``，其中 ``kt`` 和 ``vt`` 分别是键和值类型（参见下面的 ``List`` 类型）。"

#: ../scilla-in-depth.rst:1228
msgid ""
"``builtin size m``: Return the number of bindings in map ``m``. The "
"result type is ``Uint32``. Calling this builtin consumes a small "
"*constant* amount of gas. But calling it directly on a *field* map is not"
" supported, meaning that getting the size of field maps while avoiding "
"expensive copying needs some more scaffolding, which you can find out "
"about in the :ref:`Field map size <field_map_size>` section."
msgstr "``builtin size m``：返回映射 ``m`` 中的绑定数。 结果类型为 ``Uint32``。 调用这个内置函数会消耗少量恒定的 gas 费用。 但是不支持直接在 *字段* 映射上调用它，这意味着在避免昂贵的复制的同时获取字段映射的大小需要更多的脚手架，你可以在 :ref:`字段映射大小 <field_map_size>` 部分找到相关信息。"

#: ../scilla-in-depth.rst:1237
msgid ""
"Builtin functions ``put`` and ``remove`` return a new map, which is a "
"possibly modified copy of the original map. This may affect performance!"
msgstr "内置函数 ``put`` 和 ``remove`` 返回一个新映射，它可能是原始映射的修改副本。 这可能会影响性能！"

#: ../scilla-in-depth.rst:1242
msgid ""
"Empty maps can be constructed using the ``Emp`` keyword, specifying the "
"key and value types as its arguments. This is the way to initialise "
"``Map`` fields to be empty. For example ``field foomap : Map Uint128 "
"String = Emp Uint128 String`` declares a ``Map`` field with keys of type "
"``Uint128`` and values of type ``String``, which is initialized to be the"
" empty map."
msgstr "可以使用 ``Emp`` 关键字构造空映射，指定键和值类型作为其参数。 这是将 ``Map`` 字段初始化为空的方法。 例如 ``field foomap : Map Uint128  String = Emp Uint128 String`` 声明一个 ``Map`` 字段，其键是 ``Uint128`` 类型，值是 ``String`` 类型，它被初始化为空映射。"

#: ../scilla-in-depth.rst:1249
msgid "Block Numbers"
msgstr "区块高度"

#: ../scilla-in-depth.rst:1251
msgid ""
"Block numbers have a dedicated type ``BNum`` in Scilla. Variables of this"
" type are specified with the keyword ``BNum`` followed by an integer "
"value (for example ``BNum 101``)."
msgstr "区块高度在 Scilla 中有一个专用类型 ``BNum``。 这种类型的变量用关键字 ``BNum`` 指定，后跟一个整数值（例如 ``BNum 101``）。"

#: ../scilla-in-depth.rst:1255
msgid "Scilla supports the following built-in operations on block numbers:"
msgstr "Scilla 支持以下对区块高度的内置操作："

#: ../scilla-in-depth.rst:1257
msgid "``eq b1 b2``: Is ``b1`` equal to ``b2``? Returns a ``Bool``."
msgstr "``eq b1 b2``: ``b1`` 是否等于 ``b2``？ 返回一个 ``Bool`` 值。"

#: ../scilla-in-depth.rst:1258
msgid "``blt b1 b2``: Is ``b1`` less than ``b2``? Returns a ``Bool``."
msgstr "``blt b1 b2``：``b1`` 是否小于 ``b2``？ 返回一个 ``Bool`` 值。"

#: ../scilla-in-depth.rst:1259
msgid ""
"``badd b1 i1``: Add ``i1`` of type ``UintX`` to ``b1`` of type ``BNum``. "
"Returns a ``BNum``."
msgstr "``badd b1 i1``：将 ``UintX`` 类型的 ``i1`` 添加到 ``BNum`` 类型的 ``b1``。 返回一个 ``BNum``。"

#: ../scilla-in-depth.rst:1261
msgid ""
"``bsub b1 b2``: Subtract ``b2`` from ``b1``, both of type ``BNum``. "
"Returns an ``Int256``."
msgstr "``bsub b1 b2``：``b1`` 减去 ``b2``，均为 ``BNum`` 类型。 返回一个 ``Int256``。"

#: ../scilla-in-depth.rst:1265
msgid "Algebraic Datatypes"
msgstr "代数数据类型"

#: ../scilla-in-depth.rst:1268
msgid ""
"An `algebraic datatype` (ADT) is a composite type used commonly in "
"functional programming. Each ADT is defined as a set of **constructors**."
" Each constructor takes a set of arguments of certain types."
msgstr "`代数数据类型` (ADT) 是函数式编程中常用的复合类型。 每个 ADT 被定义为一组 **构造函数**。 每个构造函数都接受一组特定类型的参数。"

#: ../scilla-in-depth.rst:1273
msgid ""
"Scilla is equipped with a number of built-in ADTs, which are described "
"below. Additionally, Scilla allows users to define their own ADTs."
msgstr "Scilla 配备了许多内置 ADT，如下所述。 此外，Scilla 允许用户定义他们自己的 ADT。"

#: ../scilla-in-depth.rst:1278
msgid "Boolean"
msgstr "布尔值"

#: ../scilla-in-depth.rst:1280
msgid ""
"Boolean values are specified using the type ``Bool``. The ``Bool`` ADT "
"has two constructors ``True`` and ``False``, neither of which take any "
"arguments. Thus the following code fragment constructs a value of type "
"``Bool`` by using the constructor ``True``:"
msgstr "布尔值使用 ``Bool`` 类型指定。 ``Bool`` ADT 有两个构造函数 ``True`` 和 ``False``，它们都不带任何参数。 因此，以下代码片段使用构造函数 ``True`` 构造了一个 ``Bool`` 类型的值："

#: ../scilla-in-depth.rst:1291
msgid "Option"
msgstr "可选值"

#: ../scilla-in-depth.rst:1293
msgid ""
"Optional values are specified using the type ``Option t``, where ``t`` is"
" some type. The ``Option`` ADT has two constructors:"
msgstr "可选值使用类型 ``Option t`` 指定，其中 ``t`` 是某种类型。 ``Option`` ADT 有两个构造函数："

#: ../scilla-in-depth.rst:1296
msgid ""
"``Some`` represents the presence of a value. The ``Some`` constructor "
"takes one argument (the value, of type ``t``)."
msgstr "``Some`` 代表一个值的存在。 ``Some`` 构造函数接受一个参数（``t`` 类型的值）。"

#: ../scilla-in-depth.rst:1299
msgid ""
"``None`` represents the absence of a value. The ``None`` constructor "
"takes no arguments."
msgstr "``None`` 表示没有值。 ``None`` 构造函数不接受任何参数。"

#: ../scilla-in-depth.rst:1302
msgid ""
"The following code snippet constructs two optional values. The first "
"value is an absent string value, constructed using ``None``. The second "
"value is the ``Int32`` value 10, which, because the value is present, is "
"constructed using ``Some``:"
msgstr "以下代码片段构造了两个可选值。 第一个值是一个不存在的字符串类型的值，使用 ``None`` 构造。 第二个值是 ``Int32`` 类型的值 10，因为该值存在，所以使用 ``Some`` 构造："

#: ../scilla-in-depth.rst:1316
msgid ""
"Optional values are useful for initialising fields where the value is not"
" yet known:"
msgstr "可选值对于初始化值未知的字段非常有用："

#: ../scilla-in-depth.rst:1323
msgid ""
"Optional values are also useful for functions that might not have a "
"result, such as the ``get`` function for maps:"
msgstr "可选值对于可能没有结果的函数也非常有用，例如映射的 ``get`` 函数："

#: ../scilla-in-depth.rst:1341
msgid "List"
msgstr "列表"

#: ../scilla-in-depth.rst:1343
msgid ""
"Lists of values are specified using the type ``List t``, where ``t`` is "
"some type. The ``List`` ADT has two constructors:"
msgstr "使用 ``List t`` 类型指定值列表，其中 ``t`` 是某种类型。 ``List`` ADT 有两个构造函数："

#: ../scilla-in-depth.rst:1346
msgid ""
"``Nil`` represents an empty list. The ``Nil`` constructor takes no "
"arguments."
msgstr "``Nil`` 表示一个空列表。 ``Nil`` 构造函数不接受任何参数。"

#: ../scilla-in-depth.rst:1349
msgid ""
"``Cons`` represents a non-empty list. The ``Cons`` constructor takes two "
"arguments: The first element of the list (of type ``t``), and another "
"list (of type ``List t``) representing the rest of the list."
msgstr "``Cons`` 代表一个非空列表。 ``Cons`` 构造函数接受两个参数：列表的第一个元素（``t`` 类型），以及另一个表示列表其余部分的列表（``List t`` 类型）。"

#: ../scilla-in-depth.rst:1354
msgid ""
"All elements in a list must be of the same type ``t``. In other words, "
"two values of different types cannot be added to the same list."
msgstr "列表中的所有元素都必须属于同一类型 ``t``。 换句话说，不能将两个不同类型的值添加到同一个列表中。"

#: ../scilla-in-depth.rst:1357
msgid ""
"The following example shows how to build a list of ``Int32`` values. "
"First we create an empty list using the ``Nil`` constructor. We then add "
"four other values one by one using the ``Cons`` constructor. Notice how "
"the list is constructed backwards by adding the last element, then the "
"second-to-last element, and so on, so that the final list is ``[11; 10; "
"2; 1]``:"
msgstr "以下示例显示如何构建 ``Int32`` 值列表。 首先，我们使用 ``Nil`` 构造函数创建一个空列表。 然后我们使用 ``Cons`` 构造函数一一添加其他四个值。 注意列表是如何通过添加最后一个元素，然后是倒数第二个元素，依此类推向后构造的，因此最终列表是 ``[11; 10; 2; 1]``："

#: ../scilla-in-depth.rst:1377
msgid ""
"Scilla provides three structural recursion primitives for lists, which "
"can be used to traverse all the elements of any list:"
msgstr "Scilla 为列表提供了三种结构递归原语，可用于遍历任意列表的所有元素："

#: ../scilla-in-depth.rst:1380
msgid ""
"``list_foldl: ('B -> 'A -> 'B) -> 'B -> (List 'A) -> 'B`` : Recursively "
"process the elements in a list from front to back, while keeping track of"
" an *accumulator* (which can be thought of as a running total). "
"``list_foldl`` takes three arguments, which all depend on the two type "
"variables ``'A`` and ``'B``:"
msgstr "``list_foldl: ('B -> 'A -> 'B) -> 'B -> (List 'A) -> 'B`` ：从前到后递归处理列表中的元素，同时跟踪 *累加器* （ 可以认为是一个累计）。 ``list_foldl`` 接受三个参数，它们都依赖于两个类型变量 ``'A`` 和 ``'B``："

#: ../scilla-in-depth.rst:1386
msgid ""
"The function processing the elements. This function takes two arguments. "
"The first argument is the current value of the accumulator (of type "
"``'B``). The second argument is the next list element to be processed (of"
" type ``'A``). The result of the function is the next value of the "
"accumulator (of type ``'B``)."
msgstr "处理元素的函数。 这个函数有两个参数。 第一个参数是累加器（``'B`` 类型）的当前值。 第二个参数是要处理的下一个列表元素（类型为``'A``）。 该函数的结果是累加器的下一个值（``'B`` 类型）。"

#: ../scilla-in-depth.rst:1392
msgid "The initial value of the accumulator (of type ``'B``)."
msgstr "累加器的初始值（``'B`` 类型）。"

#: ../scilla-in-depth.rst:1394
msgid "The list of elements to be processed (of type ``(List 'A)``)."
msgstr "要处理的元素列表（类型 ``(List 'A)``）。"

#: ../scilla-in-depth.rst:1396
msgid ""
"The result of applying ``list_foldl`` is the value of the accumulator (of"
" type ``'B``) when all list elements have been processed."
msgstr "应用 ``list_foldl`` 的结果是所有列表元素都被处理后的累加器（``'B`` 类型）的值。"

#: ../scilla-in-depth.rst:1400
msgid ""
"``list_foldr: ('A -> 'B -> 'B) -> 'B -> (List 'A) -> 'B`` : Similar to "
"``list_foldl``, except the list elements are processed from back to "
"front. Notice also that the processing function takes the list element "
"and the accumulator in the opposite order from the order in "
"``list_foldl``."
msgstr "``list_foldr: ('A -> 'B -> 'B) -> 'B -> (List 'A) -> 'B`` : 与 ``list_foldl`` 类似，只是列表元素是从后向前处理的。 另请注意，处理函数以与 ``list_foldl`` 中的顺序相反的顺序获取列表元素和累加器。"

#: ../scilla-in-depth.rst:1406
msgid ""
"``list_foldk: ('B -> 'A -> ('B -> 'B) -> 'B) -> 'B -> (List 'A) -> 'B`` :"
" Recursively process the elements in a list according to a *folding "
"function*, while keeping track of an *accumulator*. ``list_foldk`` is a "
"more general version of the left and right folds, which, by the way, can "
"be both implemented in terms of it. ``list_foldk`` takes three arguments,"
" which all depend on the two type variables ``'A`` and ``'B``:"
msgstr "``list_foldk: ('B -> 'A -> ('B -> 'B) -> 'B) -> 'B -> (List 'A) -> 'B`` ：根据 *折叠函数* 递归处理列表中的元素，同时跟踪 *累加器*。 ``list_foldk`` 是左右折叠的更通用版本，顺便说一下，这两个折叠都可以通过它来实现。 ``list_foldk`` 接受三个参数，它们都依赖于两个类型变量 ``'A`` 和 ``'B``："

#: ../scilla-in-depth.rst:1414
msgid ""
"The function describing the fold step. This function takes three "
"arguments. The first argument is the current value of the accumulator (of"
" type ``'B``). The second argument is the next list element to be "
"processed (of type ``'A``). The third argument represents the postponed "
"recursive call (of type ``'B -> 'B``). The result of the function is the "
"next value of the accumulator (of type ``'B``). The computation "
"*terminates* if the programmer does not invoke the postponed recursive "
"call. This is a major difference between ``list_foldk`` and the left and "
"right folds which process their input lists from the beginning to the end"
" unconditionally."
msgstr "描述折叠步骤的函数。 这个函数接受三个参数。 第一个参数是累加器（``'B`` 类型）的当前值。 第二个参数是要处理的下一个列表元素（类型为 ``'A``）。 第三个参数表示延迟的递归调用（类型 ``'B -> 'B``）。 该函数的结果是累加器的下一个值（``'B`` 类型）。 如果开发者不调用延迟的递归调用，则计算终止。 这是 ``list_foldk`` 和左右折叠之间的主要区别，左右折叠无条件地从头到尾处理它们的输入列表。"

#: ../scilla-in-depth.rst:1425
msgid "The initial value of the accumulator ``z`` (of type ``'B``)."
msgstr "累加器 ``z`` 的初始值（``'B`` 类型）。"

#: ../scilla-in-depth.rst:1427
msgid "The list of elements to be processed (of type ``List 'A``)."
msgstr "要处理的元素列表（类型 ``List 'A``）。"

#: ../scilla-in-depth.rst:1431
msgid ""
"When an ADT takes type arguments (such as ``List 'A``), and occurs inside"
" a bigger type (such as the type of ``list_foldl``), the ADT and its "
"arguments must be grouped using parentheses ``( )``. This is the case "
"even when the ADT occurs as the only argument to another ADT. For "
"instance, when constructing an empty list of optional values of type "
"``Int32``, one must instantiate the list type using the syntax ``Nil "
"{(Option Int32)}``."
msgstr "当 ADT 接受类型参数（例如 ``List 'A``），并出现在更大的类型（例如 ``list_foldl`` 的类型）中时，必须使用括号将 ADT 及其参数分组 ``( )``。 即使当 ADT 作为另一个 ADT 的唯一参数出现时也是如此。 例如，当构造类型为 ``Int32`` 的可选值的空列表时，必须使用语法 ``Nil {(Option Int32)}`` 来实例化列表类型。"

#: ../scilla-in-depth.rst:1440
msgid ""
"To further illustrate the ``List`` type in Scilla, we show a small "
"example using ``list_foldl`` to count the number of elements in a list. "
"For an example of ``list_foldk`` see list_find_."
msgstr "为了进一步说明 Scilla 中的 ``List`` 类型，我们展示了一个使用 ``list_foldl`` 来计算列表中元素数量的小例子。 有关 ``list_foldk`` 的示例，请参阅 list_find_。"

#: ../scilla-in-depth.rst:1460
msgid ""
"``list_length`` defines a function that takes a type argument ``'A``, and"
" a normal (value) argument ``l`` of type ``List 'A``."
msgstr "``list_length`` 定义了一个函数，它接受一个类型参数 ``'A`` 和一个 ``List 'A`` 类型的普通（值）参数 ``l``。"

#: ../scilla-in-depth.rst:1463
msgid ""
"``'A`` is a *type variable* which must be instantiated by the code that "
"intends to use ``list_length``. The type variable is specified in line 2."
msgstr "``'A`` 是一个类型变量，必须由打算使用 ``list_length`` 的代码实例化。 类型变量在第 2 行中指定。"

#: ../scilla-in-depth.rst:1467
msgid ""
"In line 4 we instantiate the types for ``list_foldl``. Since we are "
"traversing a list of values of type ``'A``, we pass ``'A`` as the first "
"type argument to ``list_foldl``, and since we are calculating the length "
"of the list (a non-negative integer), we pass ``Uint32`` as the "
"accumulator type."
msgstr "在第 4 行，我们实例化 ``list_foldl`` 的类型。 由于我们正在遍历类型为 ``'A`` 的值的列表，我们将 ``'A`` 作为第一个类型参数传递给 ``list_foldl``，并且由于我们正在计算列表的长度（一个非负整数），我们将 ``Uint32`` 作为累加器类型传递。"

#: ../scilla-in-depth.rst:1473
msgid ""
"In line 5 we define the initial value of the accumulator. Since an empty "
"list has length 0, the initial value of the accumulator is 0 (of type "
"``Uint32``, to match the accumulator type)."
msgstr "在第 5 行中，我们定义了累加器的初始值。 由于空列表的长度为 0，因此累加器的初始值为 0（类型为 ``Uint32``，以匹配累加器类型）。"

#: ../scilla-in-depth.rst:1477
msgid ""
"In lines 6-10 we specify the processing function ``iter``, which takes "
"the current accumulator value ``z`` and the current list element ``h``. "
"In this case the processing function ignores the list element, and "
"increments the accumulator by 1. When all elements in the list have been "
"processed, the accumulator will have been incremented as many times as "
"there are elements in the list, and hence the final value of the "
"accumulator will be equal to the length of the list."
msgstr "在第 6-10 行，我们指定了处理函数 ``iter``，它接受当前累加器值 ``z`` 和当前列表元素 ``h``。 在这种情况下，处理函数会忽略列表元素，并将累加器加 1。当列表中的所有元素都被处理后，累加器将增加与列表中元素一样多的次数，因此累加器的最终值将等于列表的长度。"

#: ../scilla-in-depth.rst:1485
msgid ""
"In line 12 we apply the type-instantiated version of ``list_foldl`` from "
"line 4 to the processing function, the initial accumulator, and the list "
"of values."
msgstr "在第 12 行，我们将第 4 行的 ``list_foldl`` 的类型实例化版本应用于处理函数、初始累加器和值列表。"

#: ../scilla-in-depth.rst:1489
msgid ""
"Common utilities for the ``List`` type (including ``list_length``) are "
"provided in the ``ListUtils`` library as part of the standard library "
"distribution for Scilla."
msgstr "作为 Scilla 标准库分发的一部分，``ListUtils`` 库中提供了 ``List`` 类型（包括 ``list_length``）的常用实用程序。"

#: ../scilla-in-depth.rst:1496
msgid "Pair"
msgstr "Pair"

#: ../scilla-in-depth.rst:1499
msgid ""
"Pairs of values are specified using the type ``Pair t1 t2``, where ``t1``"
" and ``t2`` are types. The ``Pair`` ADT has one constructor:"
msgstr "值 Pairs 使用类型 ``Pair t1 t2`` 指定，其中 ``t1`` 和 ``t2`` 是类型。 ``Pair`` ADT 有一个构造函数："

#: ../scilla-in-depth.rst:1502
msgid ""
"``Pair`` represents a pair of values. The ``Pair`` constructor takes two "
"arguments, namely the two values of the pair, of types ``t1`` and ``t2``,"
" respectively."
msgstr "``Pair`` 代表一对值。 ``Pair`` 构造函数接受两个参数，即 pair 的两个值，分别是 ``t1`` 和 ``t2`` 类型。"

#: ../scilla-in-depth.rst:1508
msgid ""
"``Pair`` is both the name of a type and the name of a constructor of that"
" type. An ADT and a constructor typically only share their names when the"
" constructor is the only constructor of the ADT."
msgstr "``Pair`` 既是类型的名称，也是该类型构造函数的名称。 ADT 和构造函数通常仅在构造函数是 ADT 的唯一构造函数时共享它们的名称。"

#: ../scilla-in-depth.rst:1512
msgid ""
"A ``Pair`` value may contain values of different types. In other words, "
"``t1`` and ``t2`` need not be the same type."
msgstr "``Pair`` 值可能包含不同类型的值。 换句话说，``t1`` 和 ``t2`` 不需要是相同的类型。"

#: ../scilla-in-depth.rst:1515
msgid ""
"Below is an example where we declare a field ``pp`` of type ``Pair String"
" Uint32``, which we then initialise by constructing a pair consisting of "
"a value of type ``String`` and a value of type ``Uint32``:"
msgstr "下面是一个例子，我们声明了一个 ``Pair String Uint32`` 类型的字段 ``pp``，然后我们通过构造一个由 ``String`` 类型的值和 ``Uint32`` 类型的值组成的 pair 来初始化它："

#: ../scilla-in-depth.rst:1527
msgid ""
"Notice the difference in how we specify the type of the field as ``Pair "
"A' B'``, and how we specify the types of values given to the constructor "
"as ``Pair { A' B' }``."
msgstr "请注意我们如何将字段类型指定为 ``Pair A' B'`` 以及如何将提供给构造函数的值类型指定为 ``Pair { A' B' }`` 的不同。"

#: ../scilla-in-depth.rst:1533
msgid ""
"We now illustrate how pattern matching can be used to extract the first "
"element from a ``Pair``. The function ``fst`` shown below is defined in "
"the ``PairUtils`` library of the Scilla standard library."
msgstr "我们现在说明如何使用模式匹配从 ``Pair`` 中提取第一个元素。 下面显示的函数 ``fst`` 是在 Scilla 标准库的 ``PairUtils`` 库中定义的。"

#: ../scilla-in-depth.rst:1547
msgid ""
"To apply ``fst`` to one must first instantiate the type variables ``'A`` "
"and ``'B``, which is done as follows:"
msgstr "要应用 ``fst`` ，则必须首先实例化类型变量 ``'A`` 和 ``'B``，具体操作如下："

#: ../scilla-in-depth.rst:1556
msgid ""
"The value associated with the identifier ``p_fst`` will be the string "
"``\"Hello\"``."
msgstr "与标识符 ``p_fst`` 关联的值将是字符串 ``\"Hello\"``。"

#: ../scilla-in-depth.rst:1561
msgid ""
"Using ``Pair`` is generally discouraged. Instead, the programmer should "
"define an ADT which is specialised to the particular type of pairs that "
"is needed in the particular use case. See the section on `User-defined "
"ADTs`_ below."
msgstr "通常不鼓励使用 ``Pair``。 相反，开发者应该定义一个专门用于特定用例中所需的特定类型 pair 的 ADT。 请参阅下面有关 `User-defined ADTs`_  的部分。"

#: ../scilla-in-depth.rst:1568
msgid "Nat"
msgstr "Nat"

#: ../scilla-in-depth.rst:1570
msgid ""
"Peano numbers are specified using the type ``Nat``. The ``Nat`` ADT has "
"two constructors:"
msgstr "Peano 数字使用 ``Nat`` 类型指定。 ``Nat`` ADT 有两个构造函数："

#: ../scilla-in-depth.rst:1573
msgid ""
"``Zero`` represents the number 0. The ``Zero`` constructor takes no "
"arguments."
msgstr "``Zero`` 代表数字 0。``Zero`` 构造函数不接受任何参数。"

#: ../scilla-in-depth.rst:1576
msgid ""
"``Succ`` represents the successor of another Peano number. The ``Succ`` "
"constructor takes one argument (of type ``Nat``) which represents the "
"Peano number that is one less than the current number."
msgstr "``Succ`` 代表另一个 Peano 数的后继者。 ``Succ`` 构造函数接受一个参数（``Nat`` 类型），它表示比当前数小 1 的 Peano 数。"

#: ../scilla-in-depth.rst:1581
msgid ""
"The following code shows how to build the Peano number corresponding to "
"the integer 3:"
msgstr "下面的代码展示了如何构建对应于整数 3 的 Peano 数："

#: ../scilla-in-depth.rst:1592
msgid ""
"Scilla provides two structural recursion primitives for Peano numbers, "
"which can be used to traverse all the Peano numbers from a given ``Nat`` "
"down to ``Zero``:"
msgstr "Scilla 为 Peano 数提供了两种结构递归原语，可用于遍历从给定 ``Nat`` 到 ``Zero`` 的所有 Peano 数："

#: ../scilla-in-depth.rst:1596
msgid ""
"``nat_fold: ('A -> Nat -> 'A) -> 'A -> Nat -> 'A``: Recursively process "
"the succession of numbers from a ``Nat`` down to ``Zero``, while keeping "
"track of an accumulator. ``nat_fold`` takes three arguments, two of which"
" depend on the type variable ``'A``:"
msgstr "``nat_fold: ('A -> Nat -> 'A) -> 'A -> Nat -> 'A``：递归处理从 ``Nat`` 到 ``Zero`` 的数字序列，同时跟踪累加器。 ``nat_fold`` 接受三个参数，其中两个取决于类型变量 ``'A``："

#: ../scilla-in-depth.rst:1601
msgid ""
"The function processing the numbers. This function takes two arguments. "
"The first argument is the current value of the accumulator (of type "
"``'A``). The second argument is the next Peano number to be processed (of"
" type ``Nat``). Incidentally, the next number to be processed is the "
"predecessor of the current number being processed. The result of the "
"function is the next value of the accumulator (of type ``'A``)."
msgstr "处理数字的函数。 这个函数有两个参数。 第一个参数是累加器（``'A`` 类型）的当前值。 第二个参数是下一个要处理的 Peano 数（类型为 ``Nat``）。 顺便说一下，下一个要处理的数字是当前正在处理的数字的前身。 该函数的结果是累加器的下一个值（``'A`` 类型）。"

#: ../scilla-in-depth.rst:1609
msgid "The initial value of the accumulator (of type ``'A``)."
msgstr "累加器的初始值（``'A`` 类型）。"

#: ../scilla-in-depth.rst:1611
msgid "The first Peano number to be processed (of type ``Nat``)."
msgstr "要处理的第一个 Peano 数（``Nat`` 类型）。"

#: ../scilla-in-depth.rst:1613
msgid ""
"The result of applying ``nat_fold`` is the value of the accumulator (of "
"type ``'A``) when all Peano numbers down to ``Zero`` have been processed."
msgstr "应用 ``nat_fold`` 的结果是累加器（``'A`` 类型）的值，当所有 Peano 数都被处理到 ``Zero`` 时。"

#: ../scilla-in-depth.rst:1617
msgid ""
"``nat_foldk: ('A -> Nat -> ('A -> 'A) -> 'A) -> 'A -> Nat -> 'A``: "
"Recursively process the Peano numbers down to zero according to a "
"*folding function*, while keeping track of an *accumulator*. "
"``nat_foldk`` is a more general version of the left fold allowing for "
"early termination. It takes three arguments, two depending on the type "
"variable ``'A``."
msgstr "``nat_foldk: ('A -> Nat -> ('A ->'A) ->'A) ->'A -> Nat ->'A``：根据 *折叠函数* 递归处理 Peano 数到零，同时跟踪 *累加器*。 ``nat_foldk`` 是左折叠的更通用版本，允许提前终止。 它需要三个参数，两个取决于类型变量 ``'A``。"

#: ../scilla-in-depth.rst:1624
msgid ""
"The function describing the fold step. This function takes three "
"arguments. The first argument is the current value of the accumulator (of"
" type ``'A``). The second argument is the predecessor of the Peano number"
" being processed (of type ``Nat``). The third argument represents the "
"postponed recursive call (of type ``'A -> 'A``). The result of the "
"function is the next value of the accumulator (of type ``'A``). The "
"computation *terminates* if the programmer does not invoke the postponed "
"recursive call. Left folds inevitably process the whole list whereas "
"``nat_foldk`` can differ in this regard."
msgstr "描述折叠步骤的函数。 这个函数接受三个参数。 第一个参数是累加器（``'A`` 类型）的当前值。 第二个参数是正在处理的 Peano 数的前身（``Nat`` 类型）。 第三个参数表示延迟的递归调用（类型 ``'A -> 'A``）。 该函数的结果是累加器的下一个值（``'A`` 类型）。 如果开发者不调用延迟的递归调用，则计算终止。 左折叠必须处理整个列表，而 ``nat_foldk`` 在这方面可能有所不同。"

#: ../scilla-in-depth.rst:1636
msgid "The initial value of the accumulator ``z`` (of type ``'A``)."
msgstr "累加器 ``z`` 的初始值（``'A`` 类型）。"

#: ../scilla-in-depth.rst:1638
msgid "The Peano number to be processed (of type ``Nat``)."
msgstr "要处理的 Peano 数（``Nat`` 类型）。"

#: ../scilla-in-depth.rst:1640
msgid ""
"To better understand ``nat_foldk``, we explain how ``nat_eq`` works. "
"``nat_eq`` checks to see if two Peano numbers are equivalent. Below is "
"the program, with line numbers and an explanation."
msgstr "为了更好地理解 ``nat_foldk``，我们解释了 ``nat_eq`` 的工作原理。 ``nat_eq`` 检查两个 Peano 数是否相等。 下面是带有行号和解释的具体程序。"

#: ../scilla-in-depth.rst:1662
msgid ""
"Line 2 specifies that we take two Peano numbers ``m`` and ``n``. Line 3 "
"instantiates the type of ``nat_foldk``, we give it ``Nat`` because we "
"will be passing a ``Nat`` value as the fold accumulator."
msgstr "第 2 行指定我们采用两个 Peano 数 ``m`` 和 ``n``。 第 3 行实例化了 ``nat_foldk`` 的类型，因为我们将传递一个 ``Nat`` 值作为折叠累加器，所以我们给它 ``Nat``。"

#: ../scilla-in-depth.rst:1666
msgid ""
"Lines 4 to 8 specify the fold description, this is the first argument "
"that ``nat_foldk`` takes usually of type ``'A -> Nat -> ('A -> 'A) -> "
"'A`` but we have specified that ``'A`` is ``Nat`` in this case. Our "
"function takes the accumulator ``n`` and ``ignore : Nat`` is the "
"predecessor of the number being processed which we don't care about in "
"this particular case."
msgstr "第 4 到 8 行指定了折叠描述，这是 ``nat_foldk`` 通常采用的第一个参数，类型为 ``'A -> Nat -> ('A -> 'A) -> 'A``， 但我们在这种情况下指定了 ``'A`` 是 ``Nat``。 我们的函数采用累加器 ``n`` 并且 ``ignore : Nat`` 是正在处理的数字的前身，在这种特殊情况下我们不关心它。"

#: ../scilla-in-depth.rst:1672
msgid ""
"Essentially, we start accumulating the end result from ``n`` and iterate "
"at most ``m`` times (see line 10), decrementing both ``n`` and ``m`` at "
"each recursive step (lines 4 - 9). The ``m`` variable gets decremented "
"implicitly because this is how ``nat_foldk`` works under the hood. And we"
" explicitly decrement ``n`` using pattern matching (lines 6, 7). To "
"continue iteratively decrement both ``m`` and ``n`` we use ``recurse`` on"
" line 7. If the two input numbers are equal, we will get the accumulator "
"(``n``) equal to zero in the end. We call the final value of the "
"accumulator ``remaining`` on line 10. At the end we will be checking to "
"see if our accumulator ended up at ``Zero`` to say if the input numbers "
"are equal. The last lines, return ``True`` when the result of the fold is"
" ``Zero`` and ``False`` otherwise as described above."
msgstr "本质上，我们从 ``n`` 开始累积最终结果并最多迭代 ``m`` 次（参见第 10 行），在每个递归步骤（第 4 - 9 行）递减 ``n`` 和 ``m``。 ``m`` 变量隐式递减，因为这就是 ``nat_foldk`` 在幕后工作的方式。 我们使用模式匹配（第 6、7 行）显式地递减 ``n``。 为了继续迭代递减 ``m`` 和 ``n``，我们在第 7 行使用 ``recurse``。如果两个输入数字相等，我们最终将得到等于 0 的累加器 (``n``)。 我们在第 10 行调用累加器的 ``remaining`` 来获取最终值。最后，我们将检查我们的累加器是否最终为 ``Zero``，以判断输入数字是否相等。 如上所述，在最后几行，当折叠结果为 ``Zero`` 时返回 ``True``，否则返回 ``False``。"

#: ../scilla-in-depth.rst:1687
msgid ""
"In the case when accumulator ``n`` reaches zero (line 8) while ``m`` "
"still has not been fully processed, we stop iteration (hence no "
"``recurse`` on that line) and return a non-zero natural number to "
"indicate inequality. Any number (e.g. ``Succ Zero``) would do, but to "
"make the code concise we return the original input number ``m`` because "
"we know ``iter`` gets called on ``m`` only if it's not zero."
msgstr "在累加器 ``n`` 达到零（第 8 行）而 ``m`` 仍未完全处理的情况下，我们停止迭代（因此该行没有 ``recurse``）并返回一个非零自然数以表示不等式。 任何数字（例如 ``Succ Zero``）都可以，但为了使代码简洁，我们返回原始输入数字 ``m``，因为我们知道只有当 ``m`` 不为零时才会在 ``m`` 上调用 ``iter``。"

#: ../scilla-in-depth.rst:1695
msgid ""
"In the symmetrical case when ``m`` reaches zero while the accumulator "
"``n`` is still strictly positive, we indicate inequality, because "
"``remaining`` gets this final value of ``n``."
msgstr "因为 ``remaining`` 得到 ``n`` 的最终值，所以在 ``m`` 达到零而累加器 ``n`` 仍然严格为正的对称情况下，我们表示不等式。"

#: ../scilla-in-depth.rst:1700
msgid "User-defined ADTs"
msgstr "用户自定义 ADT"

#: ../scilla-in-depth.rst:1702
msgid ""
"In addition to the built-in ADTs described above, Scilla supports user-"
"defined ADTs."
msgstr "除了上述内置的 ADT 之外，Scilla 还支持用户自定义 ADT。"

#: ../scilla-in-depth.rst:1705
msgid ""
"ADT definitions may only occur in the library parts of a program, either "
"in the library part of the contract, or in an imported library. An ADT "
"definition is in scope in the entire library in which it is defined, "
"except that an ADT definition may only refer to other ADT definitions "
"defined earlier in the same library, or in imported libraries. In "
"particular, an ADT definition may not refer to itself in an "
"inductive/recursive manner."
msgstr "ADT 定义可能只出现在程序的库部分：要么出现在合约的库部分，要么出现在导入的库中。 ADT 定义在定义它的整个库的范围内，除了 ADT 定义引用之前在同一库或导入库中定义的其他 ADT 定义。 特别是，ADT 定义可能不会以归纳/递归方式引用自身。"

#: ../scilla-in-depth.rst:1713
msgid ""
"Each ADT defines a set of constructors. Each constructor specifies a "
"number of types which corresponds to the number and types of arguments "
"that the constructor takes. A constructor may be specified as taking no "
"arguments."
msgstr "每个 ADT 定义了一组构造函数。 每个构造函数都指定了许多类型，这些类型对应于构造函数采用的参数的数量和类型。 构造函数可以指定为不带参数。"

#: ../scilla-in-depth.rst:1718
msgid ""
"The ADTs of a contract must have distinct names, and the set of all "
"constructors of all ADTs in a contract must also have distinct names. "
"Both the ADT and constructor names must begin with a capital letter ('A' "
"- 'Z'). However, a constructor and an ADT may have the same name, as is "
"the case with the ``Pair`` type whose only constructor is also called "
"``Pair``."
msgstr "一个合约的 ADT 必须有不同的名称，合约中所有 ADT 的所有构造函数的集合也必须有不同的名称。 ADT 和构造函数名称都必须以大写字母开头（‘A’ - ‘Z’）。 但是，构造函数和 ADT 可能具有相同的名称，就像 ``Pair`` 类型的情况一样，它的唯一构造函数也称为 ``Pair``。"

#: ../scilla-in-depth.rst:1725
msgid ""
"As an example of user-defined ADTs, consider the following type "
"declarations from a contract implementing a chess-like game called Shogi "
"or Japanese Chess (https://en.wikipedia.org/wiki/Shogi). When in turn, a "
"player can choose to either move one of his pieces, place a previously "
"captured piece back onto the board, or resign and award the victory to "
"the opponent."
msgstr "作为用户定义的 ADT 的示例，请考虑来自实现名为 Shogi 或 Japanese Chess (https://en.wikipedia.org/wiki/Shogi) 的类象棋游戏的合约中的以下类型声明。 当轮到你时，玩家可以选择移动他的一个棋子，将先前捕获的棋子放回棋盘上，或者弃权并将胜利授予对手。"

#: ../scilla-in-depth.rst:1732
msgid "The pieces of the game can be defined using the following type ``Piece``:"
msgstr "可以使用以下类型 ``Piece`` 定义游戏的棋子："

#: ../scilla-in-depth.rst:1747
msgid ""
"Each of the constructors represents a type of piece in the game. None of "
"the constructors take any arguments."
msgstr "每个构造函数都代表游戏中的一种棋子。每个构造函数都不接受任何参数。"

#: ../scilla-in-depth.rst:1750
msgid ""
"The board is represented as a set of squares, where each square has two "
"coordinates:"
msgstr "棋盘表示为一组方块，其中每个方块有两个坐标："

#: ../scilla-in-depth.rst:1758
msgid ""
"The type ``Square`` is an example of a type where a constructor has the "
"same name as the type. This usually happens when a type has only one "
"constructor. The constructor ``Square`` takes two arguments, both of type"
" ``Uint32``, which are the coordinates (the row and the column) of the "
"square on the board."
msgstr "类型 ``Square`` 是一个类型的示例，其中构造函数与类型具有相同的名称。 这通常发生在一个类型只有一个构造函数时。 构造函数 ``Square`` 接受两个参数，都是 ``Uint32`` 类型，它们是棋盘上正方形的坐标（行和列）。"

#: ../scilla-in-depth.rst:1764
msgid ""
"Similar to the definition of the type ``Piece``, we can define the type "
"of direction of movement using a constructor for each of the legal "
"directions as follows:"
msgstr "与类型 ``Piece`` 的定义类似，我们可以使用构造函数为每个合法方向定义运动方向的类型，如下所示："

#: ../scilla-in-depth.rst:1780
msgid ""
"We are now in a position to define the type of possible actions that a "
"user may choose to perform when in turn:"
msgstr "我们现在可以定义用户在以下情况下可以选择执行的可能操作类型："

#: ../scilla-in-depth.rst:1790
msgid ""
"If a player chooses to move a piece, she should use the constructor "
"``Move``, and provide four arguments:"
msgstr "如果玩家选择移动一个棋子，她应该使用构造函数 ``Move``，并提供四个参数："

#: ../scilla-in-depth.rst:1793
msgid ""
"An argument of type ``Square``, indicating the current position of the "
"piece she wants to move."
msgstr "``Square`` 类型的参数，指示她要移动的棋子的当前位置。"

#: ../scilla-in-depth.rst:1796
msgid "An argument of type ``Direction``, indicating the direction of movement."
msgstr "``Direction`` 类型的参数，指示移动的方向。"

#: ../scilla-in-depth.rst:1799
msgid ""
"An argument of type ``Uint32``, indicating the distance the piece should "
"move."
msgstr "``Uint32`` 类型的参数，指示棋子应移动的距离。"

#: ../scilla-in-depth.rst:1802
msgid ""
"An argument of type ``Bool``, indicating whether the moved piece should "
"be promoted after being moved."
msgstr "``Bool`` 类型的参数，指示被移动的棋子在被移动后是否应该被提升。"

#: ../scilla-in-depth.rst:1805
msgid ""
"If instead the player chooses to place a previously captured piece back "
"onto the board, she should use the constructor ``Place``, and provide two"
" arguments:"
msgstr "相反，如果玩家选择将先前捕获的棋子放回棋盘上，她应该使用构造函数 ``Place``，并提供两个参数："

#: ../scilla-in-depth.rst:1809
msgid ""
"An argument of type ``Piece``, indicating which piece to place on the "
"board."
msgstr "``Piece`` 类型的参数，指示将哪一块放置在板上。"

#: ../scilla-in-depth.rst:1812
msgid ""
"An argument of type ``Square``, indicating the position the piece should "
"be placed in."
msgstr "``Square`` 类型的参数，指示棋子应放置的位置。"

#: ../scilla-in-depth.rst:1815
msgid ""
"Finally, if the player chooses to resign and award the victory to her "
"opponent, she should use the constructor ``Resign``. Since ``Resign`` "
"does not take any arguments, no arguments should be provided."
msgstr "最后，如果玩家选择弃权并将胜利授予她的对手，她应该使用构造函数 ``Resign``。 由于 ``Resign`` 不接受任何参数，因此不应提供任何参数。"

#: ../scilla-in-depth.rst:1819
msgid ""
"To check which action a player has chosen we use a match statement or a "
"match expression:"
msgstr "要检查玩家选择了哪个动作，我们使用 ``match`` 语句或 ``match`` 表达式："

#: ../scilla-in-depth.rst:1839
msgid "Type identity for user-defined ADTs"
msgstr "用户自定义 ADT 的类型标识"

#: ../scilla-in-depth.rst:1843
msgid ""
"Due to a bug in the Scilla implementation the information in this section"
" is only valid from Scilla version 0.10.0 and forwards. Contracts written"
" in Scilla versions prior to 0.10.0 and which exploit this bug will have "
"to be rewritten and redeployed, as they will no longer work from version "
"0.10.0 and onwards."
msgstr "由于 Scilla 实现中的错误，本节中的信息仅适用于 Scilla 0.10.0 及更高版本。 使用 0.10.0 之前的 Scilla 版本编写并发现此错误的合约必须重新编写和重新部署，因为它们将不再适用于 0.10.0 及更高版本。"

#: ../scilla-in-depth.rst:1849
msgid ""
"Each type declaration defines a unique type. In particular this means "
"that even if two libraries both define identical types, the types are "
"considered different."
msgstr "每个类型声明定义了一个唯一的类型。 特别需要注意的是，这意味着即使两个库都定义了相同的类型，这些类型也被认为是不同的。"

#: ../scilla-in-depth.rst:1853
msgid "As an example, consider the following two contracts:"
msgstr "例如，思考以下两个合约："

#: ../scilla-in-depth.rst:1896
msgid ""
"Even though both contracts define identical types ``T``, the two types "
"are considered different in Scilla. In particlar this means that the "
"message sent from ``Contract1`` to ``Contract2`` will not trigger the "
"``Receiving`` transition, because the value sent as the ``param`` message"
" field has the type ``T`` from ``Contract1``, whereas the type ``T`` from"
" ``Contract2`` is expected."
msgstr "尽管两个合约都定义了相同的类型 ``T``，但这两种类型在 Scilla 中被认为是不同的。 特别是，这意味着从 ``Contract1`` 发送到 ``Contract2`` 的消息不会触发 transition ``Receiving``，因为作为 ``param`` 消息字段发送的值具有来自 ``Contract1`` 的类型 ``T``，而真正需要的是来自 ``Contract2`` 的类型 ``T``。"

#: ../scilla-in-depth.rst:1903
msgid ""
"In order to pass a value of a user-defined ADT as a parameter to a "
"transition, the type must be defined in a user-defined library, which "
"both the sending and the receiving contract must import:"
msgstr "为了将用户自定义 ADT 的值作为参数传递给 transition，必须在用户定义的库中定义类型，发送和接收合约都必须导入："

#: ../scilla-in-depth.rst:1955
msgid ""
"The section :ref:`user-defined_libraries` has more information on how to "
"define and use libraries."
msgstr ":ref:`user-defined_libraries` 部分提供了有关如何定义和使用库的更多信息。"

#: ../scilla-in-depth.rst:1959
msgid "More ADT examples"
msgstr "更多 ADT 示例"

#: ../scilla-in-depth.rst:1961
msgid ""
"To further illustrate how ADTs can be used, we provide some more examples"
" and describe them in detail. Versions of both the functions described "
"below can be found in the ``ListUtils`` part of the :doc:`Scilla standard"
" library <stdlib>`."
msgstr "为了进一步说明如何使用 ADT，我们提供了更多示例并详细描述了它们。 下面描述的两个函数的版本都可以在 :doc:`Scilla标准库 <stdlib>` 的 ``ListUtils`` 部分中找到。"

#: ../scilla-in-depth.rst:1967
msgid "Computing the Head of a List"
msgstr "计算列表的头部"

#: ../scilla-in-depth.rst:1969
msgid "The function ``list_head`` returns the first element of a list."
msgstr "函数 ``list_head`` 返回列表的第一个元素。"

#: ../scilla-in-depth.rst:1971
msgid ""
"Since a list may be empty, ``list_head`` may not always be able to "
"compute a result, and thus should return a value of the ``Option`` type. "
"If the list is non-empty, and the first element is ``h``, then "
"``list_head`` should return ``Some h``. Otherwise, if the list is empty, "
"``list_head`` should return ``None``."
msgstr "由于列表可能为空，``list_head`` 可能并不总是能够计算结果，因此应该返回 ``Option`` 类型的值。 如果列表非空，并且第一个元素是 ``h``，那么 ``list_head`` 应该返回 ``Some h``。 否则，如果列表为空，``list_head`` 应返回 ``None``。"

#: ../scilla-in-depth.rst:1977
msgid ""
"The following code snippet shows the implementation of ``list_head``, and"
" how to apply it:"
msgstr "以下代码片段显示了 ``list_head`` 的实现以及如何应用它："

#: ../scilla-in-depth.rst:2005
msgid ""
"Line 2 specifies that ``'A`` is a type parameter to the function, while "
"line 3 specifies that ``l`` is a (value) parameter of type ``List 'A``. "
"In other words, lines 1-3 specify a function ``list_head`` which can be "
"instantiated for any type ``'A``, and which takes as an argument a value "
"of type ``List 'A``."
msgstr "第 2 行指定 ``'A`` 是函数的类型参数，而第 3 行指定 ``l`` 是 ``List 'A`` 类型的（值）参数。 换句话说，第 1-3 行指定了一个函数 ``list_head``，它可以为任何类型 ``'A`` 实例化，并将 ``List 'A`` 类型的值作为参数。"

#: ../scilla-in-depth.rst:2011
msgid ""
"The pattern-match in lines 4-9 matches on the value of ``l``. In line 5 "
"we match on the list constructor ``Cons h t``, where ``h`` is the first "
"element of the list, and ``t`` is the rest of the list. If the list is "
"not empty then the match is successful, and we return the first element "
"as an optional value ``Some h``. In line 7 we match on the list "
"constructor ``Nil``. If the list is empty then the match is successful, "
"and we return the optional value ``None`` indicating that there was no "
"head element of the list."
msgstr "第 4-9 行中的模式匹配匹配 ``l`` 的值。 在第 5 行，我们匹配列表构造函数 ``Cons h t``，其中 ``h`` 是列表的第一个元素，而 ``t`` 是列表的其余部分。 如果列表不为空，则匹配成功，我们将第一个元素作为可选值返回 ``Some h``。 在第 7 行，我们匹配列表构造函数 ``Nil``。 如果列表为空，则匹配成功，我们返回可选值 ``None`` 表示列表中没有头元素。"

#: ../scilla-in-depth.rst:2020
msgid ""
"Line 11 instantiates the ``list_head`` function for the type ``Int32``, "
"so that ``list_head`` can be applied to values of type ``List Int32``. "
"Lines 13-20 build a list of type ``List Int32``, and line 21 invokes the "
"instantiated ``list_head`` function on the list that was built."
msgstr "第 11 行实例化了 ``Int32`` 类型的 ``list_head`` 函数，以便将 ``list_head`` 应用于 ``List Int32`` 类型的值。 第 13-20 行构建一个 ``List Int32`` 类型的列表，第 21 行在构建的列表上调用实例化的 ``list_head`` 函数。"

#: ../scilla-in-depth.rst:2027
msgid "Computing a Left Fold"
msgstr "计算左折叠"

#: ../scilla-in-depth.rst:2029
msgid ""
"The function ``list_foldl`` returns the result of a left fold given a "
"function ``f : 'B -> 'A -> 'B``, accumulator ``z : 'B`` and list ``xs : "
"List 'A``. This can be implemented as a recursion primitive or a list "
"utility function."
msgstr "函数 ``list_foldl`` 在给定 ``function f : 'B -> 'A -> 'B``、累加器 ``z : 'B`` 和列表 ``xs : List 'A`` 的情况下返回左折叠的结果。 这可以实现为递归原语或列表实用程序函数。"

#: ../scilla-in-depth.rst:2033
msgid ""
"A left fold is a recursive application of an accumulator ``z`` and next "
"list element ``x : 'A`` with ``f`` repetitively until there are no more "
"list elements. For example the left fold on ``[1,2,3]`` using subtraction"
" starting with accumulator 0 would be ``((0-1)-2)-3 = -6``. The left fold"
" is explained in pseudocode below, note that the result is always the "
"accumulator type."
msgstr "左折叠是累加器 ``z`` 和下一个重复使用 ``f`` 的列表元素 ``x : 'A`` 的递归应用，直到没有更多列表元素为止。 例如，使用从累加器 0 开始的减法在 ``[1,2,3]`` 上的左折叠将是 ``((0-1)-2)-3 = -6``。 左折叠在下面的伪代码中解释，注意结果总是累加器类型。"

#: ../scilla-in-depth.rst:2045
msgid ""
"The same can be achieved with ``list_foldk`` by partially applying a left"
" fold description; this avoids illegal direct recursion. Our fold "
"description ``left_f : 'B -> 'A -> ('B -> 'B) -> 'B`` takes arguments "
"accumulator, next list element and recursive call. The recursive call "
"will be supplied by the ``list_foldk`` function. An implementation is "
"explained below."
msgstr "使用 ``list_foldk`` 也可以通过部分应用左折叠描述来实现相同的效果； 这避免了非法的直接递归。 我们的折叠描述 ``left_f : 'B -> 'A -> ('B -> 'B) -> 'B`` 接受参数累加器、下一个列表元素和递归调用。 递归调用将由 ``list_foldk`` 函数提供。 下面将解释一个具体实现。"

#: ../scilla-in-depth.rst:2063
msgid ""
"On line 1, we declare the name and type signature as according to the "
"first paragraph. On the second line, we say that the function takes two "
"types as arguments ``'A`` and ``'B``. The third line says that we take "
"some function ``f`` to process the list element and accumulator, as in "
"paragraph two."
msgstr "我们根据第一段所述，在第 1 行，声明名称和类型签名。 在第二行，我们说该函数采用两种类型作为参数 ``'A`` 和 ``'B``。 如第二段所述，第三行我们使用一些函数 ``f`` 来处理列表元素和累加器。"

#: ../scilla-in-depth.rst:2068
msgid ""
"On line 4, we define the fold description using ``f``. The fold "
"description does not take a function but instead it should be implemented"
" in terms of some function, as according to the type signature, ``left_f "
": 'B -> 'A -> ('B -> 'B) -> 'B``. ``left_f`` takes arguments as described"
" in paragraph two. We calculate the new accumulator ``f z x`` and call it"
" ``res``. Then we recursively call with the new accumulator."
msgstr "在第 4 行，我们使用 ``f`` 定义折叠描述。 折叠描述不采用函数，而是应该根据某些函数来实现，正如根据类型签名那样，``left_f : 'B -> 'A -> ('B -> 'B) -> 'B``。 ``left_f`` 接受第二段中描述的参数。 我们计算新的累加器 ``f z x`` 并将其称为 ``res``。 然后我们用新的累加器递归调用。"

#: ../scilla-in-depth.rst:2075
msgid ""
"On line 7, we instantiate an instance of ``list_foldk`` that has the "
"right types for the job using a type application."
msgstr "在第 7 行，我们使用类型应用程序实例化一个 ``list_foldk`` 实例，该实例具有适合作业的正确类型。"

#: ../scilla-in-depth.rst:2078
msgid ""
"On line 8, we partially apply ``folder`` with the left fold description. "
". What is significant about ``list_foldk`` is that when calling the "
"description, it provides a recursive call to itself, changing to the next"
" element in the list and respective tail each time. This results in a "
"function that just needs the user to provide the updated accumulator in "
"the description."
msgstr "在第 8 行，我们部分应用了带有左折叠描述的 ``folder``。 ``list_foldk`` 的重要之处在于，在调用描述时，它提供对自身的递归调用，每次更改为列表中的下一个元素和相应的尾部。 这导致一个函数只需要用户在描述中提供更新的累加器。"

#: ../scilla-in-depth.rst:2085
msgid "Computing a Right Fold"
msgstr "计算右折叠"

#: ../scilla-in-depth.rst:2087
msgid ""
"The function ``list_foldr`` returns the result of a right fold given some"
" function ``f : 'A -> 'B -> 'B``, accumulator ``z : 'B`` and list ``xs : "
"List 'A``. Like ``list_foldl``, this can be a recursion primitive or a "
"list utility function."
msgstr "在给定一些函数 ``f : 'A -> 'B -> 'B``、累加器 ``z : 'B`` 和列表 ``xs : List 'A`` 的情况下，函数 ``list_foldr`` 返回右折叠的结果。 与 ``list_foldl`` 一样，这可以是递归原语或列表实用程序函数。"

#: ../scilla-in-depth.rst:2092
msgid ""
"A right fold is similar to a left fold but is reversed in a way. The "
"right fold applies a function ``f`` with an accumulator ``z`` starting "
"from the end and then combines with the second last element, third last "
"element, etc... until it reaches the beginning. For example a right fold "
"on the list ``[1,2,3]`` with subtraction starting with accumulator 0 "
"would be equal to ``1-(2-(3-0)) = 2``. It is listed below in pseudocode, "
"note that the result is always the accumulator type."
msgstr "右折叠类似于左折叠，但在某种程度上是相反的。 右折叠从末尾开始应用一个带有累加器 ``z`` 的函数 ``f``，然后与倒数第二个元素、倒数第三个元素等组合，直到它到达开头。 例如，列表 ``[1,2,3]`` 上的右折叠从累加器 0 开始减法直到等于 ``1-(2-(3-0)) = 2``。下面以伪代码列出，注意结果始终是累加器类型。"

#: ../scilla-in-depth.rst:2106
msgid ""
"Like before, the same can be achieved with ``list_foldk`` by partially "
"applying a right fold description. The fold description takes arguments "
"accumulator ``z : 'B``, next list element ``x : 'A`` and recursive call "
"``recurse : 'B -> 'B``. The recursive call will be supplied by the "
"``list_foldk`` function. An implementation is explained below."
msgstr "像以前一样，通过部分应用右折叠描述，可以使用 ``list_foldk`` 实现相同的效果。 折叠描述采用参数累加器 ``z : 'B``，下一个列表元素 ``x : 'A`` 和递归调用 ``recurse : 'B -> 'B``。 递归调用将由 ``list_foldk`` 函数提供。 下面将解释一个具体实现。"

#: ../scilla-in-depth.rst:2123
msgid ""
"This is very similar to before. On line 1 we declare the name and type "
"signature, according to the first paragraph. On line 2, we take two type "
"arguments ``'A`` and ``'B``. The third line says that we take some "
"function ``f`` to process the list element ``x : 'A`` and accumulator "
"``z``. The argument order is necessarily different to that of a left "
"fold."
msgstr "这与以前非常相似。 在第 1 行，我们根据第一段所述，声明名称和类型签名。 在第 2 行，我们采用两个类型参数 ``'A`` 和 ``'B``。 第三行表示我们使用一些函数 ``f`` 来处理列表元素 ``x : 'A`` 和累加器 ``z``。 参数顺序必然与左折叠的顺序不同。"

#: ../scilla-in-depth.rst:2129
msgid ""
"Following that we write a fold description like before. ``list_foldk`` "
"processes lists from left to right. But we need ``list_foldr`` to emulate"
" the right-to-left traversal. By calling ``recurse z`` on line 5 as our "
"first action, we postpone actual computation with the combining function "
"``f`` preserving the original accumulator until the very end. Once the "
"recursive call reaches an empty list it returns the original accumulator."
" Then the function calls ``f x res`` (line 5) will evaluate outwards "
"combining from the end to the beginning, see paragraph two."
msgstr "之后，我们像以前一样编写折叠描述。 ``list_foldk`` 从左到右处理列表。 但是我们需要 ``list_foldr`` 来模拟从右到左的遍历。 通过在第 5 行调用 ``recurse z`` 作为我们的第一个动作，我们使用组合函数 ``f`` 将实际计算推迟到最后，保留原始累加器。 一旦递归调用到达一个空列表，它就会返回原始累加器。 然后函数调用 ``f x res`` （第 5 行）将评估从结尾到开头的向外组合，参见第二段。"

#: ../scilla-in-depth.rst:2138
msgid ""
"The recursive call ``recurse z`` on line 5 may seem to be the same each "
"time but what is changing is the list element we process."
msgstr "第 5 行的递归调用 ``recurse z`` 似乎每次都一样，但改变的是我们处理的列表元素。"

#: ../scilla-in-depth.rst:2141
msgid ""
"On line 6, we instantiate ``list_foldk`` by applying the types ``'A`` and"
" ``'B`` to make a type-specific function. The last line we partially "
"apply ``folder`` with the right fold description. Like before what is "
"special about ``list_foldk`` is that it calls this function with a "
"recursive call to itself that each time slightly truncates the list; this"
" provides the recursion."
msgstr "在第 6 行，我们通过应用类型 ``'A`` 和 ``'B`` 来实例化 ``list_foldk``，并以此创建特定于类型的函数。 最后一行我们部分应用带有正确折叠描述的 ``folder``。 和之前一样，``list_foldk`` 的特别之处在于它通过递归调用自身来调用这个函数，每次都会稍微截断列表； 它提供了递归。"

#: ../scilla-in-depth.rst:2148
msgid "Checking for Existence in a List"
msgstr "检查列表中的存在性"

#: ../scilla-in-depth.rst:2150
msgid ""
"The function ``list_exists`` takes a predicate function and a list, and "
"returns a value indicating whether the predicate holds for at least one "
"element in the list."
msgstr "函数 ``list_exists`` 接受一个谓词函数和一个列表，并返回一个值，该值指示谓词是否至少对列表中的一个元素而成立。"

#: ../scilla-in-depth.rst:2154
msgid ""
"A predicate function is a function returning a Boolean value, and since "
"we want to apply it to elements in the list, the argument type of the "
"function should be the same as the element type of the list."
msgstr "谓词函数是一个返回布尔值的函数，由于我们希望将其应用于列表中的元素，因此函数的参数类型应该与列表的元素类型相同。"

#: ../scilla-in-depth.rst:2158
msgid ""
"``list_exists`` should return either ``True`` (if the predicate holds for"
" at least one element) or ``False`` (if the predicate does not hold for "
"any element in the list), so the return type of ``list_exists`` should be"
" ``Bool``."
msgstr "``list_exists`` 应该返回 ``True`` （如果谓词至少对一个元素成立）或 ``False`` （如果谓词对列表中的任何元素都不成立），所以 ``list_exists`` 的返回类型应该是 ``Bool``。"

#: ../scilla-in-depth.rst:2163
msgid ""
"The following code snippet shows the implementation of ``list_exists``, "
"and how to apply it:"
msgstr "以下代码片段显示了 ``list_exists`` 的实现，以及如何应用它："

#: ../scilla-in-depth.rst:2201
msgid ""
"As in the previous example ``'A`` is a type variable to the function. The"
" function takes two arguments:"
msgstr "与前面的示例一样，``'A`` 是函数的类型变量。 该函数有两个参数："

#: ../scilla-in-depth.rst:2204
msgid ""
"A predicate ``f``, i.e., a function that returns a ``Bool``. In this "
"case, ``f`` will be applied to elements of the list, so the argument type"
" of the predicate should be ``'A``. Hence, ``f`` should have the type "
"``'A -> Bool``."
msgstr "谓词 ``f``，即返回 ``Bool`` 的函数。 在这种情况下，``f`` 将应用于列表的元素，那么谓词的参数类型应为 ``'A``。 因此，``f`` 的类型应该是 ``'A -> Bool``。"

#: ../scilla-in-depth.rst:2209
msgid ""
"A list of elements ``l`` of type ``List 'A``, so that the type of the "
"elements in the list matches the argument type of ``f``."
msgstr "类型为 ``List 'A`` 的元素 ``l`` 的列表，以便列表中元素的类型与 ``f`` 的参数类型相匹配。"

#: ../scilla-in-depth.rst:2212
msgid ""
"To traverse the elements of the input list ``l`` we use ``list_foldl``. "
"In line 5 we instantiate ``list_foldl`` for lists with elements of type "
"``'A`` and for the accumulator type ``Bool``. In line 6 we set the "
"initial accumulator value to ``False`` to indicate that no element "
"satisfying the predicate has yet been seen."
msgstr "为了遍历输入列表 ``l`` 的元素，我们使用 ``list_foldl``。 在第 5 行，我们为具有类型 ``'A`` 的元素的列表和类型为 ``Bool`` 的累加器实例化 ``list_foldl``。 在第 6 行中，我们将初始累加器值设置为 ``False`` 以指示尚未看到满足谓词的元素。"

#: ../scilla-in-depth.rst:2218
msgid ""
"The processing function ``iter`` defined in lines 7-16 tests the "
"predicate on the current list element, and returns an updated "
"accumulator. If an element has been found which satisfies the predicate, "
"the accumulator is set to ``True`` and remains so for the rest of the "
"traversal."
msgstr "第 7-16 行中定义的处理函数 ``iter`` 测试当前列表元素上的谓词，并返回更新的累加器。 如果找到满足谓词的元素，则累加器设置为 ``True`` 并在剩余的遍历中保留此值。"

#: ../scilla-in-depth.rst:2224
msgid ""
"The final value of the accumulator is either ``True``, indicating that "
"``f`` returned ``True`` for at least one element in the list, or "
"``False``, indicating that ``f`` returned ``False`` for all elements in "
"the list."
msgstr "累加器的最终值要么是 ``True``，表示 ``f`` 对列表中的至少一个元素返回 ``True``，要么是 ``False``，表示 ``f`` 对列表中的所有元素都返回 ``False``。"

#: ../scilla-in-depth.rst:2229
msgid ""
"In line 20 we instantiate ``list_exists`` to work on lists of type "
"``Int128``. In lines 21-24 we define the predicate, which returns "
"``True`` if its argument is less than 3, and returns ``False`` otherwise."
msgstr "在第 20 行，我们实例化 ``list_exists`` 以处理 ``Int128`` 类型的列表。 在第 21-24 行中，我们定义了谓词，如果其参数小于 3，则返回 ``True``，否则返回 ``False``。"

#: ../scilla-in-depth.rst:2234
msgid ""
"Omitted in line 27 is building the same list ``l3`` as in the previous "
"example. In line 30 we apply the instantiated ``list_exists`` to the "
"predicate and the list."
msgstr "第 27 行省略了构建与前一个示例相同的列表 ``l3``。 在第 30 行，我们将实例化的 ``list_exists`` 应用于谓词和列表。"

#: ../scilla-in-depth.rst:2241
msgid "Finding the first occurrence satisfying a predicate"
msgstr "找到满足谓词的第一次出现"

#: ../scilla-in-depth.rst:2243
msgid ""
"The function ``list_find`` searches for the first occurrence in a list "
"that satisfies some predicate ``p : 'A -> Bool``. It takes the predicate "
"and the list, returning ``Some {'A} x :: Option 'A`` if ``x`` is the "
"first element such that ``p x`` and ``None {'A} :: Option 'A`` otherwise."
msgstr "函数 ``list_find`` 在满足谓词 ``p : 'A -> Bool`` 的列表中搜索第一次出现。 它接受谓词和列表，如果 ``x`` 是第一个元素使得 ``p x`` 则返回 ``Some {'A} x :: Option 'A``，否则返回 ``None {'A} :: Option 'A`` 。"

#: ../scilla-in-depth.rst:2249
msgid ""
"Below we have an implementation of ``list_find`` that illustrates how to "
"use ``list_foldk``."
msgstr "下面我们有一个 ``list_find`` 的实现，它说明了如何使用 ``list_foldk``。"

#: ../scilla-in-depth.rst:2271
msgid ""
"Like before, we take a type variable ``'A`` on line 2 and take the "
"predicate on the next line. We begin by using this type variable to "
"instantiate ``foldk``, by giving it our processing type and return type. "
"The processing type being the list element type and the result type being"
" ``Option 'A``. The next line is our accumulator, we assume that at the "
"start of the search there is no satisfier."
msgstr "和以前一样，我们在第 2 行取一个类型变量 ``'A``，并在下一行取谓词。 我们首先使用这个类型变量来实例化 ``foldk``，给它我们的处理类型和返回类型。 处理类型为列表元素类型，结果类型为 ``Option 'A``。 下一行是我们的累加器，我们假设在搜索开始时没有满足条件。"

#: ../scilla-in-depth.rst:2278
msgid ""
"On line 7, we write a fold description for ``foldk``. This embodies the "
"order of the recursion and conditions for recursion. ``predicate_step`` "
"has the type ``Option 'A -> 'A -> (Option 'A -> Option 'A) -> Option "
"'A``. The first argument is the accumulator, the second ``x`` is the next"
" element to process and the third ``recurse`` is the recursive call. We "
"do not care what the accumulator ``ignore`` is since if it mattered we "
"will have already terminated."
msgstr "在第 7 行，我们为 ``foldk`` 写了一个折叠描述。 这体现了递归的顺序和递归的条件。 ``predicate_step`` 的类型为 ``Option 'A -> 'A -> (Option 'A -> Option 'A) -> Option 'A``。 第一个参数是累加器，第二个 ``x`` 是下一个要处理的元素，第三个递归是递归调用。 我们不在乎累加器 ``ignore`` 的是什么，因为如果重要，我们就已经终止了。"

#: ../scilla-in-depth.rst:2286
msgid ""
"On lines 10 to 12 check for ``p x`` and if so return ``Some {'A} x``. In "
"the case that ``p x`` does not hold, try again from scratch with the next"
" element and so on via recursion. ``recurse init`` is in pseudo-code "
"equal to ``λk. foldk predicate_step init k xs`` where ``xs`` is the tail "
"of our list of to be processed elements."
msgstr "在第 10 到 12 行检查 ``p x``，如果成立，则返回 ``Some {'A} x``。 在 ``p x`` 不成立的情况下，通过递归从头开始尝试下一个元素，依此类推。 ``recurse init`` 在伪代码中等于 ``λk. foldk predicate_step init k xs``，其中 ``xs`` 是我们要处理的元素列表的尾部。"

#: ../scilla-in-depth.rst:2292
msgid ""
"With the final line we partially apply ``foldk`` so that it just takes a "
"list argument and gives us our final answer. The first argument of "
"``foldk`` gives us the specific fold we want, for example if you wanted a"
" left fold you would replace ``predicate_step`` with something else."
msgstr "在最后一行中，我们部分应用了 ``foldk`` 以便它只接受一个列表参数并给出我们的最终答案。 ``foldk`` 的第一个参数为我们提供了我们想要的特定折叠，例如，如果你想要一个左折叠，你可以用其他东西替换 ``predicate_step``。"

#: ../scilla-in-depth.rst:2298
msgid "Standard Libraries"
msgstr "标准库"

#: ../scilla-in-depth.rst:2299
msgid "The Scilla standard library is :doc:`documented<stdlib>` separately."
msgstr "Scilla 标准库在 :doc:`Scilla 标准库<stdlib>` 中单独记录。"

#: ../scilla-in-depth.rst:2304
msgid "User-defined Libraries"
msgstr "用户自定义库"

#: ../scilla-in-depth.rst:2306
msgid ""
"In addition to the standard library provided by Scilla, users are allowed"
" to deploy library code on the blockchain. Library files are allowed to "
"only contain pure Scilla code (which is the same restriction that in-"
"contract library code has). Library files must use the ``.scillib`` file "
"extension."
msgstr "除了 Scilla 提供的标准库，用户还可以在区块链上部署库代码。 库文件只允许包含纯 Scilla 代码（这与合约库代码的限制相同）。 库文件必须使用 ``.scillib`` 文件扩展名。"

#: ../scilla-in-depth.rst:2311
msgid ""
"Below is an example of a user-defined library that defines a single "
"function ``add_if_equal`` that adds to ``Uint128`` values if they are "
"equal and returns ``0`` otherwise."
msgstr "下面是一个用户自定义库的示例，它定义了一个函数 ``add_if_equal``，如果它们相等，则添加到 ``Uint128`` 值，否则返回 ``0``。"

#: ../scilla-in-depth.rst:2328
msgid ""
"The structure of a library file is similar to the structure of the "
"library part of a Scilla contract. A library file contains definitions of"
" variables and pure library functions, but does not contain an actual "
"contract definition with parameters, fields, transitions and so on."
msgstr "库文件的结构类似于 Scilla 合约的库部分的结构。 库文件包含变量和纯库函数的定义，但不包含带有参数、字段、transition 等的实际合约定义。"

#: ../scilla-in-depth.rst:2333
msgid ""
"Of particular importance is that a library cannot declare fields. "
"Therefore, all libraries are stateless and can only contain pure code."
msgstr "特别重要的是库不能声明字段。 因此，所有库都是无状态的，只能包含纯代码。"

#: ../scilla-in-depth.rst:2336
msgid ""
"Similar to how contracts can import libraries, a library can import other"
" libraries (including user-defined libraries) too. The scope of variables"
" in an imported library is restricted to the immediate importer. So if "
"``X`` imports library ``Y`` which in turn imports library ``Z``, then the"
" names in ``Z`` are not in scope in `X``, but only in ``Y``. Cyclic "
"dependencies in imports are not allowed and flagged as errors during the "
"checking phase."
msgstr "与合约导入库的方式类似，库也可以导入其他库（包括用户自定义库）。 导入库中变量的范围仅限于直接导入者。 因此，如果 ``X`` 导入库 ``Y`` 而后者又导入库 ``Z``，则 ``Z`` 中的名称不在 ``X`` 的范围内，而仅在 ``Y`` 中。导入中的循环依赖项是不允许的，并在检查阶段标记为错误。"

#: ../scilla-in-depth.rst:2345
msgid "Local Development with User-defined Libraries"
msgstr "使用用户自定义库进行本地开发"

#: ../scilla-in-depth.rst:2347
msgid ""
"To use variables and functions declared in an external (user-defined) "
"library module, the command line argument to the Scilla executables must "
"include a ``-libdir`` option, along with a list of directories  as an "
"argument. If the Scilla file imports a library ``ALib``, then the Scilla "
"executable will search for a library file called ``ALib.scillib`` in the "
"directories provided. If more than one directory contains a file with the"
" correct name, then the directories are given priority in the same order "
"as they are provided to the Scilla executable. Alternatively, the "
"environment variable ``SCILLA_STDLIB_PATH`` can be set to a list of "
"library directories."
msgstr "要使用在外部（用户定义）库模块中声明的变量和函数，Scilla 可执行文件的命令行参数必须包含 ``-libdir`` 选项，以及作为参数的目录列表。 如果 Scilla 文件导入库 ``ALib``，则 Scilla 可执行文件将在提供的目录中搜索名为 ``ALib.scillib`` 的库文件。 如果多个目录包含具有正确名称的文件，则这些目录的优先级与它们提供给 Scilla 可执行文件的顺序相同。 或者，可以将环境变量 ``SCILLA_STDLIB_PATH`` 设置为库目录列表。"

#: ../scilla-in-depth.rst:2355
msgid ""
"``scilla-checker`` typechecks library modules in the same way as contract"
" modules. Similarly, ``scilla-runner`` can deploy libraries. Note that "
"``scilla-runner`` takes a ``blockhain.json`` as argument (the way it does"
" for :ref:`Contract Creation <calling-interface>`) to be command line "
"argument compatible with contract creation."
msgstr "``scilla-checker`` 以与合约模块相同的方式检查库模块。 同样， ``scilla-runner`` 可以部署库。 请注意， ``scilla-runner`` 将 ``blockhain.json`` 作为参数（它是 :ref:`合约创建 <calling-interface>` 所使用的方式）作为与合约创建兼容的命令行参数。"

#: ../scilla-in-depth.rst:2361
msgid "User-defined Libraries on the Blockchain"
msgstr "区块链上的用户自定义库"

#: ../scilla-in-depth.rst:2363
msgid ""
"While the Zilliqa blockchain is designed to provide the standard Scilla "
"libraries to an executing contract, it must be provided with extra "
"information to support user-defined libraries."
msgstr "虽然 Zilliqa 区块链旨在为执行合约提供标准 Scilla 库，但必须为其提供额外信息以支持用户自定义库。"

#: ../scilla-in-depth.rst:2367
msgid ""
"The ``init.json`` of a library must include a ``Bool`` entry named "
"``_library``, set to ``True``. Additionally, A contract or a library that"
" imports user-defined libraries must include in its `init.json` an entry "
"named ``_extlibs``, of Scilla type ``List (Pair String ByStr20)``. Each "
"entry in the list maps an imported library's name to its address in the "
"blockchain."
msgstr "库的 ``init.json`` 必须包含一个名为 ``_library`` 的 ``Bool`` 条目，设置为 ``True``。 此外，导入用户自定义库的合约或库必须在其 ``init.json`` 中包含一个名为 ``_extlibs`` 的条目，属于 Scilla 类型 ``List (Pair String ByStr20)``。 列表中的每个条目都将导入的库名称映射到其在区块链中的地址。"

#: ../scilla-in-depth.rst:2373
msgid ""
"Continuing the previous example, a contract or library that imports "
"``Examplelib`` should have the following entry in its ``init.json``:"
msgstr "继续上一个示例，导入 ``Examplelib`` 的合约或库应在其 ``init.json`` 中包含以下条目："

#: ../scilla-in-depth.rst:2400
msgid "Namespaces"
msgstr "命名空间"

#: ../scilla-in-depth.rst:2401
msgid ""
"Import statements can be used to define separate namespaces for imported "
"names. To push the names from a library ``Foo`` into the namespace "
"``Bar``, use the statement ``import Foo as Bar``. Accessing a variable "
"``v`` in Foo must now be done using the qualified name ``Bar.v``. This is"
" useful when importing multiple libraries that define the same name."
msgstr "导入语句可用于为导入的名称定义单独的命名空间。 要将名称从库 ``Foo`` 推送到命名空间 ``Bar``，请使用语句 ``import Foo as Bar``。 现在必须使用限定名称 ``Bar.v`` 来访问 ``Foo`` 中的变量 ``v``。 这在导入多个定义相同名称的库时很有用。"

#: ../scilla-in-depth.rst:2406
msgid ""
"The same variable name must not be defined more than once in the same "
"namespace, so if multiple imported libraries define the same name, then "
"at most one of the libraries may reside in the default (unqualified) "
"namespace. All other conflicting libraries must be pushed to separate "
"namespaces."
msgstr "同一个变量名不能在同一个命名空间中定义多次，因此如果多个导入的库定义了相同的名称，那么最多一个库可以驻留在默认（非限定）命名空间中。 所有其他冲突的库必须推送到单独的命名空间。"

#: ../scilla-in-depth.rst:2411
msgid ""
"Extending our previous example, shown below is a contract that imports "
"``ExampleLib`` in namespace ``Bar``, to use the function "
"``add_if_equal``."
msgstr "扩展我们之前的示例，如下所示是一个为了使用函数 ``add_if_equal`` 而在命名空间 ``Bar`` 中导入 ``ExampleLib`` 的合约。"

#: ../scilla-in-depth.rst:2430
msgid "Scilla versions"
msgstr "Scilla 版本"

#: ../scilla-in-depth.rst:2434
msgid "Major and Minor versions"
msgstr "主要和次要版本"

#: ../scilla-in-depth.rst:2436
msgid ""
"Scilla releases have a major version, minor version and a patch number, "
"denoted as ``X.Y.Z`` where ``X`` is the major version, ``Y`` is the minor"
" version, and ``Z`` the patch number."
msgstr "Scilla 版本有一个主要版本、次要版本和补丁号，表示为 ``X.Y.Z``，其中 ``X`` 是主要版本，``Y`` 是次要版本，``Z`` 是补丁号。"

#: ../scilla-in-depth.rst:2440
msgid ""
"Patches are usually bug fixes that do not impact the behaviour of "
"existing contracts. Patches are backward compatible."
msgstr "补丁通常是不影响现有合约行为的错误修复。 补丁向后兼容。"

#: ../scilla-in-depth.rst:2443
msgid ""
"Minor versions typically include performance improvements and feature "
"additions that do not affect the behaviour of existing contracts. Minor "
"versions are backward compatible until the latest major version."
msgstr "次要版本通常包括不影响现有合约行为的性能改进和功能添加。 次要版本向后兼容，直到最新的主要版本。"

#: ../scilla-in-depth.rst:2448
msgid ""
"Major versions are not backward compatible. It is expected that miners "
"have access to implementations of each major version of Scilla for "
"running contracts set to that major version."
msgstr "主要版本不向后兼容。 我们希望矿工可以访问 Scilla 的每个主要版本的实现，以运行设置为该主要版本的合约。"

#: ../scilla-in-depth.rst:2452
msgid ""
"Within a major version, miners are advised to use the latest minor "
"revision."
msgstr "在主要版本中，建议矿工使用最新的小版本。"

#: ../scilla-in-depth.rst:2455
msgid ""
"The command ``scilla-runner -version`` will print major, minor and patch "
"versions of the interpreter being invoked."
msgstr "命令 ``scilla-runner -version`` 将打印被调用的解释器的主要、次要和补丁版本。"

#: ../scilla-in-depth.rst:2460
msgid "Contract Syntax"
msgstr "合约语法"

#: ../scilla-in-depth.rst:2462
msgid ""
"Every Scilla contract must begin with a major version declaration. The "
"syntax is shown below:"
msgstr "每个 Scilla 合约都必须以主要版本声明开始。 语法如下所示："

#: ../scilla-in-depth.rst:2490
msgid ""
"When deploying a contract the output of the interpreter contains the "
"field ``scilla_version : X.Y.Z``, to be used by the blockchain code to "
"keep track of the version of the contract. Similarly, ``scilla-checker`` "
"also reports the version of the contract on a successful check."
msgstr "部署合约时，解释器的输出包含字段 ``scilla_version : X.Y.Z``，区块链代码将使用该字段来跟踪合约的版本。 同样， ``scilla-checker`` 也会在检查成功时报告合约的版本。"

#: ../scilla-in-depth.rst:2497
msgid "The ``init.json`` file"
msgstr "``init.json`` 文件"

#: ../scilla-in-depth.rst:2499
msgid ""
"In addition to the version specified in the contract source code, it is "
"also required that the contract's ``init.json`` specifies the same "
"version when the contract is deployed and when the contract's transitions"
" are invoked. This eases the process for the blockchain code to decide "
"which interpreter to invoke."
msgstr "除了合约源代码中指定的版本外，还要求合约的 ``init.json`` 在部署合约和调用合约 transition 时指定相同的版本。 这简化了区块链代码决定调用哪个解释器的过程。"

#: ../scilla-in-depth.rst:2505
msgid ""
"A mismatch in the versions specified in ``init.json`` and the source code"
" will lead to a gas-charged error by the interpreter."
msgstr "``init.json`` 和源代码中指定的版本不匹配将导致解释器产生 gas-charged 错误。"

#: ../scilla-in-depth.rst:2508
msgid "An example ``init.json``:"
msgstr "``init.json`` 示例："

#: ../scilla-in-depth.rst:2527
msgid "Chain Calls"
msgstr "链式调用"

#: ../scilla-in-depth.rst:2530
msgid ""
"When a user invokes a transition on a contract by sending a message with "
"the contract's address as the recipient, then that transition may then "
"send one or more messages onwards, possibly invoking other transitions on"
" other contracts. The resulting collection of messages, fund transfers, "
"transition invocations, and contract state changes are referred to as a "
"*transaction*."
msgstr "当用户通过发送以合约地址作为接收者的消息来调用合约的 transition 时，那么该 transition  可能会继续发送一条或多条消息，也可能会调用其他合约的其他 transition。 由此产生的消息、资金转移、transition 调用和合约状态更改的集合称为 *交易*。"

#: ../scilla-in-depth.rst:2537
msgid ""
"A transition that sends a message invoking another transition (typically "
"on another contract) is referred to as a *chain call*."
msgstr "发送消息调用另一个 transition （通常在另一个合约上）的 transition 称为 *链式调用*。"

#: ../scilla-in-depth.rst:2540
msgid ""
"During a transaction a LIFO queue (i.e., a stack) of unprocessed messages"
" is maintained. Initially, the message queue contains only the single "
"message sent by the original user, but additional messages may be added "
"to the queue when a transition performs a chain call."
msgstr "在交易期间，维护未处理消息的 LIFO 队列（即堆栈）。 最初，消息队列仅包含原始用户发送的单个消息，但当 transition 执行链式调用时，可能会向队列中添加其他消息。"

#: ../scilla-in-depth.rst:2545
msgid ""
"When a transition finishes, its outgoing messages are added to the "
"message queue. The first message in the queue is then removed from the "
"queue for processing. If there are no messages left to process, then the "
"transaction finishes, and all state changes and fund transfers are "
"committed to the blockchain."
msgstr "当 transition 完成时，它的传出消息被添加到消息队列中。 然后从队列中删除队列中的第一条消息以进行处理。 如果没有消息要处理，则交易完成，所有状态更改和资金转移都提交到区块链。"

#: ../scilla-in-depth.rst:2551
msgid ""
"When a transition sends multiple messages, the messages are added to the "
"queue in the following order:"
msgstr "当 transition 发送多条消息时，消息按以下顺序添加到队列中："

#: ../scilla-in-depth.rst:2554
msgid ""
"If multiple ``send`` statements are executed, then the messages of the "
"last ``send`` are added first. This means that the messages of the first "
"``send`` get processed first."
msgstr "如果执行多条 ``send`` 语句，则最后一次 ``send`` 的消息最先添加。 这意味着首先处理第一次 ``send`` 的消息。"

#: ../scilla-in-depth.rst:2558
msgid ""
"If a ``send`` statement is given a list with multiple messages in it, "
"then the head of the list is added to the queue before the messages in "
"the tail of the list are added. This means that the last message in the "
"list (the one that that was added to the list first) gets processed "
"first."
msgstr "如果给 ``send`` 语句提供了一个包含多条消息的列表，则在添加列表尾部的消息之前，将列表的头部添加到队列中。 这意味着列表中的最后一条消息（首先添加到列表中的消息）首先得到处理。"

#: ../scilla-in-depth.rst:2564
msgid ""
"Any run-time failure during the execution of a transaction causes the "
"entire transaction to be aborted, with no further statements being "
"executed, no further messages being processed, all state changes being "
"rolled back, and all transferred funds returned to their respective "
"senders. However, gas is still charged for the transcaction up until the "
"point of the failure."
msgstr "交易执行期间的任何运行时故障都会导致整个交易中止，不再执行进一步的语句，不再处理进一步的消息，回滚所有状态更改，并将所有转移的资金返还给各自的发送者。 然而，直到故障点为止，仍然会为交易收取 gas 费用。"

#: ../scilla-in-depth.rst:2571
msgid ""
"The total number of messages that can be sent in a single transaction is "
"currently set at 10. The number is subject to revision in the future."
msgstr "单笔交易可以发送的消息总数目前设置为 10。该数字将来可能会进行修订。"

#: ../scilla-in-depth.rst:2575
msgid ""
"Contracts of different Scilla versions may invoke transitions on each "
"other. The semantics of message passing between contracts is guaranteed "
"to be backward compatible between major versions."
msgstr "不同 Scilla 版本的合约可能会相互调用 transition。 合约之间消息传递的语义保证在主要版本之间向后兼容。"

#: ../scilla-in-depth.rst:2581
msgid "Accounting"
msgstr ""

#: ../scilla-in-depth.rst:2583
msgid ""
"For the transfer of native ZIL funds, Scilla follows an `acceptance "
"semantics`. For a transfer to take place the funds must explicitly be "
"accepted by the recipient by executing an ``accept`` statement - it is "
"not sufficient that the sender executes a ``send`` statement."
msgstr "对于原生 ZIL 资金的转移，Scilla 遵循 `接受语义`。 要进行转账，接收方必须通过执行 ``accept`` 语句明确接受资金——仅发送方执行 ``send`` 语句是不够的。"

#: ../scilla-in-depth.rst:2588
msgid ""
"When a contract executes an ``accept`` statement the ``_amount`` of the "
"incoming message is added to the contract's ``_balance`` field. "
"Simultaneously, the ``_amount`` is deducted from the sender's balance "
"(the ``_balance`` field if the sender is a contract, or the user account "
"balance if the sender is a user)."
msgstr "当合约执行 ``accept`` 语句时，传入消息的 ``_amount`` 被添加到合约的 ``_balance`` 字段中。 同时，``_amount`` 从发送方的余额中扣除（如果发送方是合约，则是 ``_balance`` 字段，或者如果发送方是用户，则从用户账户余额中扣除）。"

#: ../scilla-in-depth.rst:2594
msgid ""
"Conversely, when a contract executes a ``send`` statement the ``_amount``"
" values of the outgoing messages are `not` deducted from the ``_balance``"
" field, because the outgoing funds have not yet been accepted by the "
"recipients."
msgstr "相反，当合约执行 ``send`` 语句时，外发消息的 ``_amount`` 值不会从 ``_balance`` 字段中扣除，因为外发资金尚未被接收者接受。"

#: ../scilla-in-depth.rst:2601
msgid ""
"A user account (i.e., an address that does not hold a contract) "
"implicitly accepts all incoming funds, but does not do so until the "
"message carrying the funds is processed."
msgstr "用户帐户（即不持有合约的地址）隐式接受所有传入资金，但在携带资金的消息被处理之前不会这样做。"

#: ../scilla-in-depth.rst:2605
msgid ""
"Using an acceptance semantics for transfers means that it is possible for"
" a transition to send out more funds than its contract's current "
"``_balance``. Care must be taken to only do so either if one or more of "
"the recipients do not accept the funds, or if one of multiple outgoing "
"messages causes a series of chain calls which results in the current "
"contract receiving (and accepting) additional funds to cover the "
"outgoings of the yet-to-be-processed messages."
msgstr "使用接受语义进行转账意味着转换有可能发送比其合约当前的 ``_balance`` 多的资金。 只有在一个或多个接收者不接受资金，或者如果多个传出消息中的一个（它会导致当前合约接收（和接受）额外资金来支付尚未处理的消息的传出）导致一系列链式调用时，才必须注意要这样做。"

#: ../scilla-in-depth.rst:2613
msgid ""
"If at any point during a transaction a recipient accepts more funds than "
"are available in the sender's balance, then a run-time error occurs, and "
"the entire transaction is aborted. In other words, no account balance may"
" drop below 0 at any point during a transaction."
msgstr "如果在交易过程中的任何时候，接收者接受的资金多于发送者余额中的可用资金，则会发生运行时错误，整个交易将被中止。 换句话说，在交易期间的任何时候，账户余额都不会低于 0。"

