# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Zilliqa Research
# This file is distributed under the same license as the scilla中文文档 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: scilla中文文档 \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-21 15:18+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../scilla-by-example.rst:2
msgid "Scilla by Example"
msgstr "Scilla实战演练"

#: ../scilla-by-example.rst:6
msgid "HelloWorld"
msgstr ""

#: ../scilla-by-example.rst:8
msgid ""
"We start off by writing a classical ``HelloWorld.scilla`` contract with "
"the following  specification:"
msgstr "首先，我们来编写具有以下规范的经典 ``HelloWorld.scilla`` 合约："

#: ../scilla-by-example.rst:12
msgid ""
"It should have an `immutable contract parameter` ``owner`` to be "
"initialized by the creator of the contract. The parameter is immutable in"
" the sense that once initialized during contract deployment, its value "
"cannot be changed. ``owner`` will be of type ``ByStr20`` (a hexadecimal "
"Byte String representing a 20 byte address)."
msgstr "此合约中有一个不可变的合约参数 ``owner`` ，由合约的创建者初始化。 该参数是不可变的，即意味着一旦在合约部署期间进行初始化，其值就无法更改。其中 ``owner`` 是 ``ByStr20`` 类型（表示 20 字节地址的十六进制字节字符串）。"

#: ../scilla-by-example.rst:18
msgid ""
"It should have a `mutable field` ``welcome_msg`` of type ``String`` "
"initialized to ``\"\"``. Mutability here refers to the possibility of "
"modifying the value of a variable even after the contract has been "
"deployed."
msgstr "此合约中有一个 ``String`` 类型的可变字段 ``welcome_msg`` 且被初始化为 ``\"\"`` 。 此处的可变性是指，即使在部署合约后也可以修改变量的值。"

#: ../scilla-by-example.rst:22
msgid ""
"The ``owner`` and **only her** should be able to modify ``welcome_msg`` "
"through an interface ``setHello``. The interface takes a ``msg`` (of type"
" ``String``) as input and  allows the ``owner`` to set the value of "
"``welcome_msg`` to ``msg``."
msgstr "``owner`` 且 **只有她** 才能够通过接口 ``setHello`` 修改 ``welcome_msg`` 。 该接口将 ``msg`` （  ``String`` 类型）作为输入，并允许 ``owner`` 将 ``welcome_msg`` 的值设置为 ``msg`` 。"

#: ../scilla-by-example.rst:27
msgid ""
"It should have an interface ``getHello`` that welcomes any caller with "
"``welcome_msg``. ``getHello`` will not take any input."
msgstr "此合约有一个接口 ``getHello`` ，允许任何带有 ``welcome_msg`` 的调用者调用。此外 ``getHello`` 不会接受任何输入。"

#: ../scilla-by-example.rst:32
msgid "Defining a Contract, its Immutable Parameters and Mutable Fields"
msgstr "定义合约、不可变参数和可变字段"

#: ../scilla-by-example.rst:34
msgid ""
"A contract is declared using the ``contract`` keyword that starts the "
"scope of the contract. The keyword is followed by the name of the "
"contract which will be ``HelloWorld`` in our example. So, the following "
"code fragment declares a ``HelloWorld`` contract."
msgstr "我们将使用关键字 ``contract`` 来作为声明一个合约的开始。 关键字后跟合约的名称，而在我们的示例中就是 ``HelloWorld`` 。 综上，以下代码片段声明了一个 ``HelloWorld`` 合约。"

#: ../scilla-by-example.rst:46
msgid ""
"In the current implementation, a Scilla contract can only contain a "
"single contract declaration and hence any code that follows the "
"``contract`` keyword is part of the contract declaration. In other words,"
" there is no explicit keyword to declare the end of the contract "
"definition."
msgstr "在目前的实现中，一个 Scilla 合约只能包含一个单一的合约声明，因此任何跟在 ``contract`` 关键字之后的代码都是合约声明的一部分。 换句话说，没有明确的关键字来声明合约定义的结束。"

#: ../scilla-by-example.rst:53
msgid ""
"A contract declaration is followed by the declaration of its immutable "
"parameters, the scope of which is defined by ``()``. Each immutable "
"parameter is declared in the following way: ``vname: vtype``, where "
"``vname`` is the parameter name and ``vtype`` is the parameter type. "
"Immutable parameters are separated by ``,``. As per the specification, "
"the contract will have only one immutable parameter ``owner`` of type "
"``ByStr20`` and hence the following code fragment."
msgstr "声明合约后，接下来是其不可变参数的声明，其代码块由 ``()`` 包裹。 每个不可变参数都通过以下方式声明： ``vname: vtype`` ，其中 ``vname`` 是参数名称，``vtype`` 是参数类型。 不可变参数由 ``,`` 分隔。 根据规范，合约将只有一个 ``ByStr20`` 类型的不可变参数 ``owner`` ，具体参考以下代码片段。"

#: ../scilla-by-example.rst:66
msgid ""
"Mutable fields in a contract are declared through keyword ``field``. Each"
" mutable field is declared in the following way: ``field vname : vtype = "
"init_val``, where ``vname`` is the field name, ``vtype`` is its type and "
"``init_val`` is the value to which the field has to be initialized. The "
"``HelloWorld`` contract has one mutable field ``welcome_msg`` of type "
"``String`` initialized to ``\"\"``. This yields the following code "
"fragment:"
msgstr "合约中的可变字段通过关键字 ``field`` 声明。 每个可变字段以下列方式声明： ``field vname : vtype = init_val`` ，其中 ``vname`` 是字段名称，``vtype`` 是它的类型，``init_val`` 是字段必须被初始化的值。 ``HelloWorld`` 合约有一个 ``String`` 类型的可变字段 ``welcome_msg`` ，且被初始化为 ``\"\"`` 。 具体实现参考以下代码片段："

#: ../scilla-by-example.rst:78
msgid ""
"At this stage, our ``HelloWorld.scilla`` contract will have the following"
" form that includes the contract name, its immutable parameters and "
"mutable fields:"
msgstr "在此阶段，我们的 ``HelloWorld.scilla`` 合约将具有以下形式，其中包括合约名称、不可变参数和可变字段："

#: ../scilla-by-example.rst:92
msgid "Defining Interfaces `aka` Transitions"
msgstr "定义接口即Transitions"

#: ../scilla-by-example.rst:94
msgid ""
"Interfaces like ``setHello`` are referred to as `transitions` in Scilla. "
"Transitions are similar to `functions` or `methods` in other languages. "
"There is an important difference, however, most languages allow their "
"functions or methods to be \"interrupted\" by a thread running in "
"parallel, but Scilla won't let a transition to be interrupted ensuring "
"there is no so-called reentrancy issues."
msgstr "像 ``setHello`` 这样的接口在 Scilla 中被称为 `transitions` 。 Transitions类似于其他语言中的函数或方法。 然而，他们有一个重要的区别，大多数语言允许它们的函数或方法被并行运行的线程\"中断\" ，但 Scilla 不会让transitions被中断，以此来确保不会出现所谓的重入问题。"

#: ../scilla-by-example.rst:104
msgid ""
"The term `transition` comes from the underlying computation model in "
"Scilla which follows a communicating automaton. A contract in Scilla is "
"an automaton with some state. The state of an automaton can be changed "
"using a transition that takes a previous state and an input and yields a "
"new state. Check the `wikipedia entry "
"<https://en.wikipedia.org/wiki/Transition_system>`_ to read more about "
"transition systems."
msgstr "术语 `transition` 来自 Scilla 中的底层计算模型，它遵循通信自动机。 Scilla 中的合约是具有某种状态的自动机。 自动机的状态可以使用 `transition` 来更改，该 `transition` 采用先前状态和输入并产生新的状态。 访问 `维基百科条目 <https://en.wikipedia.org/wiki/Transition_system>`_ 以阅读有关 `transition` 系统的更多信息。"

#: ../scilla-by-example.rst:111
msgid ""
"A transition is declared using the keyword ``transition``. The end of a "
"transition scope is declared using the keyword ``end``. The "
"``transition`` keyword is followed by the transition name, which is "
"``setHello`` for our example. Then follows the input parameters within "
"``()``. Each input parameter is separated by a ``,`` and is declared in "
"the following format: ``vname : vtype``.  According to the specification,"
" ``setHello`` takes only one parameter of name ``msg`` of type "
"``String``.  This yields the following code fragment:"
msgstr "使用关键字 ``transition`` 声明一个 `transition` 。 使用关键字 ``end`` 声明 `transition` 代码块的结束。 ``transition`` 关键字后跟 `transition` 名称，在我们的示例中为 ``setHello`` 。 然后是 ``()`` 内的输入参数。 每个输入参数由 ``,`` 分隔，并以以下格式声明：  ``vname : vtype`` 。 根据规范， ``setHello`` 只接受一个 ``String`` 类型的名为 ``msg`` 的参数。具体参照以下代码片段："

#: ../scilla-by-example.rst:123
msgid ""
"What follows the transition signature is the body of the transition. Code"
" for the first transition ``setHello (msg :  String)`` to set "
"``welcome_msg`` is given below:"
msgstr "transition 声明之后是 transition 的主体部分。 下面给出了第一个transition的代码段，此代码段为调用 ``setHello (msg :  String)`` 以设置 ``welcome_msg`` ："

#: ../scilla-by-example.rst:144
msgid ""
"At first, the caller of the transition is checked against the ``owner`` "
"using the instruction ``builtin eq owner _sender`` in ``Line 2``. In "
"order to compare two addresses, we are using the function ``eq`` defined "
"as a ``builtin`` operator. The operator returns a Boolean value ``True`` "
"or ``False``."
msgstr "首先，使用第 2 行中的指令 ``builtin eq owner _sender`` 来检查 transition 的调用者是否与  ``owner`` 相等。为了比较两个地址，我们使用定义为函数 ``eq`` 的 ``builtin`` 运算符。 该运算符返回布尔值 ``True`` 或 ``False`` 。"

#: ../scilla-by-example.rst:152
msgid ""
"Scilla internally defines some variables that have special semantics. "
"These special variables are often prefixed by ``_``. For instance, "
"``_sender`` in Scilla refers to the account address that called the "
"current contract."
msgstr "Scilla 内部定义了一些具有特殊语义的变量。 这些特殊变量通常以  ``_`` 为前缀。 例如，Scilla 中的 ``_sender`` 是指调用当前合约的帐户地址。"

#: ../scilla-by-example.rst:156
msgid ""
"Depending on the output of the comparison, the transition takes a "
"different path declared using `pattern matching`, the syntax of which is "
"given in the fragment below."
msgstr "根据比较的结果，transition 通过不同的分支来进行模式匹配，其语法如下面的代码片段所示。"

#: ../scilla-by-example.rst:167
msgid ""
"The above code checks whether ``expr`` evaluates to a value that matches "
"``pattern_1`` or ``pattern_2``. If ``expr`` evaluates to a value matching"
" ``pattern_1``, then the next expression to be evaluated will be "
"``expr_1``.  Otherwise, if ``expr`` evaluates to a value matching "
"``pattern_2``, then the next expression to be evaluated will be "
"``expr_2``."
msgstr "上面的代码检查 ``expr`` 的计算结果是否与 ``pattern_1`` 或  ``pattern_2`` 匹配。 如果 ``expr`` 的计算结果与 ``pattern_1`` 匹配，那么接下来要执行的表达式将是 ``expr_1`` 。 否则，如果 ``expr`` 的计算结果与 ``pattern_2`` 匹配，那么接下来要执行的表达式就是 ``expr_2`` 。"

#: ../scilla-by-example.rst:174
msgid ""
"Hence, the following code block implements an ``if-then-else`` "
"instruction:"
msgstr "因此，以下代码块实现了类似于 ``if-then-else`` 的指令："

#: ../scilla-by-example.rst:185
msgid "The Caller is Not the Owner"
msgstr "调用者不是所有者"

#: ../scilla-by-example.rst:187
msgid ""
"In case the caller is different from ``owner``, the transition takes the "
"``False`` branch and the contract emits an event using the instruction "
"``event``."
msgstr "如果调用者与 ``owner`` 不同，则 transition 会进入 ``False`` 分支，即合约使用指令 ``event`` 来触发一个事件。"

#: ../scilla-by-example.rst:191
msgid ""
"An event is a signal that gets stored on the blockchain for everyone to "
"see. If a user uses a client application to invoke a transition on a "
"contract, the client application can listen for events that the contract "
"may emit, and alert the user."
msgstr "事件是指存储在区块链上供所有人查看的信号。 如果用户使用客户端应用程序调用合约的 transition，客户端应用程序就可以监听合约可能触发的事件，并提醒用户。"

#: ../scilla-by-example.rst:196
msgid "More concretely, the output event in this case is:"
msgstr "更具体地说，这种情况下的事件代码如下："

#: ../scilla-by-example.rst:202
msgid ""
"An event is comprised of a number of ``vname : value`` pairs delimited by"
" ``;`` inside a pair of curly braces ``{}``. An event must contain the "
"compulsory field ``_eventname``, and may contain other fields such as the"
" ``code`` field in the example above."
msgstr "一个事件由许多 ``vname : value`` 对组成，并由 ``;`` 分隔。 在一对花括号 ``{}`` 内。 一个事件必须包含必填字段  ``_eventname`` ，同时也可以包含其他字段，例如上面示例中的  ``code``  字段。"

#: ../scilla-by-example.rst:209
msgid ""
"In our example we have chosen to name the event after the transition that"
" emits the event, but any name can be chosen. However, it is recommended "
"that you name the events in a way that makes it easy to see which part of"
" the code emitted the event."
msgstr "在我们的示例中，我们选择使用 transition 的名称来命名事件的名称，但时你可以选择任何其他名称。 不过呢，还是建议你以易读性为标准来命名，即使用执行事件的那部分代码的名称来命名事件。"

#: ../scilla-by-example.rst:219
msgid "The Caller is the Owner"
msgstr "调用者是所有者"

#: ../scilla-by-example.rst:221
msgid ""
"In case the caller is ``owner``, the contract allows the caller to set "
"the value of the mutable field ``welcome_msg`` to the input parameter "
"``msg``. This is done through the following instruction:"
msgstr "如果调用者是 ``owner`` ，则合约允许调用者将可变字段 ``welcome_msg`` 的值设置为输入参数 ``msg`` 。 这些是通过以下指令完成的："

#: ../scilla-by-example.rst:233
msgid "Writing to a mutable field is done using the operator ``:=``."
msgstr "给可变字段赋值是使用运算符 ``:=`` 完成的。"

#: ../scilla-by-example.rst:236
msgid ""
"And as in the previous case, the contract then emits an event with the "
"code ``set_hello_code``."
msgstr "和前面的例子一样，合约随后会触发一个 code 值为  ``set_hello_code`` 的事件。"

#: ../scilla-by-example.rst:241
msgid "Libraries"
msgstr "库定义"

#: ../scilla-by-example.rst:243
msgid ""
"A Scilla contract may come with some helper libraries that declare purely"
" functional components of a contract, i.e., components with no state "
"manipulation. A library is declared in the preamble of a contract using "
"the keyword ``library`` followed by the name of the library. In our "
"current example a library declaration would look as follows:"
msgstr "Scilla 合约会有一些辅助库，它们声明合约的纯功能组件，即没有状态操作的组件。 使用关键字 ``library`` 然后跟上库名称，就完成了在合约的开始部分中库的声明。 在我们当前的示例中，库声明如下所示："

#: ../scilla-by-example.rst:254
msgid ""
"The library may include utility functions and program constants using the"
" ``let ident = expr`` construct. In our example the library will only "
"include the definition of error codes:"
msgstr "该库可能包含使用 ``let ident = expr`` 定义的效用函数和程序常量。 在我们的示例中，库定义的部分只包含错误代码的定义："

#: ../scilla-by-example.rst:263
msgid "At this stage, our contract fragment will have the following form:"
msgstr "到这里为止，我们的合约片段会变成下面这个样子："

#: ../scilla-by-example.rst:293
msgid "Adding Another Transition"
msgstr "增加另一个 Transition"

#: ../scilla-by-example.rst:295
msgid ""
"We may now add the second transition ``getHello()`` that allows client "
"applications to know what the ``welcome_msg`` is. The declaration is "
"similar to ``setHello (msg : String)`` except that ``getHello()`` does "
"not take a parameter."
msgstr "我们现在可以增加第二个 transition  ``getHello()`` ，它允许客户端应用程序知道 ``welcome_msg`` 是什么。 声明与 ``setHello (msg : String)`` 类似，只是 ``getHello()`` 不带参数。"

#: ../scilla-by-example.rst:310
msgid ""
"Reading from a local mutable field, i.e., a field defined in the current "
"contract, is done using the operator ``<-``."
msgstr "读取到本地可变字段（即将当前合约中定义的字段读取到本地）是使用运算符 ``<-`` 完成的。"

#: ../scilla-by-example.rst:312
msgid ""
"In the ``getHello()`` transition, we will first read from a mutable "
"field, and then we construct and emit the event."
msgstr "在 transition  ``getHello()``  中，我们将首先从可变字段中读取，然后构造并触发事件。"

#: ../scilla-by-example.rst:317
msgid "Scilla Version"
msgstr "Scilla 版本号"

#: ../scilla-by-example.rst:319
msgid ""
"Once a contract has been deployed on the network, it cannot be changed. "
"It is therefore necessary to specify which version of Scilla the contract"
" is written in, so as to ensure that the behaviour of the contract does "
"not change even if changes are made to the Scilla specification."
msgstr "合约一旦在网络上部署，就无法更改。 因此需要指定合约是用哪个版本的 Scilla 编写的，以确保即使对 Scilla 规范进行更改，合约的行为也不会改变。"

#: ../scilla-by-example.rst:325
msgid ""
"The Scilla version of the contract is declared using the keyword "
"``scilla_version``:"
msgstr "合约的 Scilla 版本是使用关键字 ``scilla_version`` 声明的："

#: ../scilla-by-example.rst:332
msgid "The version declaration must appear before any library or contract code."
msgstr "版本声明必须出现在任何库或合约代码之前。"

#: ../scilla-by-example.rst:337 ../scilla-by-example.rst:658
#: ../scilla-by-example.rst:1720
msgid "Putting it All Together"
msgstr "代码完整示例"

#: ../scilla-by-example.rst:339
msgid ""
"The complete contract that implements the desired specification is given "
"below, where we have added comments using the ``(* *)`` construct:"
msgstr "下面给出了实现所需规范的完整合约，其中我们使用  ``(* *)``  结构添来添加注释："

#: ../scilla-by-example.rst:392
msgid "A Second Example: Crowdfunding"
msgstr "示例二：众筹"

#: ../scilla-by-example.rst:394
msgid ""
"In this section, we present a slightly more involved contract that runs a"
" crowdfunding campaign. In a crowdfunding campaign, a project owner "
"wishes to raise funds through donations from the community."
msgstr "在本节中，我们展示了一个运行众筹活动的稍微复杂的合约。 在众筹活动中，项目所有者希望通过社区捐款筹集资金。"

#: ../scilla-by-example.rst:398
msgid ""
"It is assumed that the owner (``owner``) wishes to run the campaign until"
" a certain, predetermined block number is reached on the blockchain "
"(``max_block``). The owner also wishes to raise a minimum amount of QA "
"(``goal``) without which the project can not be started. The contract "
"hence has three immutable parameters ``owner``, ``max_block`` and "
"``goal``."
msgstr "假设所有者（ ``owner`` ）希望一直运行该活动，直到在区块链（ ``max_block`` ）上达到某个预定的区块高度。 所有者还希望提高最低数量的 QA（ ``goal`` ），否则项目将无法启动。 因此，合约具有三个不可变参数 ``owner`` 、 ``max_block`` 和 ``goal`` 。"

#: ../scilla-by-example.rst:405
msgid ""
"The immutable parameters are provided when the contract is deployed. At "
"that point we wish to add a sanity check that the ``goal`` is a strictly "
"positive amount. If the contract is accidentally initialised with a "
"``goal`` of 0, then the contract should not be deployed."
msgstr "不可变参数会在部署合约时提供。 在这一点上，我们希望添加一个合理性检查，其中  ``goal``  必须是一个严格意义上的正数。 如果合约中的  ``goal``  意外地以 0 值进行初始化，则该合约就不会被部署。"

#: ../scilla-by-example.rst:410
msgid ""
"The total amount that has been donated to the campaign so far is stored "
"in a field ``_balance``. Any contract in Scilla has an implicit "
"``_balance`` field of type ``Uint128``, which is initialised to 0 when "
"the contract is deployed, and which holds the amount of QA in the "
"contract's account on the blockchain."
msgstr "到目前为止，捐赠给该活动的总金额存储在字段 ``_balance`` 中。Scilla中的任何合约都有一个隐式的 ``_balance`` 字段，类型为  ``Uint128`` ，在合同部署时初始化为0，它包含了区块链上合约账户中QA的数量。"

#: ../scilla-by-example.rst:416
msgid ""
"The campaign is deemed successful if the owner can raise the goal in the "
"stipulated time. In case the campaign is unsuccessful, the donations are "
"returned to the project backers who contributed during the campaign. The "
"backers are supposed to ask for refund explicitly."
msgstr "如果所有者能在规定的时间内达到目标，则视为众筹成功。如果众筹失败，捐款将返还给在竞选期间捐款的项目支持者。并且需要支持者有明确要求退款的操作。"

#: ../scilla-by-example.rst:421
msgid "The contract maintains two mutable fields:"
msgstr "合约包含两个可变字段："

#: ../scilla-by-example.rst:423
msgid ""
"``backers``: a field map from a contributor's address (a ``ByStr20`` "
"value) to the amount contributed, represented with a ``Uint128`` value. "
"Since there are no backers initially, this map is initialized to an "
"``Emp`` (empty) map. The map enables the contract to register a donor, "
"prevent multiple donations and to refund back the money if the campaign "
"does not succeed."
msgstr "``backers`` ：从贡献者地址（类型为 ``ByStr20`` 的值）到贡献金额的字段映射，用类型为 ``Uint128`` 的值表示。 由于最初没有支持者，因此此映射被初始化为 ``Emp``（即空）映射。 该映射使合约能够注册捐赠者，以此防止重复捐赠并在活动失败时可以退还资金。"

#: ../scilla-by-example.rst:430
msgid ""
"``funded``:  a Boolean flag initialized to ``False`` that indicates "
"whether the owner has already transferred the funds after the end of the "
"campaign."
msgstr "``funded`` ：一个布尔值的标志，初始化为 ``False`` ，指所有者是否已经在活动结束后转移了资金。"

#: ../scilla-by-example.rst:434
msgid ""
"The contract contains three transitions: ``Donate ()`` that allows anyone"
" to contribute to the crowdfunding campaign, ``GetFunds ()`` that allows "
"**only the owner** to claim the donated amount and transfer it to "
"``owner`` and ``ClaimBack()`` that allows contributors to claim back "
"their donations in case the campaign is not successful."
msgstr "该合约包含三个 transitions ： ``Donate ()`` 允许任何人为众筹活动捐款， ``GetFunds ()`` **仅允许所有者**提取捐赠金额并将其转账给 ``owner``  ，以及 ``ClaimBack()`` 允许贡献者在活动不成功时取回他们的捐款 。"

#: ../scilla-by-example.rst:441
msgid "Sanity check for contract parameters"
msgstr "合约参数的合理性检查"

#: ../scilla-by-example.rst:443
msgid ""
"To ensure that the ``goal`` is a strictly positive amount, we use a "
"`contract constraint`:"
msgstr "为了确保  ``goal``  是一个严格的正数，我们使用了一个合约约束："

#: ../scilla-by-example.rst:453
msgid ""
"The Boolean expression between ``with`` and ``=>`` above is evaluated "
"during contract deployment and the contract only gets deployed if the "
"result of evaluation is ``True``. This ensures that the contract cannot "
"be deployed with a ``goal`` of 0 by mistake."
msgstr "上面 ``with`` 和 ``=>`` 之间的布尔表达式在合约部署期间进行判断，只有判断结果为 ``True`` 时才会部署合约。 这确保了合约不会被错误地将 ``goal`` 的值以 0 的进行部署。"

#: ../scilla-by-example.rst:460
msgid "Reading the Current Block Number"
msgstr "读取当前区块高度"

#: ../scilla-by-example.rst:462
msgid ""
"The deadline is given as a block number, so to check whether the deadline"
" has passed, we must compare the deadline against the current block "
"number."
msgstr "截止日期以区块高度给出，因此要检查是否已过截止日期，我们必须将截止日期与当前区块高度进行比较。"

#: ../scilla-by-example.rst:466
msgid "The current block number is read as follows:"
msgstr "当前块高度读取如下："

#: ../scilla-by-example.rst:472
msgid ""
"Block numbers have a dedicated type ``BNum`` in Scilla, so as to not "
"confuse them with regular unsigned integers."
msgstr "区块高度在 Scilla 中有一个专用类型  ``BNum``  ，以免将它们与常规无符号整数混淆。"

#: ../scilla-by-example.rst:477
msgid ""
"Reading data from the blockchain is done using the operator ``<- &``. "
"Blockchain data cannot be updated directly from the contract."
msgstr "从区块链读取数据是使用运算符  ``<- &`` 完成的。 且区块链数据不能直接从合约中更新。"

#: ../scilla-by-example.rst:483
msgid "Reading and Updating the Current Balance"
msgstr "读取以及更新当前余额"

#: ../scilla-by-example.rst:485
msgid ""
"The target for the campaign is specified by the owner in the immutable "
"parameter ``goal`` when the contract is deployed. To check whether the "
"target have been met, we must compare the total amount raised to the "
"target."
msgstr "在部署合约时，活动的目标由所有者在不可变参数  ``goal``  中指定。 要检查是否达到目标，我们必须将筹集的总额与目标进行比较。"

#: ../scilla-by-example.rst:490
msgid ""
"The amount of QA raised is stored in the contract's account on the "
"blockchain, and can be accessed through the implicitly declared "
"``_balance`` field as follows:"
msgstr "QA 筹集的金额存储在区块链上的合约账户中，可以通过隐式声明的 ``_balance`` 字段访问，如下所示："

#: ../scilla-by-example.rst:498
msgid "Money is represented as values of type ``Uint128``."
msgstr "Money 表示为 ``Uint128`` 类型的值。"

#: ../scilla-by-example.rst:502
msgid ""
"The ``_balance`` field is read using the operator ``<-`` just like any "
"other contract field. However, the ``_balance`` field can only be updated"
" by accepting money from incoming messages (using the instruction "
"``accept``), or by explicitly transferring money to other account (using "
"the instruction ``send`` as explained below)."
msgstr "像任何其他合约字段一样， ``_balance``  字段是使用运算符 ``<-`` 读取的。 但是， ``_balance`` 字段只能通过接受来自传入 messages 的资金（使用指令 ``accept`` ）或通过明确地将资金转移到其他帐户（使用如下所述的  ``send``  指令）来更新。"

#: ../scilla-by-example.rst:511
msgid "Sending Messages"
msgstr "发送 Messages"

#: ../scilla-by-example.rst:513
msgid ""
"In Scilla, there are two ways that transitions can transmit data. One way"
" is through events, as covered in the previous example. The other is "
"through the sending of messages using the instruction ``send``."
msgstr "在 Scilla 中， transitions 可以通过两种方式传输数据。 一种方法是通过 events ，如前一个示例中所述。 另一种是通过使用指令  ``send`` 发送 messages。"

#: ../scilla-by-example.rst:517
msgid ""
"``send`` is used to send messages to other accounts, either in order to "
"invoke transitions on another smart contract, or to transfer money to "
"user accounts. On the other hand, events are dispatched signals that "
"smart contracts can use to transmit data to client applications."
msgstr "``send``  用于向其他帐户发送 messages，以便调用另一个智能合约上的 transitions，或者将资金转移到用户帐户。 另一方面， events 是智能合约可以用来将数据传输到客户端应用程序的分派信号。"

#: ../scilla-by-example.rst:522
msgid ""
"To construct a message we use a similar syntax as when constructing "
"events:"
msgstr "要定义 message，我们可以使用与定义 events 时类似的语法："

#: ../scilla-by-example.rst:529
msgid ""
"A message must contain the compulsory `message fields` ``_tag``, "
"``_recipient`` and ``_amount``. The ``_recipient`` message field is the "
"blockchain address (of type ``ByStr20``) that the message is to be sent "
"to, and the ``_amount`` message field is the number of QA to be "
"transferred to that account."
msgstr "message 必须包含必填的 message 字段 ``_tag`` 、``_recipient`` 和 ``_amount`` 。 ``_recipient`` 字段是消息要发送到的区块链地址（类型为 ``ByStr20`` ）， ``_amount`` 字段是要转移到该帐户的 QA 数量。"

#: ../scilla-by-example.rst:534
msgid ""
"The value of the ``_tag`` message field is the name of the transition (of"
" type ``String``) that is to be invoked on the contract deployed at "
"``_recipient`` address. If ``_recipient`` is the address of a user "
"account then the value of ``_tag`` is ignored, hence for simplicity we "
"put ``\"\"`` here."
msgstr "``_tag`` 字段的值表示的是要部署在 ``_recipient`` 地址的合约调用的 transition（  ``String`` 类型）的名称。 如果 ``_recipient`` 是用户帐户的地址，则忽略 ``_tag`` 的值，因此为简单起见，我们这里定义为空， 即 ``\"\"`` 。"

#: ../scilla-by-example.rst:541
msgid ""
"To make it possible to refund both contracts and user accounts (this is "
"useful if a backer used a wallet contract to donate), use a standard "
"transition name as per `ZRC-5 "
"<https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-5.md>`_, i.e. "
"``AddFunds``."
msgstr "为了能够同时退还合约和用户帐户（对于使用钱包合约进行捐赠的支持者非常有用），请使用 `ZRC-5 <https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-5.md>`_ 中的标准 transition 名称，如 ``AddFunds`` 。"

#: ../scilla-by-example.rst:547
msgid ""
"In addition to the compulsory fields the message may contain other "
"fields, such as ``code`` above. However, if the message recipient is a "
"contract, the additional fields must have the same names and types as the"
" parameters of the transition being invoked on the recipient contract."
msgstr "除了必填字段之外，message 还可以包含其他字段，例如上面的代码所示。 但是，如果 message 的接收者是合约，则附加字段的名称和类型必须与在接收者合约上调用的 transition 参数相同。"

#: ../scilla-by-example.rst:553
msgid ""
"Sending a message is done using the ``send`` instruction, which takes a "
"list of messages as a parameter. Since we will only ever send one message"
" at a time in the crowdfunding contract, we define a library function "
"``one_msg`` to construct a list consisting of one message:"
msgstr "发送 message 是使用 ``send`` 指令完成的，该指令将 messages 列表作为参数。 由于我们在众筹合约中一次只会发送一条 message，因此我们定义了一个库函数 ``one_msg`` 来构造一个由 message 组成的列表："

#: ../scilla-by-example.rst:566
msgid ""
"To send out a message, we first construct the message, insert it into a "
"list, and send it:"
msgstr "要发送 message，我们首先构造 message，并将其插入列表，然后发送："

#: ../scilla-by-example.rst:577
msgid "Procedures"
msgstr "Procedures"

#: ../scilla-by-example.rst:579
msgid ""
"The transitions of a Scilla contract often need to perform the same small"
" sequence of instructions. In order to prevent code duplication a "
"contract may define a number of `procedures`, which may be invoked from "
"the contract's transitions. Procedures also help divide the contract code"
" into separate, self-contained pieces which are easier to read and reason"
" about individually."
msgstr "Scilla 合约的 transitions 通常需要执行相同的小指令序列。为了防止代码重复，合约可以定义许多 procedures，这些 procedures 可以通过合约的 transitions 调用。procedures 还有助于将合约代码分成独立的、自包含的部分，这些部分更容易阅读和单独推理。"

#: ../scilla-by-example.rst:586
msgid ""
"A procedure is declared using the keyword ``procedure``. The end of a "
"procedure is declared using the keyword ``end``. The ``procedure`` "
"keyword is followed by the transition name, then the input parameters "
"within ``()``, and then the statements of the procedure."
msgstr "使用关键字 ``procedure`` 来声明 procedure。procedure 的结束使用关键字 ``end`` 声明。 ``procedure`` 关键字后面是 transition 名称，然后是  ``()`` 中的输入参数，然后是 procedure 的语句。"

#: ../scilla-by-example.rst:591
msgid ""
"In our example the ``Donate`` transition will issue an event in three "
"situations: An error event if the donation happens after the deadline, "
"another error event if the backer has donated money previously, and a "
"non-error event indicating a successful donation. Since much of the event"
" issuing code is identical, we decide to define a procedure "
"``DonationEvent`` which is responsible for issuing the correct event:"
msgstr "在我们的示例中，名为 ``Donate``  的 transition 将在三种情况下触发一个 event ：如果捐赠在截止日期之后发生，则触发一个错误 event ；如果捐赠者以前捐赠过，则触发另一个错误 event；由于大部分 event 触发代码是相同的，我们决定定义一个名为 ``DonationEvent``  的 procedure，负责发出正确的 event："

#: ../scilla-by-example.rst:613
msgid ""
"The procedure takes two arguments: A ``Bool`` indicating whether the "
"donation failed, and an error code indicating the type of failure if a "
"failure did indeed occur."
msgstr "该 procedure 接受两个参数： 一个 ``Bool`` 类型，代表捐赠是否失败；一个代表当失败发生时，失败类型的错误代码。"

#: ../scilla-by-example.rst:617
msgid ""
"The procedure performs a ``match`` on the ``failure`` argument. If the "
"donation did not fail, the error code is ignored, and a "
"``DonationSuccess`` event is issued. Otherwise, if the donation failed, "
"then a ``DonationFailure`` event is issued with the error code that was "
"passed as the second argument to the procedure."
msgstr "procedure 会对参数  ``failure``  进行  ``match``  。如果捐赠没有失败，错误代码将被忽略，并触发一个名为 ``DonationSuccess`` 的 event。否则，如果捐赠失败，则触发一个名为 ``DonationFailure`` 的 event，该 event 带有作为 procedure 的第二个参数进行传递的错误代码。"

#: ../scilla-by-example.rst:623
msgid ""
"The following code shows how to invoke the ``DonationEvent`` procedure "
"with the arguments ``True`` and ``0``:"
msgstr "下面的代码展示了如何使用参数 ``True`` 和 ``0`` 调用名为  ``DonationEvent``  的procedure："

#: ../scilla-by-example.rst:635
msgid ""
"The special parameters ``_sender``, ``_origin`` and ``_amount`` are "
"available to a procedure even though the procedure is invoked by a "
"transition rather than by an incoming message. It is not necessary to "
"pass these special parameters as arguments to the procedure."
msgstr "特殊参数  ``_sender`` 、 ``_origin`` 和 ``_amount`` 对 procedure 是可用的，即使 procedure 是由 transition 而不是由传入消息调用的。没有必要将这些特殊参数作为实参传递给 procedure。"

#: ../scilla-by-example.rst:642
msgid ""
"Procedures are similar to library functions in that they can be invoked "
"from any transition (as long as the transition is defined after the "
"procedure). However, procedures are different from library functions in "
"that library functions cannot access the contract state, and procedures "
"cannot return a value."
msgstr "procedures 与库函数相似，它们可以从任何 transition 中调用(只要 transition 是在 procedures 之后定义的)。但是两者也有不同之处，标准库函数不能访问合约状态，procedures 不能有返回值。"

#: ../scilla-by-example.rst:648
msgid ""
"Procedures are similar to transitions in that they can access and change "
"the contract state, as well as read the incoming messages and send "
"outgoing messages. However, procedures cannot be invoked from the "
"blockchain layer. Only transitions may be invoked from outside the "
"contract, so procedures can be viewed as private transitions."
msgstr "procedures 与 transitions 有点类似，因为它们都可以访问和更改合约状态，以及读取传入消息和发送传出消息。但是，procedures 不能在链上调用，只能从合约外部调用 transitions，因此 procedures 可以被视为私有 transitions。"

#: ../scilla-by-example.rst:660
msgid "The complete crowdfunding contract is given below."
msgstr "完整的众筹合约代码如下"

#: ../scilla-by-example.rst:851
msgid "A Third Example: A Simple Token Exchange"
msgstr "示例三：代币交易所"

#: ../scilla-by-example.rst:853
msgid ""
"As a third example we look at how contracts written in Scilla can "
"interact by passing messages to each other, and by reading each other's "
"states. As our example application we choose a simplified token exchange "
"contracts in which users can place offers of swapping one type of "
"fungible tokens for another type."
msgstr "在第三个例子中，我们来看一下用 Scilla 编写的合约是如何通过相互传递消息和读取彼此的状态来进行交互的。作为我们的示例应用程序，我们选择了一个简化的代币转换合约，其中用户可以将一种类型的同质化代币交换为另一种类型。"

#: ../scilla-by-example.rst:860
msgid "Fungible Tokens"
msgstr "同质化代币"

#: ../scilla-by-example.rst:862
msgid ""
"Recall that a fungible token is one which is indistinguishable from "
"another token of the same type. For example, a US $1 bank note is "
"indistinguishable from any other US $1 bank note (for the purposes of "
"using the bank note to pay for goods, services, or other tokens, at "
"least)."
msgstr "回想一下，同质化代币是指与其他相同类型的代币难以区分的代币。例如，1美元钞票与任何其他1美元钞票没有区别(至少在用于支付商品、服务或其他代币时没有区别)。"

#: ../scilla-by-example.rst:868
msgid ""
"The `Zilliqa Reference Contracts <https://github.com/Zilliqa/ZRC>`_ "
"library offers specifications and reference implementations of commonly "
"used contract types, and the `ZRC2 "
"<https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-2.md>`_ standard "
"specifies a standard for fungible tokens, which we will use for this "
"example. We will not go into detail about how the token contract works, "
"but only point out a few important aspects that will be needed in order "
"to implement the token exchange."
msgstr "`Zilliqa 合约参考库 <https://github.com/Zilliqa/ZRC>`_ 提供了常用合约类型的规范和参考实现， `ZRC2 <https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-2.md>`_ 标准为同质化代币指定了一个标准，我们将在本例中使用它。我们不会详细讨论代币合约是如何工作的，只是指出实现代币转换所需的几个重要方面。"

#: ../scilla-by-example.rst:879
msgid "Exchange Specification"
msgstr "交易规范"

#: ../scilla-by-example.rst:881
msgid "We want our simple exchange to support the following functionality:"
msgstr "我们希望我们的简单转换支持以下功能："

#: ../scilla-by-example.rst:883
msgid ""
"The exchange has a number of listed tokens that can be freely swapped "
"with each other. Each listed token is identified by its token code (e.g.,"
" \"USD\" for US dollars)."
msgstr "该交易所有许多上市的代币，这些代币可以彼此自由转换。每个列出的代币都由其代币代简称标识(例如，“USD”表示美元)。"

#: ../scilla-by-example.rst:887
msgid ""
"The exchange should have an administrator at all times. The administrator"
" is in charge of approving token contracts, and listing them on the "
"exchange. The administrator may pass the administrator role on to someone"
" else."
msgstr "交易所应该始终有一个管理员。管理员负责批准代币合约，并将其在交易所上市。管理员可以将管理员角色传递给其他人。"

#: ../scilla-by-example.rst:892
msgid ""
"Any user can place an order on the exchange. To place an order, the user "
"specifies which token he wants to sell and how many of them he is "
"offering, and which token he wants to buy and how many he wants in "
"return. The contract keeps track of every active (unmatched) order."
msgstr "任何用户都可以在交易所下单。为了下单，用户指定他想要出售哪个代币，他提供多少代币，他想购买哪个代币，以及他想要多少代币作为回报。该合约跟踪每一个活跃的（不匹配的）订单。"

#: ../scilla-by-example.rst:898
msgid ""
"When a user attempts to place an order to sell some tokens, the exchange "
"checks that the user actually has those tokens to sell. If he does, then "
"the exchange claims those tokens and holds on to them until the order is "
"matched."
msgstr "当用户试图下单出售一些代币时，交易所会检查用户是否确实有这些代币要出售。如果他确实有，那么交易所就会索取这些代币并持有它们，直到订单匹配为止。"

#: ../scilla-by-example.rst:903
msgid ""
"Any user can match an active order on the exchange. To match an order, "
"the user specifies which order to match."
msgstr "任何用户都可以匹配交易所的活跃订单。为了匹配到订单，用户必须明确指定要匹配的订单。"

#: ../scilla-by-example.rst:906
msgid ""
"When a user attempts to match an order, the exchange checks that the user"
" actually has the tokens that the order placer wants to buy. If he does, "
"then the exchange transfers the tokens that were claimed when the order "
"was placed to the order matcher, and transfers the tokens that the order "
"placer wants to buy from the order matcher to the order placer. After the"
" tokens have been transferred the exchange deletes the fulfilled order."
msgstr "当用户试图匹配订单时，交易所会检查该用户是否确实拥有订单发布者想要购买的代币。如果他确实有，那么交易所就会将订单下发时所要求的代币转移到订单匹配器，并将下单者想要从订单匹配器购买的代币转移给他。在代币被转移之后，交易所会删除已完成的订单。"

#: ../scilla-by-example.rst:914
msgid ""
"To keep the example brief our exchange will not support unlisting of "
"tokens, cancellation of orders, orders with expiry time, prioritising "
"orders so that the order matcher gets the best deal possible, partial "
"matching of orders, securing the exchange against abuse, fees for trading"
" on the exchange, etc.. We encourage the reader to implement additional "
"features as a way to familiarise themselves even further with Scilla."
msgstr "为了使示例简洁，我们的交易所将不支持下架代币、取消订单、限时订单、订单排序以便订单匹配器获得尽可能好的交易、订单的部分匹配、确保交易所不被滥用、交易手续费等。我们鼓励读者通过实现未实现的功能来进一步熟悉 Scilla。"

#: ../scilla-by-example.rst:924
msgid "The Administrator Role"
msgstr "管理员角色"

#: ../scilla-by-example.rst:926
msgid ""
"The exchange must have an administrator at all times, including when it "
"is first deployed. The administrator may change over time, so we define a"
" mutable field ``admin`` to keep track of the current administrator, and "
"initialise it to an ``initial_admin``, which is given as an immutable "
"parameter:"
msgstr "交易所必须始终有管理员，包括首次部署时。 管理员可能会随着时间的推移而改变，因此我们定义了一个可变字段 ``admin`` 来跟踪当前管理员，并将其初始化为  ``initial_admin`` ，它作为一个不可变参数给出："

#: ../scilla-by-example.rst:941
msgid ""
"The type of the ``admin`` field is ``ByStr20 with end``, which is an "
"`address type`. As in the earlier examples ``ByStr20`` is the type of "
"byte strings of length 20, but we now add the addtional requirement that "
"when that byte string is interpreted as an address on the network, the "
"address must be `in use`, and the contents at that address must satisfy "
"whatever is between the ``with`` and ``end`` keywords."
msgstr "``admin`` 字段的类型是 ``ByStr20 with end`` ，这是一种地址类型。 正如在前面的例子中， ``ByStr20`` 是长度为 20 的字符串类型，但我们现在要添加额外的要求，当该字符串被解释为网络上的地址时，该地址必须在使用中，并且该地址处的内容必须满足  ``with`` 和 ``end`` 关键字之间的任何内容。"

#: ../scilla-by-example.rst:949
msgid ""
"In this case there is nothing between ``with`` and ``end``, so we have no"
" additional requirements. However, the address must be in use, either by "
"a user or by another contract - otherwise Scilla will not accept it as "
"having a legal address type. (We will go into more detail about address "
"types when the exchange interacts with the listed token contracts.)"
msgstr "在这种情况下， ``with`` 和 ``end`` 之间没有任何内容，因此我们没有额外的要求。 但是，该地址必须由用户或其他合约使用 - 否则 Scilla 将不接受其具有合法地址类型。 （当交易所与列出的代币合约交互时，我们将更详细地介绍地址类型。）"

#: ../scilla-by-example.rst:956
msgid ""
"Multiple transitions will need to check that the ``_sender`` is the "
"current ``admin``, so let us define a procedure that checks that that is "
"the case:"
msgstr "有多个 transition 需要检查 ``_sender`` 是否为当前的  ``admin`` ，因此让我们定义一个 procedure 来检查这种情况："

#: ../scilla-by-example.rst:974
msgid ""
"If the ``_sender`` is the current administrator, then nothing happens, "
"and whichever transition called this procedure can continue. If the "
"``_sender`` is someone else, however, the procedure throws an `exception`"
" causing the current transaction to be aborted."
msgstr "如果 ``_sender`` 是当前管理员，则什么也不会发生，调用此 procedure 的任何 transition 都可以继续。 但是，如果``_sender`` 是其他人，则该 procedure 会引发异常，从而导致当前事务中止。"

#: ../scilla-by-example.rst:979
msgid ""
"We want the administrator to be able to pass on the administrator role to"
" someone else, so we define our first transition ``SetAdmin`` as follows:"
msgstr "我们希望管理员能够将管理员角色传递给其他人，因此我们定义我们的第一个 transition ``SetAdmin`` ，如下："

#: ../scilla-by-example.rst:991
msgid ""
"The transition applies the ``CheckSenderIsAdmin`` procedure, and if no "
"exception is thrown then the sender is indeed the current administrator, "
"and is thus allowed to pass on the administrator role on to someone else."
" The new admin must once again be an address that is in use."
msgstr "transition 会应用 procedure ``CheckSenderIsAdmin`` ，如果没有抛出异常，则发送者确实是当前管理员，因此允许将管理员角色传递给其他人。 新管理员必须同样是正在使用的地址。"

#: ../scilla-by-example.rst:999
msgid "Intermezzo: Transferring Tokens On Behalf Of The Token Owner"
msgstr "Intermezzo：代表代币所有者转移代币"

#: ../scilla-by-example.rst:1001
msgid ""
"Before we continue adding features to our exchange we must first look at "
"how token contracts transfer tokens between users."
msgstr "在我们继续向我们的交易所添加功能之前，我们必须首先了解代币合约如何在用户之间转移代币。"

#: ../scilla-by-example.rst:1004
msgid ""
"The ZRC2 token standard defines a field ``balances`` which keeps track of"
" how many tokens each user has:"
msgstr "ZRC2 代币标准定义了一个字段 ``balances`` 来跟踪每个用户拥有多少代币："

#: ../scilla-by-example.rst:1011
msgid ""
"However, this is not particularly useful for our exchange, because the "
"token contract won't allow the exchange to transfer tokens belonging to "
"someone other than the exchange itself."
msgstr "然而，这对我们的交易所并不是特别有用，因为代币合约不允许交易所转移属于交易所本身以外的其他人的代币。"

#: ../scilla-by-example.rst:1015
msgid ""
"Instead, the ZRC2 standard defines a field ``allowances``, which a user "
"who owns tokens can use to allow another user partial access to the "
"owner's tokens:"
msgstr "相反的，ZRC2 标准定义了另一个字段 ``allowances`` ，拥有令牌的用户可以使用它来允许另一个用户部分访问所有者的令牌："

#: ../scilla-by-example.rst:1023
msgid ""
"For instance, if Alice has given Bob an allowance of 100 tokens, then the"
" ``allowances`` map in token contract will contain the value "
"``allowances[<address of Alice>][<address of Bob>] = 100``. This allows "
"Bob to spend 100 of Alice's tokens as if they were his own. (Alice can of"
" course withdraw the allowance, as long as Bob hasn't yet spent the "
"tokens)."
msgstr "例如，如果 Alice 给了 Bob 100 个代币的配额，那么代币合约中的  ``allowances``  映射将包含值 ``allowances[<address of Alice>][<address of Bob>] = 100`` 。这会允许 Bob 使用这 100 个 Alice 的代币，就像使用他自己的一样。 （Alice 当然可以提取配额，只要 Bob 还没有花掉这些代币）。"

#: ../scilla-by-example.rst:1030
msgid ""
"Before a user places an order, the user should provide the exchange with "
"an allowance of the token he wants to sell to cover the order. The user "
"can then place the order, and the exchange can check that the allowance "
"is sufficient. The exchange then transfers the tokens to its own account "
"for holding until the order is matched."
msgstr "在用户下订单之前，用户应该向交易所提供他想要出售的代币额度以支付订单。 然后用户才可以下订单，同时交易所会检查配额是否足够。 然后交易所会将代币转移到自己的账户中持有，直到订单匹配为止。"

#: ../scilla-by-example.rst:1036
msgid ""
"Similarly, before a user matches an order, the user should provide the "
"exchange with an allowance of the token that the order placer wants to "
"buy. The user can then match the order, and the exchange can check that "
"the allowance is sufficent. The exchange then transfers those tokens to "
"the user who placed the order, and transfers to the matching user the "
"tokens that it transferred to itself when the order was placed."
msgstr "类似地，在用户匹配订单之前，用户应该向交易所提供下单者想要购买的代币的配额。 然后用户才可以匹配订单，同时交易所会检查配额是否足够。 然后，交易所将这些代币转移给下订单的用户，并将代币转移给匹配的用户，这些转移的代币就是在下订单时转移给自己的那些。"

#: ../scilla-by-example.rst:1044
msgid ""
"In order to check the current allowance that a user has given to the "
"exchange, we will need to specify the ``allowances`` field in the token "
"address type. We do this as follows:"
msgstr "为了检查用户提供给交易所的当前配额，我们需要在代币地址类型中指定 ``allowances`` 字段。 我们会像下面这样做："

#: ../scilla-by-example.rst:1052
msgid ""
"As with the ``admin`` field we require that the address is in use. "
"Additionally, the requirements between ``with`` and ``end`` must also be "
"satisfied:"
msgstr "与 ``admin`` 字段一样，我们要求地址正在使用中。 此外，还必须满足 ``with`` 和 ``end`` 之间的要求："

#: ../scilla-by-example.rst:1056
msgid ""
"The keyword ``contract`` specifies that the address must be in use by a "
"contract, and not by a user."
msgstr "关键字 ``contract`` 指定：地址必须由合约使用，而不是由用户使用。"

#: ../scilla-by-example.rst:1059
msgid ""
"The keyword ``field`` specifies that the contract in question must "
"contain a mutable field with the specified name and of the specified "
"type."
msgstr "关键字 ``field`` 指定：相关合约必须包含具有指定名称和指定类型的可变字段。"

#: ../scilla-by-example.rst:1065
msgid "Listing a New Token"
msgstr "上架新币"

#: ../scilla-by-example.rst:1067
msgid ""
"The exchange keeps track of its listed tokens, i.e., which tokens are "
"allowed to be traded on the exchange. We do this by defining a map from "
"the token code (a ``String``) to the address of the token."
msgstr "交易所跟踪其上市代币，即允许在交易所交易哪些代币。 我们通过定义从代币代码（ ``String`` ）到代币地址的映射来实现这一点。"

#: ../scilla-by-example.rst:1081
msgid ""
"Only the administrator is allowed to list new tokens, so we leverage the "
"``CheckSenderIsAdmin`` procedure again here."
msgstr "只有允许管理员上架新代币，因此我们在这里再次利用 procedure ``CheckSenderIsAdmin`` 。"

#: ../scilla-by-example.rst:1084
msgid ""
"Additionally, we only want to list tokens that have a different token "
"code from the previously listed tokens. For this purpose we define a "
"procedure ``CheckIsTokenUnlisted`` to check whether a token code is "
"defined as a key in the ``listed_tokens`` map. :"
msgstr "此外，我们只想上架与之前上架的代币具有不同代币代码的代币。 为此，我们定义了一个 procedure ``CheckIsTokenUnlisted`` 来检查代币代码是否被定义为 ``listed_tokens`` 映射中的键。 ："

#: ../scilla-by-example.rst:1126
msgid ""
"This time we define a helper procedure ``ThrowListingStatusException`` "
"which unconditionally throws an exception. This will be useful later when"
" we later write the transition for placing orders, because we will need "
"to check that the tokens involved in the order are listed."
msgstr "这次我们定义了一个辅助 procedure ``ThrowListingStatusException`` ，它无条件地抛出异常。 这将在我们稍后编写用于下订单的 transition 时有用，因为我们需要检查订单中涉及的代币是否已上架。"

#: ../scilla-by-example.rst:1131
msgid ""
"We also define the constant ``false`` in the contract's library. This is "
"due to the fact that Scilla requires all values to be named before they "
"are used in computations. Defining constants in library code prevents us "
"from cluttering the transition code with constant definitions:"
msgstr "我们还在合约的库中定义了常量 ``false`` 。 这是因为 Scilla 要求所有值在用于计算之前都必须命名。 在库代码中定义常量可以防止我们用常量定义混淆 transition 代码："

#: ../scilla-by-example.rst:1143
msgid ""
"With the helper procedures in place we are now ready to define the "
"``ListToken`` transition as follows:"
msgstr "有了帮助 procedure ，我们现在可以定义 transition ``ListToken`` 了，如下所示："

#: ../scilla-by-example.rst:1161
msgid "Placing an Order"
msgstr "下单"

#: ../scilla-by-example.rst:1163
msgid ""
"To place an order a user must specify the token code and the amount of "
"the token he wants to sell, and the token code and amount he wants to "
"buy. We invoke the ``ThrowListingStatusException`` procedure if any of "
"the token codes are unlisted:"
msgstr "要下订单，用户必须指定他想要出售的代币代码和数量，以及他想要购买的代币代码和数量。 如果没有代币代码上架，我们将调用 procedure ``ThrowListingStatusException`` 过程："

#: ../scilla-by-example.rst:1194
msgid ""
"If both tokens are listed, we must first check that the user has supplied"
" a sufficient allowance to the exchange. We will need a similar check "
"when another user matches the order, so we define a helper procedure "
"``CheckAllowance`` to perform the check:"
msgstr "如果两个代币都上架了，我们必须首先检查用户是否为交易所提供了足够的配额。 当另一个用户匹配订单时，我们将需要类似的检查，因此我们定义了一个帮助 procedure ``CheckAllowance`` 来执行检查："

#: ../scilla-by-example.rst:1208
msgid ""
"To perform the check we will need to perform a `remote read` of the "
"``allowances`` field in the token contract. We are interested in the "
"allowance given by the ``_sender`` to the exchange, whose address is "
"given by a special immutable field ``_this_address``, so we want to "
"remote read the value of ``allowances[_sender][_this_address]`` in the "
"token contract."
msgstr "为了执行检查，我们需要远程读取代币合约中的配额字段。 我们对  ``_sender`` 给交易所的配额感兴趣，其地址由一个特殊的不可变字段 ``_this_address`` 给出，所以我们想远程读取代币合约中的配额 ``allowances[_sender][_this_address]`` 的值。"

#: ../scilla-by-example.rst:1215
msgid ""
"Remote reads in Scilla are performed using the operator ``<- &``, and we "
"use ``.`` notation to specify the contract that we want to remote read "
"from. The entire statement for the remote read is therefore as follows:"
msgstr "Scilla 中的远程读取是使用运算符 ``<- &`` 执行的，我们使用 ``.`` 指定我们要远程读取的合约的符号。 因此，远程读取的整个语句如下："

#: ../scilla-by-example.rst:1224
msgid ""
"Just as when we perform a local read of a map, the result of reading from"
" a remote map is an optional value. If the result is ``Some v`` for some "
"``v``, then the user has provided the exchange with an allowance of ``v``"
" tokens, and if the result is ``None`` the user has not supplied an "
"allowance at all. We therefore need to pattern-match the result to get "
"the actual allowance:"
msgstr "就像我们执行本地读取映射一样，从远程映射读取的结果是一个可选值。 如果对于  ``v``  计算结果为 ``Some v`` ，则用户向交易所提供了 ``v`` 代币的配额，如果结果为 ``None`` ，则用户根本没有提供配额。 因此，我们需要对结果进行模式匹配以获得实际的配额："

#: ../scilla-by-example.rst:1239
msgid ""
"Once again, we define the constant ``zero = Uint128 0`` in the contract "
"library for convenience."
msgstr "为方便起见，我们再次在合约库中定义常量 ``zero = Uint128 0`` 。"

#: ../scilla-by-example.rst:1242
msgid ""
"We can now compare the actual allowance to the allowance we are "
"expecting, and throw an exception if the actual allowance is "
"insufficient:"
msgstr "我们现在可以将实际配额与我们期望的配额进行比较，如果实际配额不足，则抛出异常："

#: ../scilla-by-example.rst:1255
msgid ""
"The function ``uint128_le`` is a utility function which performs a less-"
"than-or-equal comparison on values of type ``Uint128``. The function is "
"defined in the ``IntUtils`` part of the standard library, so in order to "
"use the function we must import ``IntUtils`` into the contract, which is "
"done immediately after the ``scilla_version`` preamble, and before the "
"contract library definitions:"
msgstr "函数 ``uint128_le`` 是一个实用函数，它对 ``Uint128`` 类型的值执行小于或等于比较。 该函数是在标准库的 ``IntUtils`` 部分定义的，所以为了使用该函数，我们必须将 ``IntUtils`` 导入合约，这部分定义在 ``scilla_version`` 之后，合约库定义之前："

#: ../scilla-by-example.rst:1272
msgid ""
"We also utilise a helper procedure "
"``ThrowInsufficientAllowanceException`` to throw an exception if the "
"allowance is insufficient, so the ``CheckAllowance`` procedure ends up "
"looking as follows:"
msgstr "我们还利用辅助 procedure ``ThrowInsufficientAllowanceException`` 在配额不足时抛出异常，因此 procedure ``CheckAllowance`` 最终如下所示："

#: ../scilla-by-example.rst:1334
msgid ""
"If the user has given the exchange a sufficient allowance, the exchange "
"can send a message to the token contract to perform the transfer of "
"tokens from the allowance the exchange's own balance. The transition we "
"need to invoke on the token contract is called ``TransferFrom``, as "
"opposed to ``Transfer`` which transfers funds from the sender's own token"
" balance rather than from the sender's allowance of someone else's "
"balance."
msgstr "如果用户给了交易所足够的额度，交易所可以向代币合约发送消息，以便从交易所自己的余额中转移代币。 我们需要在代币合约上调用的 transition 称为 ``TransferFrom`` ，而不是 ``Transfer`` ，后者从发送者自己的代币余额中转移资金，而不是从发送者允许的其他人余额中转移资金。"

#: ../scilla-by-example.rst:1342
msgid ""
"Since the message will look much like the messages that we need when an "
"order is matched, we generate the message using helper functions in the "
"contract library (we will also need a new constant ``true``):"
msgstr "由于消息看起来很像订单匹配时我们需要的消息，因此我们使用合约库中的辅助函数生成消息（我们还需要一个新的常量 ``true`` ）："

#: ../scilla-by-example.rst:1422
msgid ""
"Finally, we need to store the new order, so that users may match the "
"order in the future. For this we define a new type ``Order``, which holds"
" all the information needed when eventually the order is matched:"
msgstr "最后，我们需要存储新订单，以便用户将来可以匹配订单。 为此，我们定义了一个新类型 ``Order`` ，它包含最终匹配订单时所需的所有信息："

#: ../scilla-by-example.rst:1436
msgid ""
"A value of type ``Order`` is given by the type constructor ``Order``, a "
"token address and an amount of tokens to sell, and a token address and an"
" amount of tokens to buy."
msgstr "``Order`` 类型的值由类型构造函数 ``Order`` 、代币地址和要出售的代币数量以及代币地址和要购买的代币数量给出。"

#: ../scilla-by-example.rst:1440
msgid ""
"We now need a field containing a map from order numbers (of type "
"``Uint128``) to ``Order``, which represents the currently active orders. "
"Additionally, we will need a way to generate a unique order number, so "
"we'll define a field which holds the next order number to use:"
msgstr "我们现在需要一个包含从订单号（类型为 ``Uint128`` ）到 ``Order`` 的映射的字段，它表示当前活动的订单。 此外，我们将需要一种生成唯一订单号的方法，因此我们将定义一个字段来保存要使用的下一个订单号："

#: ../scilla-by-example.rst:1452
msgid ""
"To add a new order we need to generate a new order number, store the "
"generated order number and the new order in the ``active_orders`` map, "
"and finally increment the ``next_order_no`` field (using the library "
"constant ``one = Uint128 1``) so that it is ready for the next order to "
"be placed. We will put that in a helper procedure ``AddOrder``, and add a"
" call to the procedure in the ``PlaceOrder`` transition:"
msgstr "要添加新订单，我们需要生成一个新订单号，将生成的订单号和新订单存储在 ``active_orders`` 映射中，最后增加 ``next_order_no`` 字段（使用库常量 ``one = Uint128 1`` ），以便为生成下一个订单。 我们将把它放在一个辅助 procedure ``AddOrder`` 中，并在 transition ``PlaceOrder`` 中添加一个对该 procedure 的调用："

#: ../scilla-by-example.rst:1505
msgid ""
"``PlaceOrder`` is now complete, but there is still one thing missing. The"
" `ZRC2` token standard specifies that when a ``TransferFrom`` transition "
"is executed, the token sends messages to the recipient and the "
"``_sender`` (known as the `initiator`) notifying them of the successful "
"transfer. These notifications are known as `callbacks`. Since our "
"exchange executes a ``TransferFrom`` transition on the sell token, and "
"since the exchange is the recipient of those tokens, we will need to "
"specify transitions that can handle both callbacks - if we don't, then "
"the callbacks will not be recognised, causing the entire ``PlaceOrder`` "
"transaction to fail."
msgstr "``PlaceOrder`` 现在已经完成，但还缺少一件事。 ZRC2 代币标准规定，当执行 transition ``TransferFrom`` 时，代币将消息发送给接收者和 ``_sender`` （称为发起者），以此来通知他们传输成功。 这些通知称为回调。 由于我们的交易所在卖出代币上执行 transition ``TransferFrom`` ，并且由于交易所是这些代币的接收者，我们需要指定可以处理这两个回调的 transition ——如果我们不这样做，那么回调将不会被识别，从而导致整个 ``PlaceOrder`` 交易失败。"

#: ../scilla-by-example.rst:1516
msgid ""
"Token contracts notify the recipients of token transfers because such "
"notifications add an extra safeguard against the risk of transferring "
"tokens to a contract that is unable to deal with token ownership. For "
"instance, if someone were to transfer tokens to the ``HelloWorld`` "
"contract in the first example in this section, then the tokens would be "
"locked forever because the ``HelloWorld`` contract is incapable of doing "
"anything with the tokens."
msgstr "代币合约通知代币转移的接收者，因为此类通知增加了额外的保护措施，以防止将代币转移到无法处理代币所有权的合约的风险。 例如，如果有人在本节的第一个示例中将代币转移到 ``HelloWorld`` 合约，那么代币将被永久锁定，因为  ``HelloWorld`` 合约无法对代币进行任何操作。"

#: ../scilla-by-example.rst:1524
msgid ""
"Our exchange is only capable of dealing with tokens for which there is an"
" active order, but in principle there is nothing stopping a user from "
"transferring funds to the exchange without placing an order, so we need "
"to ensure that the exchange is only involved in token transfers that it "
"itself has initiated. We therefore define a procedure ``CheckInitiator``,"
" which throws an exception if the exchange is involved in a token "
"transfer that it itself did not initiate, and invoke that procedure from "
"all callback transitions:"
msgstr "我们的交易所只能处理有活跃订单的代币，但原则上没有什么可以阻止用户不下订单就向交易所转账，所以我们需要确保交易所只涉及代币自己发起的转账。 因此，我们定义了一个 procedure ``CheckInitiator`` ，如果交换涉及它本身没有启动的代币传输，它会抛出异常，并从所有回调 transition 中调用该 procedure ："

#: ../scilla-by-example.rst:1566
msgid "Matching an Order"
msgstr "匹配订单"

#: ../scilla-by-example.rst:1568
msgid ""
"For the ``MatchOrder`` transition we can leverage many of the helper "
"functions and procedures defined in the previous section."
msgstr "对于 transition ``MatchOrder`` ，我们可以利用上一节中定义的许多辅助函数和 procedure 。"

#: ../scilla-by-example.rst:1571
msgid ""
"The user specifies an order he wishes to match. We then look up the order"
" number in the ``active_orders`` map, and throw an exception if the order"
" is not found:"
msgstr "用户指定他希望匹配的订单。 然后我们在 ``active_orders`` 映射中查找订单号，如果找不到订单则抛出异常："

#: ../scilla-by-example.rst:1590
msgid ""
"In order to match the order, the matcher has to provide sufficient "
"allowance of the buy token. This is checked by the ``CheckAllowance`` "
"procedure we defined earlier, so we simply reuse that procedure here:"
msgstr "为了匹配订单，匹配者必须提供足够的买入代币额度。 这是由我们之前定义的 procedure ``CheckAllowance`` 检查的，因此我们在这里简单地重用该 procedure ："

#: ../scilla-by-example.rst:1611
msgid ""
"We now need to generate two transfer messages: One message is a "
"``TransferFrom`` message on the buy token, transferring the matcher's "
"allowance to the user who placed the order, and the other message is a "
"``Transfer`` message on the sell token, transferring the tokens held by "
"the exchange to the order matcher. Once again, we define helper functions"
" to generate the messages:"
msgstr "我们现在需要生成两条转账消息：一条消息是买入代币上的 ``TransferFrom`` 消息，将匹配者的配额转移给下订单的用户，另一条消息是卖出代币上的 ``Transfer`` 消息，将被持有的代币转移到订单匹配器。 同样的，我们定义辅助函数来生成消息："

#: ../scilla-by-example.rst:1670
msgid ""
"Since the order has now been matched, it should no longer be listed as an"
" active order, so we delete the entry in ``active_orders``:"
msgstr "由于订单现在已经匹配，所以不应再将其列为活动订单，因此我们删除 ``active_orders`` 中的条目："

#: ../scilla-by-example.rst:1694
msgid ""
"This concludes the ``MatchOrder`` transition, but we need to define one "
"additional callback transition. When placing an order we executed a "
"``TransferFrom`` transition, but now we also execute a ``Transfer`` "
"transition, which gives rise to a different callback:"
msgstr "transition ``MatchOrder`` 到此就结束了，但我们需要定义一个额外的回调 transition。 下订单时，我们执行了 transition ``TransferFrom`` ，但现在我们也执行 transition ``Transfer`` ，这会产生不同的回调："

#: ../scilla-by-example.rst:1710
msgid ""
"Note that we do not need to specify a transition handling the receipt of "
"tokens from a ``Transfer`` transition, because the exchange never "
"executes a ``Transfer`` with itself as the recipient. By not defining the"
" callback transition at all, we also take care of the situation where a "
"user performs a ``Transfer`` with the exchange as the recipient, because "
"the recipient callback won't have a matching transition on the exchange, "
"causing the entire transfer transaction to fail."
msgstr "请注意，我们不需要指定处理从 transition ``Transfer`` 中接收代币的 transition，因为交易所永远不会将自己作为接收者执行 ``Transfer`` 。 通过完全不定义回调 transition，我们还处理了用户以交易所作为接收方进行转账的情况，因为接收方回调在交易所上不会有匹配的 transition，这将导致整个转账交易失败。"

#: ../scilla-by-example.rst:1722
msgid "We now have everything in place to specify the entire contract:"
msgstr "我们现在已经准备好指定整个合约的一切："

#: ../scilla-by-example.rst:2027
msgid ""
"As mentioned in the introduction we have kept the exchange simplistic in "
"order to keep the focus on Scilla features."
msgstr "正如介绍中提到的，我们保持交流简单化，以保持对 Scilla 功能的关注。"

#: ../scilla-by-example.rst:2030
msgid ""
"To further familiarise themselves with Scilla we encourage the reader to "
"add additional features such as unlisting of tokens, cancellation of "
"orders, orders with expiry time, prioritising orders so that the order "
"matcher gets the best deal possible, partial matching of orders, securing"
" the exchange against abuse, fees for trading on the exchange, etc.."
msgstr "为了进一步熟悉 Scilla，我们鼓励读者添加其他功能，例如取消代币上市、取消订单、有到期时间的订单、以便订单匹配器获得最佳交易的优先订单、订单的部分匹配、反对滥用的交易保护、交易所交易费用等。"

