# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Zilliqa Research
# This file is distributed under the same license as the scilla中文文档 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: scilla中文文档 \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-21 15:18+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../scilla-by-example.rst:2
msgid "Scilla by Example"
msgstr "Scilla实战演练"

#: ../scilla-by-example.rst:6
msgid "HelloWorld"
msgstr ""

#: ../scilla-by-example.rst:8
msgid ""
"We start off by writing a classical ``HelloWorld.scilla`` contract with "
"the following  specification:"
msgstr "首先，我们来编写具有以下规范的经典 ``HelloWorld.scilla`` 合约："

#: ../scilla-by-example.rst:12
msgid ""
"It should have an `immutable contract parameter` ``owner`` to be "
"initialized by the creator of the contract. The parameter is immutable in"
" the sense that once initialized during contract deployment, its value "
"cannot be changed. ``owner`` will be of type ``ByStr20`` (a hexadecimal "
"Byte String representing a 20 byte address)."
msgstr "此合约中有一个不可变的合约参数 ``owner`` ，由合约的创建者初始化。 该参数是不可变的，即意味着一旦在合约部署期间进行初始化，其值就无法更改。其中 ``owner`` 是 ``ByStr20`` 类型（表示 20 字节地址的十六进制字节字符串）。"

#: ../scilla-by-example.rst:18
msgid ""
"It should have a `mutable field` ``welcome_msg`` of type ``String`` "
"initialized to ``\"\"``. Mutability here refers to the possibility of "
"modifying the value of a variable even after the contract has been "
"deployed."
msgstr "此合约中有一个 ``String`` 类型的可变字段 ``welcome_msg`` 且被初始化为 ``\"\"`` 。 此处的可变性是指，即使在部署合约后也可以修改变量的值。"

#: ../scilla-by-example.rst:22
msgid ""
"The ``owner`` and **only her** should be able to modify ``welcome_msg`` "
"through an interface ``setHello``. The interface takes a ``msg`` (of type"
" ``String``) as input and  allows the ``owner`` to set the value of "
"``welcome_msg`` to ``msg``."
msgstr "``owner`` 且 **只有她** 才能够通过接口 ``setHello`` 修改 ``welcome_msg`` 。 该接口将 ``msg`` （  ``String`` 类型）作为输入，并允许 ``owner`` 将 ``welcome_msg`` 的值设置为 ``msg`` 。"

#: ../scilla-by-example.rst:27
msgid ""
"It should have an interface ``getHello`` that welcomes any caller with "
"``welcome_msg``. ``getHello`` will not take any input."
msgstr "此合约有一个接口 ``getHello`` ，允许任何带有 ``welcome_msg`` 的调用者调用。此外 ``getHello`` 不会接受任何输入。"

#: ../scilla-by-example.rst:32
msgid "Defining a Contract, its Immutable Parameters and Mutable Fields"
msgstr "定义合约、不可变参数和可变字段"

#: ../scilla-by-example.rst:34
msgid ""
"A contract is declared using the ``contract`` keyword that starts the "
"scope of the contract. The keyword is followed by the name of the "
"contract which will be ``HelloWorld`` in our example. So, the following "
"code fragment declares a ``HelloWorld`` contract."
msgstr "我们将使用关键字 ``contract`` 来作为声明一个合约的开始。 关键字后跟合约的名称，而在我们的示例中就是 ``HelloWorld`` 。 综上，以下代码片段声明了一个 ``HelloWorld`` 合约。"

#: ../scilla-by-example.rst:46
msgid ""
"In the current implementation, a Scilla contract can only contain a "
"single contract declaration and hence any code that follows the "
"``contract`` keyword is part of the contract declaration. In other words,"
" there is no explicit keyword to declare the end of the contract "
"definition."
msgstr "在目前的实现中，一个 Scilla 合约只能包含一个单一的合约声明，因此任何跟在 ``contract`` 关键字之后的代码都是合约声明的一部分。 换句话说，没有明确的关键字来声明合约定义的结束。"

#: ../scilla-by-example.rst:53
msgid ""
"A contract declaration is followed by the declaration of its immutable "
"parameters, the scope of which is defined by ``()``. Each immutable "
"parameter is declared in the following way: ``vname: vtype``, where "
"``vname`` is the parameter name and ``vtype`` is the parameter type. "
"Immutable parameters are separated by ``,``. As per the specification, "
"the contract will have only one immutable parameter ``owner`` of type "
"``ByStr20`` and hence the following code fragment."
msgstr "声明合约后，接下来是其不可变参数的声明，其代码块由 ``()`` 包裹。 每个不可变参数都通过以下方式声明： ``vname: vtype`` ，其中 ``vname`` 是参数名称，``vtype`` 是参数类型。 不可变参数由 ``,`` 分隔。 根据规范，合约将只有一个 ``ByStr20`` 类型的不可变参数 ``owner`` ，具体参考以下代码片段。"

#: ../scilla-by-example.rst:66
msgid ""
"Mutable fields in a contract are declared through keyword ``field``. Each"
" mutable field is declared in the following way: ``field vname : vtype = "
"init_val``, where ``vname`` is the field name, ``vtype`` is its type and "
"``init_val`` is the value to which the field has to be initialized. The "
"``HelloWorld`` contract has one mutable field ``welcome_msg`` of type "
"``String`` initialized to ``\"\"``. This yields the following code "
"fragment:"
msgstr "合约中的可变字段通过关键字 ``field`` 声明。 每个可变字段以下列方式声明： ``field vname : vtype = init_val`` ，其中 ``vname`` 是字段名称，``vtype`` 是它的类型，``init_val`` 是字段必须被初始化的值。 ``HelloWorld`` 合约有一个 ``String`` 类型的可变字段 ``welcome_msg`` ，且被初始化为 ``\"\"`` 。 具体实现参考以下代码片段："

#: ../scilla-by-example.rst:78
msgid ""
"At this stage, our ``HelloWorld.scilla`` contract will have the following"
" form that includes the contract name, its immutable parameters and "
"mutable fields:"
msgstr "在此阶段，我们的 ``HelloWorld.scilla`` 合约将具有以下形式，其中包括合约名称、不可变参数和可变字段："

#: ../scilla-by-example.rst:92
msgid "Defining Interfaces `aka` Transitions"
msgstr "定义接口即Transitions"

#: ../scilla-by-example.rst:94
msgid ""
"Interfaces like ``setHello`` are referred to as `transitions` in Scilla. "
"Transitions are similar to `functions` or `methods` in other languages. "
"There is an important difference, however, most languages allow their "
"functions or methods to be \"interrupted\" by a thread running in "
"parallel, but Scilla won't let a transition to be interrupted ensuring "
"there is no so-called reentrancy issues."
msgstr "像 ``setHello`` 这样的接口在 Scilla 中被称为 `transitions` 。 Transitions类似于其他语言中的函数或方法。 然而，他们有一个重要的区别，大多数语言允许它们的函数或方法被并行运行的线程\"中断\" ，但 Scilla 不会让transitions被中断，以此来确保不会出现所谓的重入问题。"

#: ../scilla-by-example.rst:104
msgid ""
"The term `transition` comes from the underlying computation model in "
"Scilla which follows a communicating automaton. A contract in Scilla is "
"an automaton with some state. The state of an automaton can be changed "
"using a transition that takes a previous state and an input and yields a "
"new state. Check the `wikipedia entry "
"<https://en.wikipedia.org/wiki/Transition_system>`_ to read more about "
"transition systems."
msgstr "术语 `transition` 来自 Scilla 中的底层计算模型，它遵循通信自动机。 Scilla 中的合约是具有某种状态的自动机。 自动机的状态可以使用 `transition` 来更改，该 `transition` 采用先前状态和输入并产生新的状态。 访问 `维基百科条目 <https://en.wikipedia.org/wiki/Transition_system>`_ 以阅读有关 `transition` 系统的更多信息。"

#: ../scilla-by-example.rst:111
msgid ""
"A transition is declared using the keyword ``transition``. The end of a "
"transition scope is declared using the keyword ``end``. The "
"``transition`` keyword is followed by the transition name, which is "
"``setHello`` for our example. Then follows the input parameters within "
"``()``. Each input parameter is separated by a ``,`` and is declared in "
"the following format: ``vname : vtype``.  According to the specification,"
" ``setHello`` takes only one parameter of name ``msg`` of type "
"``String``.  This yields the following code fragment:"
msgstr "使用关键字 ``transition`` 声明一个 `transition` 。 使用关键字 ``end`` 声明 `transition` 代码块的结束。 ``transition`` 关键字后跟 `transition` 名称，在我们的示例中为 ``setHello`` 。 然后是 ``()`` 内的输入参数。 每个输入参数由 ``,`` 分隔，并以以下格式声明：  ``vname : vtype`` 。 根据规范， ``setHello`` 只接受一个 ``String`` 类型的名为 ``msg`` 的参数。具体参照以下代码片段："

#: ../scilla-by-example.rst:123
msgid ""
"What follows the transition signature is the body of the transition. Code"
" for the first transition ``setHello (msg :  String)`` to set "
"``welcome_msg`` is given below:"
msgstr "transition 声明之后是 transition 的主体部分。 下面给出了第一个transition的代码段，此代码段为调用 ``setHello (msg :  String)`` 以设置 ``welcome_msg`` ："

#: ../scilla-by-example.rst:144
msgid ""
"At first, the caller of the transition is checked against the ``owner`` "
"using the instruction ``builtin eq owner _sender`` in ``Line 2``. In "
"order to compare two addresses, we are using the function ``eq`` defined "
"as a ``builtin`` operator. The operator returns a Boolean value ``True`` "
"or ``False``."
msgstr "首先，使用第 2 行中的指令 ``builtin eq owner _sender`` 来检查 transition 的调用者是否与  ``owner`` 相等。为了比较两个地址，我们使用定义为函数 ``eq`` 的 ``builtin`` 运算符。 该运算符返回布尔值 ``True`` 或 ``False`` 。"

#: ../scilla-by-example.rst:152
msgid ""
"Scilla internally defines some variables that have special semantics. "
"These special variables are often prefixed by ``_``. For instance, "
"``_sender`` in Scilla refers to the account address that called the "
"current contract."
msgstr "Scilla 内部定义了一些具有特殊语义的变量。 这些特殊变量通常以  ``_`` 为前缀。 例如，Scilla 中的 ``_sender`` 是指调用当前合约的帐户地址。"

#: ../scilla-by-example.rst:156
msgid ""
"Depending on the output of the comparison, the transition takes a "
"different path declared using `pattern matching`, the syntax of which is "
"given in the fragment below."
msgstr "根据比较的结果，transition 通过不同的分支来进行模式匹配，其语法如下面的代码片段所示。"

#: ../scilla-by-example.rst:167
msgid ""
"The above code checks whether ``expr`` evaluates to a value that matches "
"``pattern_1`` or ``pattern_2``. If ``expr`` evaluates to a value matching"
" ``pattern_1``, then the next expression to be evaluated will be "
"``expr_1``.  Otherwise, if ``expr`` evaluates to a value matching "
"``pattern_2``, then the next expression to be evaluated will be "
"``expr_2``."
msgstr "上面的代码检查 ``expr`` 的计算结果是否与 ``pattern_1`` 或  ``pattern_2`` 匹配。 如果 ``expr`` 的计算结果与 ``pattern_1`` 匹配，那么接下来要执行的表达式将是 ``expr_1`` 。 否则，如果 ``expr`` 的计算结果与 ``pattern_2`` 匹配，那么接下来要执行的表达式就是 ``expr_2`` 。"

#: ../scilla-by-example.rst:174
msgid ""
"Hence, the following code block implements an ``if-then-else`` "
"instruction:"
msgstr "因此，以下代码块实现了类似于 ``if-then-else`` 的指令："

#: ../scilla-by-example.rst:185
msgid "The Caller is Not the Owner"
msgstr "调用者不是所有者"

#: ../scilla-by-example.rst:187
msgid ""
"In case the caller is different from ``owner``, the transition takes the "
"``False`` branch and the contract emits an event using the instruction "
"``event``."
msgstr "如果调用者与 ``owner`` 不同，则 transition 会进入 ``False`` 分支，即合约使用指令 ``event`` 来触发一个事件。"

#: ../scilla-by-example.rst:191
msgid ""
"An event is a signal that gets stored on the blockchain for everyone to "
"see. If a user uses a client application to invoke a transition on a "
"contract, the client application can listen for events that the contract "
"may emit, and alert the user."
msgstr "事件是指存储在区块链上供所有人查看的信号。 如果用户使用客户端应用程序调用合约的 transition，客户端应用程序就可以监听合约可能触发的事件，并提醒用户。"

#: ../scilla-by-example.rst:196
msgid "More concretely, the output event in this case is:"
msgstr "更具体地说，这种情况下的事件代码如下："

#: ../scilla-by-example.rst:202
msgid ""
"An event is comprised of a number of ``vname : value`` pairs delimited by"
" ``;`` inside a pair of curly braces ``{}``. An event must contain the "
"compulsory field ``_eventname``, and may contain other fields such as the"
" ``code`` field in the example above."
msgstr "一个事件由许多 ``vname : value`` 对组成，并由 ``;`` 分隔。 在一对花括号 ``{}`` 内。 一个事件必须包含必填字段  ``_eventname`` ，同时也可以包含其他字段，例如上面示例中的  ``code``  字段。"

#: ../scilla-by-example.rst:209
msgid ""
"In our example we have chosen to name the event after the transition that"
" emits the event, but any name can be chosen. However, it is recommended "
"that you name the events in a way that makes it easy to see which part of"
" the code emitted the event."
msgstr "在我们的示例中，我们选择使用 transition 的名称来命名事件的名称，但时你可以选择任何其他名称。 不过呢，还是建议你以易读性为标准来命名，即使用执行事件的那部分代码的名称来命名事件。"

#: ../scilla-by-example.rst:219
msgid "The Caller is the Owner"
msgstr "调用者是所有者"

#: ../scilla-by-example.rst:221
msgid ""
"In case the caller is ``owner``, the contract allows the caller to set "
"the value of the mutable field ``welcome_msg`` to the input parameter "
"``msg``. This is done through the following instruction:"
msgstr "如果调用者是 ``owner`` ，则合约允许调用者将可变字段 ``welcome_msg`` 的值设置为输入参数 ``msg`` 。 这些是通过以下指令完成的："

#: ../scilla-by-example.rst:233
msgid "Writing to a mutable field is done using the operator ``:=``."
msgstr "给可变字段赋值是使用运算符 ``:=`` 完成的。"

#: ../scilla-by-example.rst:236
msgid ""
"And as in the previous case, the contract then emits an event with the "
"code ``set_hello_code``."
msgstr "和前面的例子一样，合约随后会触发一个 code 值为  ``set_hello_code`` 的事件。"

#: ../scilla-by-example.rst:241
msgid "Libraries"
msgstr "库文件"

#: ../scilla-by-example.rst:243
msgid ""
"A Scilla contract may come with some helper libraries that declare purely"
" functional components of a contract, i.e., components with no state "
"manipulation. A library is declared in the preamble of a contract using "
"the keyword ``library`` followed by the name of the library. In our "
"current example a library declaration would look as follows:"
msgstr "Scilla 合约会有一些辅助库，它们声明合约的纯功能组件，即没有状态操作的组件。 使用关键字 ``library`` 然后跟上库名称，就完成了在合约的开始部分中库的声明。 在我们当前的示例中，库声明如下所示："

#: ../scilla-by-example.rst:254
msgid ""
"The library may include utility functions and program constants using the"
" ``let ident = expr`` construct. In our example the library will only "
"include the definition of error codes:"
msgstr "该库可能包含使用 ``let ident = expr`` 定义的效用函数和程序常量。 在我们的示例中，库将仅包含错误代码的定义："

#: ../scilla-by-example.rst:263
msgid "At this stage, our contract fragment will have the following form:"
msgstr "到这里为止，我们的合约片段会变成下面这个样子："

#: ../scilla-by-example.rst:293
msgid "Adding Another Transition"
msgstr "增加另一个 Transition"

#: ../scilla-by-example.rst:295
msgid ""
"We may now add the second transition ``getHello()`` that allows client "
"applications to know what the ``welcome_msg`` is. The declaration is "
"similar to ``setHello (msg : String)`` except that ``getHello()`` does "
"not take a parameter."
msgstr "我们现在可以增加第二个 transition  ``getHello()`` ，它允许客户端应用程序知道 ``welcome_msg`` 是什么。 声明与 ``setHello (msg : String)`` 类似，只是 ``getHello()`` 不带参数。"

#: ../scilla-by-example.rst:310
msgid ""
"Reading from a local mutable field, i.e., a field defined in the current "
"contract, is done using the operator ``<-``."
msgstr "读取到本地可变字段（即将当前合约中定义的字段读取到本地）是使用运算符 ``<-`` 完成的。"

#: ../scilla-by-example.rst:312
msgid ""
"In the ``getHello()`` transition, we will first read from a mutable "
"field, and then we construct and emit the event."
msgstr "在 transition  ``getHello()``  中，我们将首先从可变字段中读取，然后构造并触发事件。"

#: ../scilla-by-example.rst:317
msgid "Scilla Version"
msgstr "Scilla 版本号"

#: ../scilla-by-example.rst:319
msgid ""
"Once a contract has been deployed on the network, it cannot be changed. "
"It is therefore necessary to specify which version of Scilla the contract"
" is written in, so as to ensure that the behaviour of the contract does "
"not change even if changes are made to the Scilla specification."
msgstr "合约一旦在网络上部署，就无法更改。 因此需要指定合约是用哪个版本的 Scilla 编写的，以确保即使对 Scilla 规范进行更改，合约的行为也不会改变。"

#: ../scilla-by-example.rst:325
msgid ""
"The Scilla version of the contract is declared using the keyword "
"``scilla_version``:"
msgstr ""

#: ../scilla-by-example.rst:332
msgid "The version declaration must appear before any library or contract code."
msgstr "合约的 Scilla 版本是使用关键字 ``scilla_version`` 声明的："

#: ../scilla-by-example.rst:337 ../scilla-by-example.rst:658
#: ../scilla-by-example.rst:1720
msgid "Putting it All Together"
msgstr "代码完整示例"

#: ../scilla-by-example.rst:339
msgid ""
"The complete contract that implements the desired specification is given "
"below, where we have added comments using the ``(* *)`` construct:"
msgstr "下面给出了实现所需规范的完整合约，其中我们使用  ``(* *)``  结构添加了注释："

#: ../scilla-by-example.rst:392
msgid "A Second Example: Crowdfunding"
msgstr ""

#: ../scilla-by-example.rst:394
msgid ""
"In this section, we present a slightly more involved contract that runs a"
" crowdfunding campaign. In a crowdfunding campaign, a project owner "
"wishes to raise funds through donations from the community."
msgstr ""

#: ../scilla-by-example.rst:398
msgid ""
"It is assumed that the owner (``owner``) wishes to run the campaign until"
" a certain, predetermined block number is reached on the blockchain "
"(``max_block``). The owner also wishes to raise a minimum amount of QA "
"(``goal``) without which the project can not be started. The contract "
"hence has three immutable parameters ``owner``, ``max_block`` and "
"``goal``."
msgstr ""

#: ../scilla-by-example.rst:405
msgid ""
"The immutable parameters are provided when the contract is deployed. At "
"that point we wish to add a sanity check that the ``goal`` is a strictly "
"positive amount. If the contract is accidentally initialised with a "
"``goal`` of 0, then the contract should not be deployed."
msgstr ""

#: ../scilla-by-example.rst:410
msgid ""
"The total amount that has been donated to the campaign so far is stored "
"in a field ``_balance``. Any contract in Scilla has an implicit "
"``_balance`` field of type ``Uint128``, which is initialised to 0 when "
"the contract is deployed, and which holds the amount of QA in the "
"contract's account on the blockchain."
msgstr ""

#: ../scilla-by-example.rst:416
msgid ""
"The campaign is deemed successful if the owner can raise the goal in the "
"stipulated time. In case the campaign is unsuccessful, the donations are "
"returned to the project backers who contributed during the campaign. The "
"backers are supposed to ask for refund explicitly."
msgstr ""

#: ../scilla-by-example.rst:421
msgid "The contract maintains two mutable fields:"
msgstr ""

#: ../scilla-by-example.rst:423
msgid ""
"``backers``: a field map from a contributor's address (a ``ByStr20`` "
"value) to the amount contributed, represented with a ``Uint128`` value. "
"Since there are no backers initially, this map is initialized to an "
"``Emp`` (empty) map. The map enables the contract to register a donor, "
"prevent multiple donations and to refund back the money if the campaign "
"does not succeed."
msgstr ""

#: ../scilla-by-example.rst:430
msgid ""
"``funded``:  a Boolean flag initialized to ``False`` that indicates "
"whether the owner has already transferred the funds after the end of the "
"campaign."
msgstr ""

#: ../scilla-by-example.rst:434
msgid ""
"The contract contains three transitions: ``Donate ()`` that allows anyone"
" to contribute to the crowdfunding campaign, ``GetFunds ()`` that allows "
"**only the owner** to claim the donated amount and transfer it to "
"``owner`` and ``ClaimBack()`` that allows contributors to claim back "
"their donations in case the campaign is not successful."
msgstr ""

#: ../scilla-by-example.rst:441
msgid "Sanity check for contract parameters"
msgstr ""

#: ../scilla-by-example.rst:443
msgid ""
"To ensure that the ``goal`` is a strictly positive amount, we use a "
"`contract constraint`:"
msgstr ""

#: ../scilla-by-example.rst:453
msgid ""
"The Boolean expression between ``with`` and ``=>`` above is evaluated "
"during contract deployment and the contract only gets deployed if the "
"result of evaluation is ``True``. This ensures that the contract cannot "
"be deployed with a ``goal`` of 0 by mistake."
msgstr ""

#: ../scilla-by-example.rst:460
msgid "Reading the Current Block Number"
msgstr ""

#: ../scilla-by-example.rst:462
msgid ""
"The deadline is given as a block number, so to check whether the deadline"
" has passed, we must compare the deadline against the current block "
"number."
msgstr ""

#: ../scilla-by-example.rst:466
msgid "The current block number is read as follows:"
msgstr ""

#: ../scilla-by-example.rst:472
msgid ""
"Block numbers have a dedicated type ``BNum`` in Scilla, so as to not "
"confuse them with regular unsigned integers."
msgstr ""

#: ../scilla-by-example.rst:477
msgid ""
"Reading data from the blockchain is done using the operator ``<- &``. "
"Blockchain data cannot be updated directly from the contract."
msgstr ""

#: ../scilla-by-example.rst:483
msgid "Reading and Updating the Current Balance"
msgstr ""

#: ../scilla-by-example.rst:485
msgid ""
"The target for the campaign is specified by the owner in the immutable "
"parameter ``goal`` when the contract is deployed. To check whether the "
"target have been met, we must compare the total amount raised to the "
"target."
msgstr ""

#: ../scilla-by-example.rst:490
msgid ""
"The amount of QA raised is stored in the contract's account on the "
"blockchain, and can be accessed through the implicitly declared "
"``_balance`` field as follows:"
msgstr ""

#: ../scilla-by-example.rst:498
msgid "Money is represented as values of type ``Uint128``."
msgstr ""

#: ../scilla-by-example.rst:502
msgid ""
"The ``_balance`` field is read using the operator ``<-`` just like any "
"other contract field. However, the ``_balance`` field can only be updated"
" by accepting money from incoming messages (using the instruction "
"``accept``), or by explicitly transferring money to other account (using "
"the instruction ``send`` as explained below)."
msgstr ""

#: ../scilla-by-example.rst:511
msgid "Sending Messages"
msgstr ""

#: ../scilla-by-example.rst:513
msgid ""
"In Scilla, there are two ways that transitions can transmit data. One way"
" is through events, as covered in the previous example. The other is "
"through the sending of messages using the instruction ``send``."
msgstr ""

#: ../scilla-by-example.rst:517
msgid ""
"``send`` is used to send messages to other accounts, either in order to "
"invoke transitions on another smart contract, or to transfer money to "
"user accounts. On the other hand, events are dispatched signals that "
"smart contracts can use to transmit data to client applications."
msgstr ""

#: ../scilla-by-example.rst:522
msgid ""
"To construct a message we use a similar syntax as when constructing "
"events:"
msgstr ""

#: ../scilla-by-example.rst:529
msgid ""
"A message must contain the compulsory `message fields` ``_tag``, "
"``_recipient`` and ``_amount``. The ``_recipient`` message field is the "
"blockchain address (of type ``ByStr20``) that the message is to be sent "
"to, and the ``_amount`` message field is the number of QA to be "
"transferred to that account."
msgstr ""

#: ../scilla-by-example.rst:534
msgid ""
"The value of the ``_tag`` message field is the name of the transition (of"
" type ``String``) that is to be invoked on the contract deployed at "
"``_recipient`` address. If ``_recipient`` is the address of a user "
"account then the value of ``_tag`` is ignored, hence for simplicity we "
"put ``\"\"`` here."
msgstr ""

#: ../scilla-by-example.rst:541
msgid ""
"To make it possible to refund both contracts and user accounts (this is "
"useful if a backer used a wallet contract to donate), use a standard "
"transition name as per `ZRC-5 "
"<https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-5.md>`_, i.e. "
"``AddFunds``."
msgstr ""

#: ../scilla-by-example.rst:547
msgid ""
"In addition to the compulsory fields the message may contain other "
"fields, such as ``code`` above. However, if the message recipient is a "
"contract, the additional fields must have the same names and types as the"
" parameters of the transition being invoked on the recipient contract."
msgstr ""

#: ../scilla-by-example.rst:553
msgid ""
"Sending a message is done using the ``send`` instruction, which takes a "
"list of messages as a parameter. Since we will only ever send one message"
" at a time in the crowdfunding contract, we define a library function "
"``one_msg`` to construct a list consisting of one message:"
msgstr ""

#: ../scilla-by-example.rst:566
msgid ""
"To send out a message, we first construct the message, insert it into a "
"list, and send it:"
msgstr ""

#: ../scilla-by-example.rst:577
msgid "Procedures"
msgstr ""

#: ../scilla-by-example.rst:579
msgid ""
"The transitions of a Scilla contract often need to perform the same small"
" sequence of instructions. In order to prevent code duplication a "
"contract may define a number of `procedures`, which may be invoked from "
"the contract's transitions. Procedures also help divide the contract code"
" into separate, self-contained pieces which are easier to read and reason"
" about individually."
msgstr ""

#: ../scilla-by-example.rst:586
msgid ""
"A procedure is declared using the keyword ``procedure``. The end of a "
"procedure is declared using the keyword ``end``. The ``procedure`` "
"keyword is followed by the transition name, then the input parameters "
"within ``()``, and then the statements of the procedure."
msgstr ""

#: ../scilla-by-example.rst:591
msgid ""
"In our example the ``Donate`` transition will issue an event in three "
"situations: An error event if the donation happens after the deadline, "
"another error event if the backer has donated money previously, and a "
"non-error event indicating a successful donation. Since much of the event"
" issuing code is identical, we decide to define a procedure "
"``DonationEvent`` which is responsible for issuing the correct event:"
msgstr ""

#: ../scilla-by-example.rst:613
msgid ""
"The procedure takes two arguments: A ``Bool`` indicating whether the "
"donation failed, and an error code indicating the type of failure if a "
"failure did indeed occur."
msgstr ""

#: ../scilla-by-example.rst:617
msgid ""
"The procedure performs a ``match`` on the ``failure`` argument. If the "
"donation did not fail, the error code is ignored, and a "
"``DonationSuccess`` event is issued. Otherwise, if the donation failed, "
"then a ``DonationFailure`` event is issued with the error code that was "
"passed as the second argument to the procedure."
msgstr ""

#: ../scilla-by-example.rst:623
msgid ""
"The following code shows how to invoke the ``DonationEvent`` procedure "
"with the arguments ``True`` and ``0``:"
msgstr ""

#: ../scilla-by-example.rst:635
msgid ""
"The special parameters ``_sender``, ``_origin`` and ``_amount`` are "
"available to a procedure even though the procedure is invoked by a "
"transition rather than by an incoming message. It is not necessary to "
"pass these special parameters as arguments to the procedure."
msgstr ""

#: ../scilla-by-example.rst:642
msgid ""
"Procedures are similar to library functions in that they can be invoked "
"from any transition (as long as the transition is defined after the "
"procedure). However, procedures are different from library functions in "
"that library functions cannot access the contract state, and procedures "
"cannot return a value."
msgstr ""

#: ../scilla-by-example.rst:648
msgid ""
"Procedures are similar to transitions in that they can access and change "
"the contract state, as well as read the incoming messages and send "
"outgoing messages. However, procedures cannot be invoked from the "
"blockchain layer. Only transitions may be invoked from outside the "
"contract, so procedures can be viewed as private transitions."
msgstr ""

#: ../scilla-by-example.rst:660
msgid "The complete crowdfunding contract is given below."
msgstr ""

#: ../scilla-by-example.rst:851
msgid "A Third Example: A Simple Token Exchange"
msgstr ""

#: ../scilla-by-example.rst:853
msgid ""
"As a third example we look at how contracts written in Scilla can "
"interact by passing messages to each other, and by reading each other's "
"states. As our example application we choose a simplified token exchange "
"contracts in which users can place offers of swapping one type of "
"fungible tokens for another type."
msgstr ""

#: ../scilla-by-example.rst:860
msgid "Fungible Tokens"
msgstr ""

#: ../scilla-by-example.rst:862
msgid ""
"Recall that a fungible token is one which is indistinguishable from "
"another token of the same type. For example, a US $1 bank note is "
"indistinguishable from any other US $1 bank note (for the purposes of "
"using the bank note to pay for goods, services, or other tokens, at "
"least)."
msgstr ""

#: ../scilla-by-example.rst:868
msgid ""
"The `Zilliqa Reference Contracts <https://github.com/Zilliqa/ZRC>`_ "
"library offers specifications and reference implementations of commonly "
"used contract types, and the `ZRC2 "
"<https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-2.md>`_ standard "
"specifies a standard for fungible tokens, which we will use for this "
"example. We will not go into detail about how the token contract works, "
"but only point out a few important aspects that will be needed in order "
"to implement the token exchange."
msgstr ""

#: ../scilla-by-example.rst:879
msgid "Exchange Specification"
msgstr ""

#: ../scilla-by-example.rst:881
msgid "We want our simple exchange to support the following functionality:"
msgstr ""

#: ../scilla-by-example.rst:883
msgid ""
"The exchange has a number of listed tokens that can be freely swapped "
"with each other. Each listed token is identified by its token code (e.g.,"
" \"USD\" for US dollars)."
msgstr ""

#: ../scilla-by-example.rst:887
msgid ""
"The exchange should have an administrator at all times. The administrator"
" is in charge of approving token contracts, and listing them on the "
"exchange. The administrator may pass the administrator role on to someone"
" else."
msgstr ""

#: ../scilla-by-example.rst:892
msgid ""
"Any user can place an order on the exchange. To place an order, the user "
"specifies which token he wants to sell and how many of them he is "
"offering, and which token he wants to buy and how many he wants in "
"return. The contract keeps track of every active (unmatched) order."
msgstr ""

#: ../scilla-by-example.rst:898
msgid ""
"When a user attempts to place an order to sell some tokens, the exchange "
"checks that the user actually has those tokens to sell. If he does, then "
"the exchange claims those tokens and holds on to them until the order is "
"matched."
msgstr ""

#: ../scilla-by-example.rst:903
msgid ""
"Any user can match an active order on the exchange. To match an order, "
"the user specifies which order to match."
msgstr ""

#: ../scilla-by-example.rst:906
msgid ""
"When a user attempts to match an order, the exchange checks that the user"
" actually has the tokens that the order placer wants to buy. If he does, "
"then the exchange transfers the tokens that were claimed when the order "
"was placed to the order matcher, and transfers the tokens that the order "
"placer wants to buy from the order matcher to the order placer. After the"
" tokens have been transferred the exchange deletes the fulfilled order."
msgstr ""

#: ../scilla-by-example.rst:914
msgid ""
"To keep the example brief our exchange will not support unlisting of "
"tokens, cancellation of orders, orders with expiry time, prioritising "
"orders so that the order matcher gets the best deal possible, partial "
"matching of orders, securing the exchange against abuse, fees for trading"
" on the exchange, etc.. We encourage the reader to implement additional "
"features as a way to familiarise themselves even further with Scilla."
msgstr ""

#: ../scilla-by-example.rst:924
msgid "The Administrator Role"
msgstr ""

#: ../scilla-by-example.rst:926
msgid ""
"The exchange must have an administrator at all times, including when it "
"is first deployed. The administrator may change over time, so we define a"
" mutable field ``admin`` to keep track of the current administrator, and "
"initialise it to an ``initial_admin``, which is given as an immutable "
"parameter:"
msgstr ""

#: ../scilla-by-example.rst:941
msgid ""
"The type of the ``admin`` field is ``ByStr20 with end``, which is an "
"`address type`. As in the earlier examples ``ByStr20`` is the type of "
"byte strings of length 20, but we now add the addtional requirement that "
"when that byte string is interpreted as an address on the network, the "
"address must be `in use`, and the contents at that address must satisfy "
"whatever is between the ``with`` and ``end`` keywords."
msgstr ""

#: ../scilla-by-example.rst:949
msgid ""
"In this case there is nothing between ``with`` and ``end``, so we have no"
" additional requirements. However, the address must be in use, either by "
"a user or by another contract - otherwise Scilla will not accept it as "
"having a legal address type. (We will go into more detail about address "
"types when the exchange interacts with the listed token contracts.)"
msgstr ""

#: ../scilla-by-example.rst:956
msgid ""
"Multiple transitions will need to check that the ``_sender`` is the "
"current ``admin``, so let us define a procedure that checks that that is "
"the case:"
msgstr ""

#: ../scilla-by-example.rst:974
msgid ""
"If the ``_sender`` is the current administrator, then nothing happens, "
"and whichever transition called this procedure can continue. If the "
"``_sender`` is someone else, however, the procedure throws an `exception`"
" causing the current transaction to be aborted."
msgstr ""

#: ../scilla-by-example.rst:979
msgid ""
"We want the administrator to be able to pass on the administrator role to"
" someone else, so we define our first transition ``SetAdmin`` as follows:"
msgstr ""

#: ../scilla-by-example.rst:991
msgid ""
"The transition applies the ``CheckSenderIsAdmin`` procedure, and if no "
"exception is thrown then the sender is indeed the current administrator, "
"and is thus allowed to pass on the administrator role on to someone else."
" The new admin must once again be an address that is in use."
msgstr ""

#: ../scilla-by-example.rst:999
msgid "Intermezzo: Transferring Tokens On Behalf Of The Token Owner"
msgstr ""

#: ../scilla-by-example.rst:1001
msgid ""
"Before we continue adding features to our exchange we must first look at "
"how token contracts transfer tokens between users."
msgstr ""

#: ../scilla-by-example.rst:1004
msgid ""
"The ZRC2 token standard defines a field ``balances`` which keeps track of"
" how many tokens each user has:"
msgstr ""

#: ../scilla-by-example.rst:1011
msgid ""
"However, this is not particularly useful for our exchange, because the "
"token contract won't allow the exchange to transfer tokens belonging to "
"someone other than the exchange itself."
msgstr ""

#: ../scilla-by-example.rst:1015
msgid ""
"Instead, the ZRC2 standard defines a field ``allowances``, which a user "
"who owns tokens can use to allow another user partial access to the "
"owner's tokens:"
msgstr ""

#: ../scilla-by-example.rst:1023
msgid ""
"For instance, if Alice has given Bob an allowance of 100 tokens, then the"
" ``allowances`` map in token contract will contain the value "
"``allowances[<address of Alice>][<address of Bob>] = 100``. This allows "
"Bob to spend 100 of Alice's tokens as if they were his own. (Alice can of"
" course withdraw the allowance, as long as Bob hasn't yet spent the "
"tokens)."
msgstr ""

#: ../scilla-by-example.rst:1030
msgid ""
"Before a user places an order, the user should provide the exchange with "
"an allowance of the token he wants to sell to cover the order. The user "
"can then place the order, and the exchange can check that the allowance "
"is sufficient. The exchange then transfers the tokens to its own account "
"for holding until the order is matched."
msgstr ""

#: ../scilla-by-example.rst:1036
msgid ""
"Similarly, before a user matches an order, the user should provide the "
"exchange with an allowance of the token that the order placer wants to "
"buy. The user can then match the order, and the exchange can check that "
"the allowance is sufficent. The exchange then transfers those tokens to "
"the user who placed the order, and transfers to the matching user the "
"tokens that it transferred to itself when the order was placed."
msgstr ""

#: ../scilla-by-example.rst:1044
msgid ""
"In order to check the current allowance that a user has given to the "
"exchange, we will need to specify the ``allowances`` field in the token "
"address type. We do this as follows:"
msgstr ""

#: ../scilla-by-example.rst:1052
msgid ""
"As with the ``admin`` field we require that the address is in use. "
"Additionally, the requirements between ``with`` and ``end`` must also be "
"satisfied:"
msgstr ""

#: ../scilla-by-example.rst:1056
msgid ""
"The keyword ``contract`` specifies that the address must be in use by a "
"contract, and not by a user."
msgstr ""

#: ../scilla-by-example.rst:1059
msgid ""
"The keyword ``field`` specifies that the contract in question must "
"contain a mutable field with the specified name and of the specified "
"type."
msgstr ""

#: ../scilla-by-example.rst:1065
msgid "Listing a New Token"
msgstr ""

#: ../scilla-by-example.rst:1067
msgid ""
"The exchange keeps track of its listed tokens, i.e., which tokens are "
"allowed to be traded on the exchange. We do this by defining a map from "
"the token code (a ``String``) to the address of the token."
msgstr ""

#: ../scilla-by-example.rst:1081
msgid ""
"Only the administrator is allowed to list new tokens, so we leverage the "
"``CheckSenderIsAdmin`` procedure again here."
msgstr ""

#: ../scilla-by-example.rst:1084
msgid ""
"Additionally, we only want to list tokens that have a different token "
"code from the previously listed tokens. For this purpose we define a "
"procedure ``CheckIsTokenUnlisted`` to check whether a token code is "
"defined as a key in the ``listed_tokens`` map. :"
msgstr ""

#: ../scilla-by-example.rst:1126
msgid ""
"This time we define a helper procedure ``ThrowListingStatusException`` "
"which unconditionally throws an exception. This will be useful later when"
" we later write the transition for placing orders, because we will need "
"to check that the tokens involved in the order are listed."
msgstr ""

#: ../scilla-by-example.rst:1131
msgid ""
"We also define the constant ``false`` in the contract's library. This is "
"due to the fact that Scilla requires all values to be named before they "
"are used in computations. Defining constants in library code prevents us "
"from cluttering the transition code with constant definitions:"
msgstr ""

#: ../scilla-by-example.rst:1143
msgid ""
"With the helper procedures in place we are now ready to define the "
"``ListToken`` transition as follows:"
msgstr ""

#: ../scilla-by-example.rst:1161
msgid "Placing an Order"
msgstr ""

#: ../scilla-by-example.rst:1163
msgid ""
"To place an order a user must specify the token code and the amount of "
"the token he wants to sell, and the token code and amount he wants to "
"buy. We invoke the ``ThrowListingStatusException`` procedure if any of "
"the token codes are unlisted:"
msgstr ""

#: ../scilla-by-example.rst:1194
msgid ""
"If both tokens are listed, we must first check that the user has supplied"
" a sufficient allowance to the exchange. We will need a similar check "
"when another user matches the order, so we define a helper procedure "
"``CheckAllowance`` to perform the check:"
msgstr ""

#: ../scilla-by-example.rst:1208
msgid ""
"To perform the check we will need to perform a `remote read` of the "
"``allowances`` field in the token contract. We are interested in the "
"allowance given by the ``_sender`` to the exchange, whose address is "
"given by a special immutable field ``_this_address``, so we want to "
"remote read the value of ``allowances[_sender][_this_address]`` in the "
"token contract."
msgstr ""

#: ../scilla-by-example.rst:1215
msgid ""
"Remote reads in Scilla are performed using the operator ``<- &``, and we "
"use ``.`` notation to specify the contract that we want to remote read "
"from. The entire statement for the remote read is therefore as follows:"
msgstr ""

#: ../scilla-by-example.rst:1224
msgid ""
"Just as when we perform a local read of a map, the result of reading from"
" a remote map is an optional value. If the result is ``Some v`` for some "
"``v``, then the user has provided the exchange with an allowance of ``v``"
" tokens, and if the result is ``None`` the user has not supplied an "
"allowance at all. We therefore need to pattern-match the result to get "
"the actual allowance:"
msgstr ""

#: ../scilla-by-example.rst:1239
msgid ""
"Once again, we define the constant ``zero = Uint128 0`` in the contract "
"library for convenience."
msgstr ""

#: ../scilla-by-example.rst:1242
msgid ""
"We can now compare the actual allowance to the allowance we are "
"expecting, and throw an exception if the actual allowance is "
"insufficient:"
msgstr ""

#: ../scilla-by-example.rst:1255
msgid ""
"The function ``uint128_le`` is a utility function which performs a less-"
"than-or-equal comparison on values of type ``Uint128``. The function is "
"defined in the ``IntUtils`` part of the standard library, so in order to "
"use the function we must import ``IntUtils`` into the contract, which is "
"done immediately after the ``scilla_version`` preamble, and before the "
"contract library definitions:"
msgstr ""

#: ../scilla-by-example.rst:1272
msgid ""
"We also utilise a helper procedure "
"``ThrowInsufficientAllowanceException`` to throw an exception if the "
"allowance is insufficient, so the ``CheckAllowance`` procedure ends up "
"looking as follows:"
msgstr ""

#: ../scilla-by-example.rst:1334
msgid ""
"If the user has given the exchange a sufficient allowance, the exchange "
"can send a message to the token contract to perform the transfer of "
"tokens from the allowance the exchange's own balance. The transition we "
"need to invoke on the token contract is called ``TransferFrom``, as "
"opposed to ``Transfer`` which transfers funds from the sender's own token"
" balance rather than from the sender's allowance of someone else's "
"balance."
msgstr ""

#: ../scilla-by-example.rst:1342
msgid ""
"Since the message will look much like the messages that we need when an "
"order is matched, we generate the message using helper functions in the "
"contract library (we will also need a new constant ``true``):"
msgstr ""

#: ../scilla-by-example.rst:1422
msgid ""
"Finally, we need to store the new order, so that users may match the "
"order in the future. For this we define a new type ``Order``, which holds"
" all the information needed when eventually the order is matched:"
msgstr ""

#: ../scilla-by-example.rst:1436
msgid ""
"A value of type ``Order`` is given by the type constructor ``Order``, a "
"token address and an amount of tokens to sell, and a token address and an"
" amount of tokens to buy."
msgstr ""

#: ../scilla-by-example.rst:1440
msgid ""
"We now need a field containing a map from order numbers (of type "
"``Uint128``) to ``Order``, which represents the currently active orders. "
"Additionally, we will need a way to generate a unique order number, so "
"we'll define a field which holds the next order number to use:"
msgstr ""

#: ../scilla-by-example.rst:1452
msgid ""
"To add a new order we need to generate a new order number, store the "
"generated order number and the new order in the ``active_orders`` map, "
"and finally increment the ``next_order_no`` field (using the library "
"constant ``one = Uint128 1``) so that it is ready for the next order to "
"be placed. We will put that in a helper procedure ``AddOrder``, and add a"
" call to the procedure in the ``PlaceOrder`` transition:"
msgstr ""

#: ../scilla-by-example.rst:1505
msgid ""
"``PlaceOrder`` is now complete, but there is still one thing missing. The"
" `ZRC2` token standard specifies that when a ``TransferFrom`` transition "
"is executed, the token sends messages to the recipient and the "
"``_sender`` (known as the `initiator`) notifying them of the successful "
"transfer. These notifications are known as `callbacks`. Since our "
"exchange executes a ``TransferFrom`` transition on the sell token, and "
"since the exchange is the recipient of those tokens, we will need to "
"specify transitions that can handle both callbacks - if we don't, then "
"the callbacks will not be recognised, causing the entire ``PlaceOrder`` "
"transaction to fail."
msgstr ""

#: ../scilla-by-example.rst:1516
msgid ""
"Token contracts notify the recipients of token transfers because such "
"notifications add an extra safeguard against the risk of transferring "
"tokens to a contract that is unable to deal with token ownership. For "
"instance, if someone were to transfer tokens to the ``HelloWorld`` "
"contract in the first example in this section, then the tokens would be "
"locked forever because the ``HelloWorld`` contract is incapable of doing "
"anything with the tokens."
msgstr ""

#: ../scilla-by-example.rst:1524
msgid ""
"Our exchange is only capable of dealing with tokens for which there is an"
" active order, but in principle there is nothing stopping a user from "
"transferring funds to the exchange without placing an order, so we need "
"to ensure that the exchange is only involved in token transfers that it "
"itself has initiated. We therefore define a procedure ``CheckInitiator``,"
" which throws an exception if the exchange is involved in a token "
"transfer that it itself did not initiate, and invoke that procedure from "
"all callback transitions:"
msgstr ""

#: ../scilla-by-example.rst:1566
msgid "Matching an Order"
msgstr ""

#: ../scilla-by-example.rst:1568
msgid ""
"For the ``MatchOrder`` transition we can leverage many of the helper "
"functions and procedures defined in the previous section."
msgstr ""

#: ../scilla-by-example.rst:1571
msgid ""
"The user specifies an order he wishes to match. We then look up the order"
" number in the ``active_orders`` map, and throw an exception if the order"
" is not found:"
msgstr ""

#: ../scilla-by-example.rst:1590
msgid ""
"In order to match the order, the matcher has to provide sufficient "
"allowance of the buy token. This is checked by the ``CheckAllowance`` "
"procedure we defined earlier, so we simply reuse that procedure here:"
msgstr ""

#: ../scilla-by-example.rst:1611
msgid ""
"We now need to generate two transfer messages: One message is a "
"``TransferFrom`` message on the buy token, transferring the matcher's "
"allowance to the user who placed the order, and the other message is a "
"``Transfer`` message on the sell token, transferring the tokens held by "
"the exchange to the order matcher. Once again, we define helper functions"
" to generate the messages:"
msgstr ""

#: ../scilla-by-example.rst:1670
msgid ""
"Since the order has now been matched, it should no longer be listed as an"
" active order, so we delete the entry in ``active_orders``:"
msgstr ""

#: ../scilla-by-example.rst:1694
msgid ""
"This concludes the ``MatchOrder`` transition, but we need to define one "
"additional callback transition. When placing an order we executed a "
"``TransferFrom`` transition, but now we also execute a ``Transfer`` "
"transition, which gives rise to a different callback:"
msgstr ""

#: ../scilla-by-example.rst:1710
msgid ""
"Note that we do not need to specify a transition handling the receipt of "
"tokens from a ``Transfer`` transition, because the exchange never "
"executes a ``Transfer`` with itself as the recipient. By not defining the"
" callback transition at all, we also take care of the situation where a "
"user performs a ``Transfer`` with the exchange as the recipient, because "
"the recipient callback won't have a matching transition on the exchange, "
"causing the entire transfer transaction to fail."
msgstr ""

#: ../scilla-by-example.rst:1722
msgid "We now have everything in place to specify the entire contract:"
msgstr ""

#: ../scilla-by-example.rst:2027
msgid ""
"As mentioned in the introduction we have kept the exchange simplistic in "
"order to keep the focus on Scilla features."
msgstr ""

#: ../scilla-by-example.rst:2030
msgid ""
"To further familiarise themselves with Scilla we encourage the reader to "
"add additional features such as unlisting of tokens, cancellation of "
"orders, orders with expiry time, prioritising orders so that the order "
"matcher gets the best deal possible, partial matching of orders, securing"
" the exchange against abuse, fees for trading on the exchange, etc.."
msgstr ""

